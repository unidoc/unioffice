//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_a "archive/zip";_fb "bytes";_aae "encoding/xml";_af "fmt";_dge "github.com/unidoc/unioffice";_dg "github.com/unidoc/unioffice/algo";_dc "github.com/unidoc/unioffice/common/tempstorage";_dd "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_aa "io";_d "path";_gg "sort";_ae "strings";_g "time";);func MarshalXMLByType (z *_a .Writer ,dt _dge .DocType ,typ string ,v interface{})error {_efa :=_dge .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_efa ,v );};func MarshalXMLByTypeIndex (z *_a .Writer ,dt _dge .DocType ,typ string ,idx int ,v interface{})error {_ad :=_dge .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_ad ,v );};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_a .Writer ,zipPath string ,data []byte )error {_afg ,_dea :=z .Create (zipPath );if _dea !=nil {return _af .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_dea );};_ ,_dea =_aa .Copy (_afg ,_fb .NewReader (data ));return _dea ;};var _ege =[]byte {'/','>'};func (_edg SelfClosingWriter )Write (b []byte )(int ,error ){_afb :=0;_egg :=0;for _gda :=0;_gda < len (b )-2;_gda ++{if b [_gda ]=='>'&&b [_gda +1]=='<'&&b [_gda +2]=='/'{_acaf :=[]byte {};_afe :=_gda ;for _gfg :=_gda ;_gfg >=0;_gfg --{if b [_gfg ]==' '{_afe =_gfg ;}else if b [_gfg ]=='<'{_acaf =b [_gfg +1:_afe ];break ;};};_ggd :=[]byte {};for _dfc :=_gda +3;_dfc < len (b );_dfc ++{if b [_dfc ]=='>'{_ggd =b [_gda +3:_dfc ];break ;};};if !_fb .Equal (_acaf ,_ggd ){continue ;};_cec ,_dca :=_edg .W .Write (b [_afb :_gda ]);if _dca !=nil {return _egg +_cec ,_dca ;};_egg +=_cec ;_ ,_dca =_edg .W .Write (_ege );if _dca !=nil {return _egg ,_dca ;};_egg +=3;for _gde :=_gda +2;_gde < len (b )&&b [_gde ]!='>';_gde ++{_egg ++;_afb =_gde +2;_gda =_afb ;};};};_bc ,_eba :=_edg .W .Write (b [_afb :]);return _bc +_egg ,_eba ;};func (_bg *DecodeMap )IndexFor (path string )int {return _bg ._fbc [path ]};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _aa .Writer ;};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_a .File ,path string )(string ,error ){_cda ,_ed :=_dc .TempFile (path ,"\u007a\u007a");if _ed !=nil {return "",_ed ;};defer _cda .Close ();_eee ,_ed :=f .Open ();if _ed !=nil {return "",_ed ;};defer _eee .Close ();_ ,_ed =_aa .Copy (_cda ,_eee );if _ed !=nil {return "",_ed ;};return _cda .Name (),nil ;};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_a .File ,dest interface{})error {_efc ,_fbe :=f .Open ();if _fbe !=nil {return _af .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_fbe );};defer _efc .Close ();_efg :=_aae .NewDecoder (_efc );if _dfd :=_efg .Decode (dest );_dfd !=nil {return _af .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_dfd );};if _fbcg ,_ggc :=dest .(*_dd .Relationships );_ggc {for _ba ,_cbca :=range _fbcg .Relationship {switch _cbca .TypeAttr {case _dge .OfficeDocumentTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .OfficeDocumentType ;case _dge .StylesTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .StylesType ;case _dge .ThemeTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .ThemeType ;case _dge .SettingsTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .SettingsType ;case _dge .ImageTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .ImageType ;case _dge .CommentsTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .CommentsType ;case _dge .ThumbnailTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .ThumbnailType ;case _dge .DrawingTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .DrawingType ;case _dge .ChartTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .ChartType ;case _dge .ExtendedPropertiesTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .ExtendedPropertiesType ;case _dge .CustomXMLTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .CustomXMLType ;case _dge .WorksheetTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .WorksheetType ;case _dge .SharedStringsTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .SharedStringsType ;case _dge .TableTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .TableType ;case _dge .HeaderTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .HeaderType ;case _dge .FooterTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .FooterType ;case _dge .NumberingTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .NumberingType ;case _dge .FontTableTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .FontTableType ;case _dge .WebSettingsTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .WebSettingsType ;case _dge .FootNotesTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .FootNotesType ;case _dge .EndNotesTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .EndNotesType ;case _dge .SlideTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .SlideType ;case _dge .VMLDrawingTypeStrict :_fbcg .Relationship [_ba ].TypeAttr =_dge .VMLDrawingType ;};};_gg .Slice (_fbcg .Relationship ,func (_gcb ,_aaa int )bool {_ee :=_fbcg .Relationship [_gcb ];_bf :=_fbcg .Relationship [_aaa ];return _dg .NaturalLess (_ee .IdAttr ,_bf .IdAttr );});};return nil ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_a .Writer ,filename string ,v interface{})error {_dbcc :=&_a .FileHeader {};_dbcc .Method =_a .Deflate ;_dbcc .Name =filename ;_dbcc .SetModTime (_g .Now ());_eda ,_ec :=z .CreateHeader (_dbcc );if _ec !=nil {return _af .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_ec );};_ ,_ec =_eda .Write ([]byte (XMLHeader ));if _ec !=nil {return _af .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_ec );};if _ec =_aae .NewEncoder (SelfClosingWriter {_eda }).Encode (v );_ec !=nil {return _af .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_ec );};_ ,_ec =_eda .Write (_ga );return _ec ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_c *DecodeMap ,_fa ,_ag string ,_cb []*_a .File ,_gb *_dd .Relationship ,_db Target )error ;

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_ac *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _ac ._gf ==nil {_ac ._gf =make (map[string ]Target );_ac ._gd =make (map[*_dd .Relationships ]string );_ac ._ab =make (map[string ]struct{});_ac ._fbc =make (map[string ]int );};_gbb :=_d .Clean (filePath );if _ ,_e :=_ac ._ab [_gbb ];_e {return false ;};_ac ._ab [_gbb ]=struct{}{};_ac ._gf [_gbb ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};var _ga =[]byte {'\r','\n'};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// Decode loops decoding targets registered with AddTarget and calling th
func (_df *DecodeMap )Decode (files []*_a .File )error {_gc :=1;for _gc > 0{for len (_df ._ggb )> 0{_cf :=_df ._ggb [len (_df ._ggb )-1];_df ._ggb =_df ._ggb [0:len (_df ._ggb )-1];_cbc :=_cf .Ifc .(*_dd .Relationships );for _ ,_bb :=range _cbc .Relationship {_be ,_ :=_df ._gd [_cbc ];_df ._b (_df ,_be +_bb .TargetAttr ,_bb .TypeAttr ,files ,_bb ,_cf );};};for _eb ,_cd :=range files {if _cd ==nil {continue ;};if _fbf ,_fc :=_df ._gf [_cd .Name ];_fc {delete (_df ._gf ,_cd .Name );if _egb :=Decode (_cd ,_fbf .Ifc );_egb !=nil {return _egb ;};files [_eb ]=nil ;if _ebd ,_aef :=_fbf .Ifc .(*_dd .Relationships );_aef {_df ._ggb =append (_df ._ggb ,_fbf );_deb ,_ :=_d .Split (_d .Clean (_cd .Name +"\u002f\u002e\u002e\u002f"));_df ._gd [_ebd ]=_deb ;_gc ++;};};};_gc --;};return nil ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_ge *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_ge ._b =fn };

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_gf map[string ]Target ;_gd map[*_dd .Relationships ]string ;_ggb []Target ;_b OnNewRelationshipFunc ;_ab map[string ]struct{};_fbc map[string ]int ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ef :=_ae .Split (path ,"\u002f");_aca :=_ae .Join (_ef [0:len (_ef )-1],"\u002f");_aaf :=_ef [len (_ef )-1];_aca +="\u002f_\u0072\u0065\u006c\u0073\u002f";_aaf +="\u002e\u0072\u0065l\u0073";return _aca +_aaf ;};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_a .Writer ,zipPath ,storagePath string )error {_ce ,_faf :=z .Create (zipPath );if _faf !=nil {return _af .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_faf );};_fg ,_faf :=_dc .Open (storagePath );if _faf !=nil {return _af .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_faf );};defer _fg .Close ();_ ,_faf =_aa .Copy (_ce ,_fg );return _faf ;};func (_de *DecodeMap )RecordIndex (path string ,idx int ){_de ._fbc [path ]=idx };