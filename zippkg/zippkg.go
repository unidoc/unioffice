//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_fa "archive/zip";_ab "bytes";_a "encoding/xml";_faf "fmt";_ac "github.com/unidoc/unioffice/v2";_gb "github.com/unidoc/unioffice/v2/common/tempstorage";_c "github.com/unidoc/unioffice/v2/internal/sort";_bf "github.com/unidoc/unioffice/v2/schema/soo/pkg/relationships";
_fc "io";_g "path";_e "sort";_b "strings";_fb "time";);

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_aa *DecodeMap ,_bd ,_cg string ,_bfb []*_fa .File ,_cd *_bf .Relationship ,_fe Target )error ;

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_fa .Writer ,filename string ,v interface{})error {_fba :=&_fa .FileHeader {};_fba .Method =_fa .Deflate ;_fba .Name =filename ;_fba .SetModTime (_fb .Now ());_dfgd ,_fae :=z .CreateHeader (_fba );if _fae !=nil {return _faf .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_fae );
};_ ,_fae =_dfgd .Write ([]byte (XMLHeader ));if _fae !=nil {return _faf .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_fae );
};if _fae =_a .NewEncoder (SelfClosingWriter {_dfgd }).Encode (v );_fae !=nil {return _faf .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_fae );};_ ,_fae =_dfgd .Write (_ade );return _fae ;
};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_fa .Writer ,zipPath string ,data []byte )error {_aae ,_beg :=z .Create (zipPath );if _beg !=nil {return _faf .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_beg );
};_ ,_beg =_fc .Copy (_aae ,_ab .NewReader (data ));return _beg ;};

// AddFileFromStorage reads a file from internal storage and adds it at a given path to a zip file.
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromStorage (z *_fa .Writer ,zipPath ,storagePath string )error {_cb ,_fec :=z .Create (zipPath );if _fec !=nil {return _faf .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_fec );
};_bcc ,_fec :=_gb .Open (storagePath );if _fec !=nil {return _faf .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_fec );};defer _bcc .Close ();_ ,_fec =_fc .Copy (_cb ,_bcc );return _fec ;
};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func (_fg *DecodeMap )IndexFor (path string )int {return _fg ._bb [path ]};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_fa .File ,path string )(string ,error ){_bdd ,_fcf :=_gb .TempFile (path ,"\u007a\u007a");if _fcf !=nil {return "",_fcf ;};defer _bdd .Close ();_dbf ,_fcf :=f .Open ();if _fcf !=nil {return "",_fcf ;};defer _dbf .Close ();_ ,_fcf =_fc .Copy (_bdd ,_dbf );
if _fcf !=nil {return "",_fcf ;};return _bdd .Name (),nil ;};var _ade =[]byte {'\r','\n'};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_cdg *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_cdg ._cec =fn };

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_abe *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _abe ._ec ==nil {_abe ._ec =make (map[string ]Target );_abe ._ce =make (map[*_bf .Relationships ]string );_abe ._gg =make (map[string ]struct{});
_abe ._bb =make (map[string ]int );};if _g .IsAbs (filePath ){filePath =_b .TrimPrefix (filePath ,"\u002f");};_d :=_g .Clean (filePath );if _ ,_cdb :=_abe ._gg [_d ];_cdb {return false ;};_abe ._gg [_d ]=struct{}{};_abe ._ec [_d ]=Target {Path :_d ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };
return true ;};func MarshalXMLByTypeIndex (z *_fa .Writer ,dt _ac .DocType ,typ string ,idx int ,v interface{})error {_bef :=_ac .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_bef ,v );};var _dec =[]byte {'/','>'};func (_gba *DecodeMap )RecordIndex (path string ,idx int ){_gba ._bb [path ]=idx };
func (_cf SelfClosingWriter )Write (b []byte )(int ,error ){_fag :=0;_fgf :=0;for _caga :=0;_caga < len (b )-2;_caga ++{if b [_caga ]=='>'&&b [_caga +1]=='<'&&b [_caga +2]=='/'{_ag :=[]byte {};_ge :=_caga ;for _bgg :=_caga ;_bgg >=0;_bgg --{if b [_bgg ]==' '{_ge =_bgg ;
}else if b [_bgg ]=='<'{_ag =b [_bgg +1:_ge ];break ;};};_ee :=[]byte {};for _aba :=_caga +3;_aba < len (b );_aba ++{if b [_aba ]=='>'{_ee =b [_caga +3:_aba ];break ;};};if !_ab .Equal (_ag ,_ee ){continue ;};_ega ,_cea :=_cf .W .Write (b [_fag :_caga ]);
if _cea !=nil {return _fgf +_ega ,_cea ;};_fgf +=_ega ;_ ,_cea =_cf .W .Write (_dec );if _cea !=nil {return _fgf ,_cea ;};_fgf +=3;for _dfa :=_caga +2;_dfa < len (b )&&b [_dfa ]!='>';_dfa ++{_fgf ++;_fag =_dfa +2;_caga =_fag ;};};};_dd ,_bde :=_cf .W .Write (b [_fag :]);
return _dd +_fgf ,_bde ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_fbg *DecodeMap )Decode (files []*_fa .File )error {_gf :=1;for _gf > 0{for len (_fbg ._bc )> 0{_gfd :=_fbg ._bc [0];_fbg ._bc =_fbg ._bc [1:];_ed :=_gfd .Ifc .(*_bf .Relationships );for _ ,_abb :=range _ed .Relationship {_bcd :=_fbg ._ce [_ed ];
_cdd :=_b .TrimPrefix (_abb .TargetAttr ,"\u002f");if _b .HasPrefix (_abb .TargetAttr ,"\u002f"){_ =_fbg ._cec (_fbg ,_cdd ,_abb .TypeAttr ,files ,_abb ,_gfd );}else {if _b .IndexByte (_bcd ,'/')> -1{_be :=_bcd [:_b .IndexByte (_bcd ,'/')+1];if _b .HasPrefix (_cdd ,_be ){_bcd ="";
};};if _b .HasPrefix (_cdd ,_bcd ){_bcd ="";};_ =_fbg ._cec (_fbg ,_bcd +_cdd ,_abb .TypeAttr ,files ,_abb ,_gfd );};};};for _ae ,_ecg :=range files {if _ecg ==nil {continue ;};if _eg ,_fge :=_fbg ._ec [_ecg .Name ];_fge {delete (_fbg ._ec ,_ecg .Name );
if _ad :=Decode (_ecg ,_eg .Ifc );_ad !=nil {return _ad ;};files [_ae ]=nil ;if _aaf ,_abc :=_eg .Ifc .(*_bf .Relationships );_abc {_fbg ._bc =append (_fbg ._bc ,_eg );_de ,_ :=_g .Split (_g .Clean (_ecg .Name +"\u002f\u002e\u002e\u002f"));_fbg ._ce [_aaf ]=_de ;
_gf ++;};};};_gf --;};return nil ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ec map[string ]Target ;_ce map[*_bf .Relationships ]string ;_bc []Target ;_cec OnNewRelationshipFunc ;_gg map[string ]struct{};_bb map[string ]int ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _fc .Writer ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";
func MarshalXMLByType (z *_fa .Writer ,dt _ac .DocType ,typ string ,v interface{})error {_dbd :=_ac .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_dbd ,v );};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_bg :=_b .Split (path ,"\u002f");_db :=_b .Join (_bg [0:len (_bg )-1],"\u002f");_ga :=_bg [len (_bg )-1];_db +="\u002f_\u0072\u0065\u006c\u0073\u002f";_ga +="\u002e\u0072\u0065l\u0073";return _db +_ga ;};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_fa .File ,dest interface{})error {_ea ,_cda :=f .Open ();if _cda !=nil {return _faf .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_cda );};defer _ea .Close ();_eae :=_a .NewDecoder (_ea );
if _ebf :=_eae .Decode (dest );_ebf !=nil {return _faf .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_ebf );};if _ca ,_dfg :=dest .(*_bf .Relationships );_dfg {for _ff ,_edg :=range _ca .Relationship {switch _edg .TypeAttr {case _ac .OfficeDocumentTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .OfficeDocumentType ;
case _ac .StylesTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .StylesType ;case _ac .ThemeTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .ThemeType ;case _ac .ControlTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .ControlType ;case _ac .SettingsTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .SettingsType ;
case _ac .ImageTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .ImageType ;case _ac .CommentsTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .CommentsType ;case _ac .ThumbnailTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .ThumbnailType ;case _ac .DrawingTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .DrawingType ;
case _ac .ChartTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .ChartType ;case _ac .ExtendedPropertiesTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .ExtendedPropertiesType ;case _ac .CustomXMLTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .CustomXMLType ;
case _ac .WorksheetTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .WorksheetType ;case _ac .SharedStringsTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .SharedStringsType ;case _ac .TableTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .TableType ;
case _ac .HeaderTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .HeaderType ;case _ac .FooterTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .FooterType ;case _ac .NumberingTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .NumberingType ;case _ac .FontTableTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .FontTableType ;
case _ac .WebSettingsTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .WebSettingsType ;case _ac .FootNotesTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .FootNotesType ;case _ac .EndNotesTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .EndNotesType ;
case _ac .SlideTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .SlideType ;case _ac .VMLDrawingTypeStrict :_ca .Relationship [_ff ].TypeAttr =_ac .VMLDrawingType ;};};_e .Slice (_ca .Relationship ,func (_dc ,_fcg int )bool {_cag :=_ca .Relationship [_dc ];
_gd :=_ca .Relationship [_fcg ];return _c .NaturalCompare (_cag .IdAttr ,_gd .IdAttr );});};return nil ;};