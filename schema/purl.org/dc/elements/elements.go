//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package elements ;import (_d "encoding/xml";_g "fmt";_b "github.com/unidoc/unioffice";);type Any struct{SimpleLiteral };func NewAny ()*Any {_bc :=&Any {};_bc .SimpleLiteral =*NewSimpleLiteral ();return _bc };func NewElementsGroupChoice ()*ElementsGroupChoice {_db :=&ElementsGroupChoice {};return _db };func (_aa *ElementsGroup )UnmarshalXML (d *_d .Decoder ,start _d .StartElement )error {_dd :for {_eg ,_gec :=d .Token ();if _gec !=nil {return _gec ;};switch _ea :=_eg .(type ){case _d .StartElement :switch _ea .Name {case _d .Name {Space :"\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f",Local :"\u0061\u006e\u0079"}:_df :=NewElementsGroupChoice ();if _ga :=d .DecodeElement (&_df .Any ,&_ea );_ga !=nil {return _ga ;};_aa .Choice =append (_aa .Choice ,_df );default:_b .Log ("\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0045\u006c\u0065\u006de\u006e\u0074\u0073\u0047\u0072\u006f\u0075\u0070 \u0025\u0076",_ea .Name );if _egc :=d .Skip ();_egc !=nil {return _egc ;};};case _d .EndElement :break _dd ;case _d .CharData :};};return nil ;};func NewElementContainer ()*ElementContainer {_bba :=&ElementContainer {};return _bba };func (_afc *SimpleLiteral )UnmarshalXML (d *_d .Decoder ,start _d .StartElement )error {for {_ebc ,_cda :=d .Token ();if _cda !=nil {return _g .Errorf ("\u0070a\u0072\u0073\u0069\u006eg\u0020\u0053\u0069\u006d\u0070l\u0065L\u0069t\u0065\u0072\u0061\u006c\u003a\u0020\u0025s",_cda );};if _ddf ,_ggdf :=_ebc .(_d .EndElement );_ggdf &&_ddf .Name ==start .Name {break ;};};return nil ;};func (_da *SimpleLiteral )MarshalXML (e *_d .Encoder ,start _d .StartElement )error {e .EncodeToken (start );e .EncodeToken (_d .EndElement {Name :start .Name });return nil ;};func (_gd *Any )MarshalXML (e *_d .Encoder ,start _d .StartElement )error {return _gd .SimpleLiteral .MarshalXML (e ,start );};type ElementContainer struct{Choice []*ElementsGroupChoice ;};func (_af *ElementsGroupChoice )MarshalXML (e *_d .Encoder ,start _d .StartElement )error {if _af .Any !=nil {_gfd :=_d .StartElement {Name :_d .Name {Local :"\u0064\u0063\u003a\u0061\u006e\u0079"}};for _ ,_dga :=range _af .Any {e .EncodeElement (_dga ,_gfd );};};return nil ;};type ElementsGroup struct{Choice []*ElementsGroupChoice ;};func NewElementsGroup ()*ElementsGroup {_bbe :=&ElementsGroup {};return _bbe };func (_ecb *ElementsGroupChoice )UnmarshalXML (d *_d .Decoder ,start _d .StartElement )error {_aab :for {_eeg ,_dc :=d .Token ();if _dc !=nil {return _dc ;};switch _cbg :=_eeg .(type ){case _d .StartElement :switch _cbg .Name {case _d .Name {Space :"\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f",Local :"\u0061\u006e\u0079"}:_fd :=NewAny ();if _ba :=d .DecodeElement (_fd ,&_cbg );_ba !=nil {return _ba ;};_ecb .Any =append (_ecb .Any ,_fd );default:_b .Log ("\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020o\u006e\u0020\u0045\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u0047\u0072ou\u0070\u0043\u0068\u006f\u0069\u0063\u0065\u0020\u0025\u0076",_cbg .Name );if _dde :=d .Skip ();_dde !=nil {return _dde ;};};case _d .EndElement :break _aab ;case _d .CharData :};};return nil ;};func NewSimpleLiteral ()*SimpleLiteral {_egd :=&SimpleLiteral {};return _egd };

// ValidateWithPath validates the Any and its children, prefixing error messages with path
func (_adg *Any )ValidateWithPath (path string )error {if _bbc :=_adg .SimpleLiteral .ValidateWithPath (path );_bbc !=nil {return _bbc ;};return nil ;};func (_bcc *Any )UnmarshalXML (d *_d .Decoder ,start _d .StartElement )error {_bcc .SimpleLiteral =*NewSimpleLiteral ();for {_de ,_a :=d .Token ();if _a !=nil {return _g .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u0041\u006e\u0079\u003a\u0020\u0025\u0073",_a );};if _c ,_ad :=_de .(_d .EndElement );_ad &&_c .Name ==start .Name {break ;};};return nil ;};

// Validate validates the ElementsGroupChoice and its children
func (_gfbc *ElementsGroupChoice )Validate ()error {return _gfbc .ValidateWithPath ("\u0045\u006c\u0065\u006den\u0074\u0073\u0047\u0072\u006f\u0075\u0070\u0043\u0068\u006f\u0069\u0063\u0065");};func (_cb *ElementContainer )UnmarshalXML (d *_d .Decoder ,start _d .StartElement )error {_ed :for {_cd ,_bg :=d .Token ();if _bg !=nil {return _bg ;};switch _gf :=_cd .(type ){case _d .StartElement :switch _gf .Name {case _d .Name {Space :"\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f",Local :"\u0061\u006e\u0079"}:_eb :=NewElementsGroupChoice ();if _ee :=d .DecodeElement (&_eb .Any ,&_gf );_ee !=nil {return _ee ;};_cb .Choice =append (_cb .Choice ,_eb );default:_b .Log ("\u0073\u006b\u0069\u0070\u0070i\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0045\u006c\u0065\u006d\u0065\u006e\u0074\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0025v",_gf .Name );if _dg :=d .Skip ();_dg !=nil {return _dg ;};};case _d .EndElement :break _ed ;case _d .CharData :};};return nil ;};

// ValidateWithPath validates the SimpleLiteral and its children, prefixing error messages with path
func (_deb *SimpleLiteral )ValidateWithPath (path string )error {return nil };

// ValidateWithPath validates the ElementsGroup and its children, prefixing error messages with path
func (_bcg *ElementsGroup )ValidateWithPath (path string )error {for _eba ,_ec :=range _bcg .Choice {if _ab :=_ec .ValidateWithPath (_g .Sprintf ("\u0025\u0073\u002f\u0043\u0068\u006f\u0069\u0063\u0065\u005b\u0025\u0064\u005d",path ,_eba ));_ab !=nil {return _ab ;};};return nil ;};

// Validate validates the ElementsGroup and its children
func (_ggd *ElementsGroup )Validate ()error {return _ggd .ValidateWithPath ("\u0045\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u0047\u0072\u006f\u0075\u0070");};

// ValidateWithPath validates the ElementsGroupChoice and its children, prefixing error messages with path
func (_eac *ElementsGroupChoice )ValidateWithPath (path string )error {for _fg ,_bcb :=range _eac .Any {if _ac :=_bcb .ValidateWithPath (_g .Sprintf ("\u0025\u0073\u002f\u0041\u006e\u0079\u005b\u0025\u0064\u005d",path ,_fg ));_ac !=nil {return _ac ;};};return nil ;};

// Validate validates the ElementContainer and its children
func (_gfb *ElementContainer )Validate ()error {return _gfb .ValidateWithPath ("\u0045\u006ce\u006d\u0065\u006et\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072");};type SimpleLiteral struct{};func (_ge *ElementContainer )MarshalXML (e *_d .Encoder ,start _d .StartElement )error {start .Name .Local ="\u0065\u006ce\u006d\u0065\u006et\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072";e .EncodeToken (start );if _ge .Choice !=nil {for _ ,_ca :=range _ge .Choice {_ca .MarshalXML (e ,_d .StartElement {});};};e .EncodeToken (_d .EndElement {Name :start .Name });return nil ;};func (_bf *ElementsGroup )MarshalXML (e *_d .Encoder ,start _d .StartElement )error {if _bf .Choice !=nil {for _ ,_gee :=range _bf .Choice {_gee .MarshalXML (e ,_d .StartElement {});};};return nil ;};

// Validate validates the SimpleLiteral and its children
func (_cg *SimpleLiteral )Validate ()error {return _cg .ValidateWithPath ("\u0053\u0069\u006d\u0070\u006c\u0065\u004c\u0069\u0074\u0065\u0072\u0061\u006c");};type ElementsGroupChoice struct{Any []*Any ;};

// Validate validates the Any and its children
func (_bb *Any )Validate ()error {return _bb .ValidateWithPath ("\u0041\u006e\u0079")};

// ValidateWithPath validates the ElementContainer and its children, prefixing error messages with path
func (_cae *ElementContainer )ValidateWithPath (path string )error {for _fb ,_ef :=range _cae .Choice {if _gg :=_ef .ValidateWithPath (_g .Sprintf ("\u0025\u0073\u002f\u0043\u0068\u006f\u0069\u0063\u0065\u005b\u0025\u0064\u005d",path ,_fb ));_gg !=nil {return _gg ;};};return nil ;};func init (){_b .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0053\u0069\u006d\u0070\u006c\u0065\u004c\u0069\u0074\u0065\u0072\u0061\u006c",NewSimpleLiteral );_b .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0065\u006ce\u006d\u0065\u006et\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072",NewElementContainer );_b .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0061\u006e\u0079",NewAny );_b .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u0047\u0072\u006f\u0075\u0070",NewElementsGroup );};