//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_db "encoding/hex";_a "errors";_de "fmt";_fg "github.com/unidoc/unioffice/common/tempstorage";_f "io";_d "io/ioutil";_ga "math/rand";_fe "sync";);

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_ba :=memStorage {_bg :_fe .Map {}};_fg .SetAsStorage (&_ba )};

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_gb *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_gbb :=_gb ._ab ._bf ;_fd :=int64 (len (p ));if _fd > _gbb {_fd =_gbb ;p =p [:_fd ];};if readOffset >=_gbb {return 0,_f .EOF ;};_ad :=readOffset +_fd ;if _ad >=_gbb {_ad =_gbb ;};_cg :=copy (p ,_gb ._ab ._gaa [readOffset :_ad ]);
return _cg ,nil ;};type memStorage struct{_bg _fe .Map };type memFile struct{_ab *memDataCell ;_b int64 ;};

// RemoveAll removes all files according to the dir argument prefix
func (_bea *memStorage )RemoveAll (dir string )error {_bea ._bg .Range (func (_dfc ,_egf interface{})bool {_bea ._bg .Delete (_dfc );return true });return nil ;};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_df *memFile )Read (p []byte )(int ,error ){_e :=_df ._b ;_c :=_df ._ab ._bf ;_dee :=int64 (len (p ));if _dee > _c {_dee =_c ;p =p [:_dee ];};if _e >=_c {return 0,_f .EOF ;};_ca :=_e +_dee ;if _ca >=_c {_ca =_c ;};_ec :=copy (p ,_df ._ab ._gaa [_e :_ca ]);
_df ._b =_ca ;return _ec ,nil ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_fa *memStorage )TempDir (pattern string )(string ,error ){return _cc (pattern ),nil };

// Name returns the filename of the underlying memDataCell
func (_dbd *memFile )Name ()string {return _dbd ._ab ._dfb };

// TempFile creates a new empty file in the storage and returns it
func (_eg *memStorage )TempFile (dir ,pattern string )(_fg .File ,error ){_deb :=dir +"\u002f"+_cc (pattern );_gg :=&memDataCell {_dfb :_deb ,_gaa :[]byte {}};_ac :=&memFile {_ab :_gg };_eg ._bg .Store (_deb ,_gg );return _ac ,nil ;};

// Open returns tempstorage File object by name
func (_be *memStorage )Open (path string )(_fg .File ,error ){_bb ,_fc :=_be ._bg .Load (path );if !_fc {return nil ,_a .New (_de .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));
};return &memFile {_ab :_bb .(*memDataCell )},nil ;};type memDataCell struct{_dfb string ;_gaa []byte ;_bf int64 ;};

// Add reads a file from a disk and adds it to the storage
func (_cf *memStorage )Add (path string )error {_ ,_dg :=_cf ._bg .Load (path );if _dg {return nil ;};_aa ,_bgf :=_d .ReadFile (path );if _bgf !=nil {return _bgf ;};_cf ._bg .Store (path ,&memDataCell {_dfb :path ,_gaa :_aa ,_bf :int64 (len (_aa ))});return nil ;
};func _cc (_gae string )string {_dga ,_ :=_gc (6);return _gae +_dga };

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_cb *memFile )Write (p []byte )(int ,error ){_cb ._ab ._gaa =append (_cb ._ab ._gaa ,p ...);_cb ._ab ._bf +=int64 (len (p ));return len (p ),nil ;};func _gc (_cbd int )(string ,error ){_gag :=make ([]byte ,_cbd );if _ ,_aae :=_ga .Read (_gag );_aae !=nil {return "",_aae ;
};return _db .EncodeToString (_gag ),nil ;};

// Close is not applicable in this implementation
func (_ed *memFile )Close ()error {return nil };