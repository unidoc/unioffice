//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_cf "encoding/hex";_cg "errors";_f "fmt";_a "github.com/unidoc/unioffice/v2/common/tempstorage";_d "io";_ef "io/ioutil";_e "math/rand";_c "sync";);

// Name returns the filename of the underlying memDataCell
func (_gc *memFile )Name ()string {return _gc ._fa ._fbd };

// Close is not applicable in this implementation
func (_ga *memFile )Close ()error {return nil };type memDataCell struct{_fbd string ;_ca []byte ;_gd int64 ;};

// TempFile creates a new empty file in the storage and returns it
func (_edf *memStorage )TempFile (dir ,pattern string )(_a .File ,error ){_cee :=dir +"\u002f"+_be (pattern );_de :=&memDataCell {_fbd :_cee ,_ca :[]byte {}};_cae :=&memFile {_fa :_de };_edf ._ecg .Store (_cee ,_de );return _cae ,nil ;};

// Open returns tempstorage File object by name
func (_ea *memStorage )Open (path string )(_a .File ,error ){_egg ,_bb :=_ea ._ecg .Load (path );if !_bb {return nil ,_cg .New (_f .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));
};return &memFile {_fa :_egg .(*memDataCell )},nil ;};

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_bg :=memStorage {_ecg :_c .Map {}};_a .SetAsStorage (&_bg )};

// TempDir creates a name for a new temp directory using a pattern argument
func (_fc *memStorage )TempDir (pattern string )(string ,error ){return _be (pattern ),nil };

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_ce *memFile )Write (p []byte )(int ,error ){_ce ._fa ._ca =append (_ce ._fa ._ca ,p ...);_ce ._fa ._gd +=int64 (len (p ));return len (p ),nil ;};type memFile struct{_fa *memDataCell ;_ee int64 ;};func _fd (_ffe int )(string ,error ){_fe :=make ([]byte ,_ffe );
if _ ,_deb :=_e .Read (_fe );_deb !=nil {return "",_deb ;};return _cf .EncodeToString (_fe ),nil ;};func _be (_cd string )string {_fg ,_ :=_fd (6);return _cd +_fg };

// RemoveAll removes all files according to the dir argument prefix
func (_dfa *memStorage )RemoveAll (dir string )error {_dfa ._ecg .Range (func (_dd ,_bc interface{})bool {_dfa ._ecg .Delete (_dd );return true });return nil ;};type memStorage struct{_ecg _c .Map };

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_b *memFile )Read (p []byte )(int ,error ){_cgf :=_b ._ee ;_fb :=_b ._fa ._gd ;_fbb :=int64 (len (p ));if _fbb > _fb {_fbb =_fb ;p =p [:_fbb ];};if _cgf >=_fb {return 0,_d .EOF ;};_ff :=_cgf +_fbb ;if _ff >=_fb {_ff =_fb ;};_df :=copy (p ,_b ._fa ._ca [_cgf :_ff ]);
_b ._ee =_ff ;return _df ,nil ;};

// Add reads a file from a disk and adds it to the storage
func (_da *memStorage )Add (path string )error {_ ,_db :=_da ._ecg .Load (path );if _db {return nil ;};_af ,_bbf :=_ef .ReadFile (path );if _bbf !=nil {return _bbf ;};_da ._ecg .Store (path ,&memDataCell {_fbd :path ,_ca :_af ,_gd :int64 (len (_af ))});
return nil ;};

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_eg *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_efc :=_eg ._fa ._gd ;_ec :=int64 (len (p ));if _ec > _efc {_ec =_efc ;p =p [:_ec ];};if readOffset >=_efc {return 0,_d .EOF ;};_ed :=readOffset +_ec ;if _ed >=_efc {_ed =_efc ;};_dg :=copy (p ,_eg ._fa ._ca [readOffset :_ed ]);
return _dg ,nil ;};