//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_a "encoding/hex";_d "errors";_b "fmt";_bf "github.com/unidoc/unioffice/common/tempstorage";_ef "io";_ea "io/ioutil";_ee "math/rand";_c "sync";);func _bfc (_efb string )string {_fc ,_ :=_fg (6);return _efb +_fc };type memDataCell struct{_f string ;_de []byte ;_aec int64 ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_bd *memStorage )TempDir (pattern string )(string ,error ){return _bfc (pattern ),nil };

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_eag *memFile )Read (p []byte )(int ,error ){_eb :=_eag ._efc ;_ba :=_eag ._ce ._aec ;_bg :=int64 (len (p ));if _bg > _ba {_bg =_ba ;p =p [:_bg ];};if _eb >=_ba {return 0,_ef .EOF ;};_g :=_eb +_bg ;if _g >=_ba {_g =_ba ;};_bae :=copy (p ,_eag ._ce ._de [_eb :_g ]);_eag ._efc =_g ;return _bae ,nil ;};

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_fa :=memStorage {_da :_c .Map {}};_bf .SetAsStorage (&_fa )};

// Name returns the filename of the underlying memDataCell
func (_ga *memFile )Name ()string {return _ga ._ce ._f };

// Open returns tempstorage File object by name
func (_aeg *memStorage )Open (path string )(_bf .File ,error ){_db ,_gd :=_aeg ._da .Load (path );if !_gd {return nil ,_d .New (_b .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));};return &memFile {_ce :_db .(*memDataCell )},nil ;};type memFile struct{_ce *memDataCell ;_efc int64 ;};

// RemoveAll removes all files according to the dir argument prefix
func (_bgd *memStorage )RemoveAll (dir string )error {_bgd ._da .Range (func (_gb ,_be interface{})bool {_bgd ._da .Delete (_gb );return true });return nil ;};

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_ae *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_af :=_ae ._ce ._aec ;_bb :=int64 (len (p ));if _bb > _af {_bb =_af ;p =p [:_bb ];};if readOffset >=_af {return 0,_ef .EOF ;};_ad :=readOffset +_bb ;if _ad >=_af {_ad =_af ;};_adc :=copy (p ,_ae ._ce ._de [readOffset :_ad ]);return _adc ,nil ;};

// Add reads a file from a disk and adds it to the storage
func (_ec *memStorage )Add (path string )error {_ ,_cg :=_ec ._da .Load (path );if _cg {return nil ;};_dbe ,_ab :=_ea .ReadFile (path );if _ab !=nil {return _ab ;};_ec ._da .Store (path ,&memDataCell {_f :path ,_de :_dbe ,_aec :int64 (len (_dbe ))});return nil ;};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_df *memFile )Write (p []byte )(int ,error ){_df ._ce ._de =append (_df ._ce ._de ,p ...);_df ._ce ._aec +=int64 (len (p ));return len (p ),nil ;};

// Close is not applicable in this implementation
func (_bfd *memFile )Close ()error {return nil };type memStorage struct{_da _c .Map };

// TempFile creates a new empty file in the storage and returns it
func (_eff *memStorage )TempFile (dir ,pattern string )(_bf .File ,error ){_cea :=dir +"\u002f"+_bfc (pattern );_aee :=&memDataCell {_f :_cea ,_de :[]byte {}};_fe :=&memFile {_ce :_aee };_eff ._da .Store (_cea ,_aee );return _fe ,nil ;};func _fg (_dba int )(string ,error ){_cc :=make ([]byte ,_dba );if _ ,_ded :=_ee .Read (_cc );_ded !=nil {return "",_ded ;};return _a .EncodeToString (_cc ),nil ;};