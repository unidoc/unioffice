//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_bgc "encoding/hex";_bg "errors";_b "fmt";_gb "github.com/unidoc/unioffice/v2/common/tempstorage";_e "io";_a "io/ioutil";_cd "math/rand";_g "sync";);type memStorage struct{_bf _g .Map };type memFile struct{_ae *memDataCell ;_ad int64 ;
};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_dgf *memFile )Write (p []byte )(int ,error ){_dgf ._ae ._ab =append (_dgf ._ae ._ab ,p ...);_dgf ._ae ._gf +=int64 (len (p ));return len (p ),nil ;};

// Open returns tempstorage File object by name
func (_af *memStorage )Open (path string )(_gb .File ,error ){_ac ,_gc :=_af ._bf .Load (path );if !_gc {return nil ,_bg .New (_b .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));
};return &memFile {_ae :_ac .(*memDataCell )},nil ;};type memDataCell struct{_gae string ;_ab []byte ;_gf int64 ;};

// TempFile creates a new empty file in the storage and returns it
func (_abe *memStorage )TempFile (dir ,pattern string )(_gb .File ,error ){_be :=dir +"\u002f"+_cdd (pattern );_eg :=&memDataCell {_gae :_be ,_ab :[]byte {}};_egg :=&memFile {_ae :_eg };_abe ._bf .Store (_be ,_eg );return _egg ,nil ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_aa *memStorage )TempDir (pattern string )(string ,error ){return _cdd (pattern ),nil };func _bc (_dbe int )(string ,error ){_ddd :=make ([]byte ,_dbe );if _ ,_bgf :=_cd .Read (_ddd );_bgf !=nil {return "",_bgf ;};return _bgc .EncodeToString (_ddd ),nil ;
};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_cb *memFile )Read (p []byte )(int ,error ){_cc :=_cb ._ad ;_ed :=_cb ._ae ._gf ;_f :=int64 (len (p ));if _f > _ed {_f =_ed ;p =p [:_f ];};if _cc >=_ed {return 0,_e .EOF ;};_d :=_cc +_f ;if _d >=_ed {_d =_ed ;};_dc :=copy (p ,_cb ._ae ._ab [_cc :_d ]);
_cb ._ad =_d ;return _dc ,nil ;};

// Close is not applicable in this implementation
func (_gg *memFile )Close ()error {return nil };

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_gaef :=memStorage {_bf :_g .Map {}};_gb .SetAsStorage (&_gaef )};

// Name returns the filename of the underlying memDataCell
func (_ef *memFile )Name ()string {return _ef ._ae ._gae };

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_ga *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_dg :=_ga ._ae ._gf ;_dcd :=int64 (len (p ));if _dcd > _dg {_dcd =_dg ;p =p [:_dcd ];};if readOffset >=_dg {return 0,_e .EOF ;};_ag :=readOffset +_dcd ;if _ag >=_dg {_ag =_dg ;};_db :=copy (p ,_ga ._ae ._ab [readOffset :_ag ]);
return _db ,nil ;};func _cdd (_aag string )string {_df ,_ :=_bc (6);return _aag +_df };

// RemoveAll removes all files according to the dir argument prefix
func (_bd *memStorage )RemoveAll (dir string )error {_bd ._bf .Range (func (_ff ,_ge interface{})bool {_bd ._bf .Delete (_ff );return true });return nil ;};

// Add reads a file from a disk and adds it to the storage
func (_ee *memStorage )Add (path string )error {_ ,_cdf :=_ee ._bf .Load (path );if _cdf {return nil ;};_dd ,_abc :=_a .ReadFile (path );if _abc !=nil {return _abc ;};_ee ._bf .Store (path ,&memDataCell {_gae :path ,_ab :_dd ,_gf :int64 (len (_dd ))});
return nil ;};