//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package wildcard ;func Match (pattern ,name string )(_e bool ){if pattern ==""{return name ==pattern ;};if pattern =="\u002a"{return true ;};_gdf :=make ([]rune ,0,len (name ));_fc :=make ([]rune ,0,len (pattern ));for _ ,_ag :=range name {_gdf =append (_gdf ,_ag );};for _ ,_dg :=range pattern {_fc =append (_fc ,_dg );};_db :=false ;return _ec (_gdf ,_fc ,_db );};func _ec (_dcf ,_ea []rune ,_gf bool )bool {for len (_ea )> 0{switch _ea [0]{default:if len (_dcf )==0||_dcf [0]!=_ea [0]{return false ;};case '?':if len (_dcf )==0&&!_gf {return false ;};case '*':return _ec (_dcf ,_ea [1:],_gf )||(len (_dcf )> 0&&_ec (_dcf [1:],_ea ,_gf ));};_dcf =_dcf [1:];_ea =_ea [1:];};return len (_dcf )==0&&len (_ea )==0;};func _dga (_bf ,_bfa []rune ,_fb int )int {for len (_bfa )> 0{switch _bfa [0]{default:if len (_bf )==0{return -1;};if _bf [0]!=_bfa [0]{return _dga (_bf [1:],_bfa ,_fb +1);};case '?':if len (_bf )==0{return -1;};case '*':if len (_bf )==0{return -1;};_ece :=_dga (_bf ,_bfa [1:],_fb );if _ece !=-1{return _fb ;}else {_ece =_dga (_bf [1:],_bfa ,_fb );if _ece !=-1{return _fb ;}else {return -1;};};};_bf =_bf [1:];_bfa =_bfa [1:];};return _fb ;};func Index (pattern ,name string )(_df int ){if pattern ==""||pattern =="\u002a"{return 0;};_bg :=make ([]rune ,0,len (name ));_efc :=make ([]rune ,0,len (pattern ));for _ ,_da :=range name {_bg =append (_bg ,_da );};for _ ,_ae :=range pattern {_efc =append (_efc ,_ae );};return _dga (_bg ,_efc ,0);};func MatchSimple (pattern ,name string )bool {if pattern ==""{return name ==pattern ;};if pattern =="\u002a"{return true ;};_b :=make ([]rune ,0,len (name ));_d :=make ([]rune ,0,len (pattern ));for _ ,_a :=range name {_b =append (_b ,_a );};for _ ,_gd :=range pattern {_d =append (_d ,_gd );};_ba :=true ;return _ec (_b ,_d ,_ba );};