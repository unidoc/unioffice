//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_cb "archive/zip";_de "errors";_ade "fmt";_g "github.com/unidoc/unioffice";_dc "github.com/unidoc/unioffice/chart";_gb "github.com/unidoc/unioffice/color";_bfd "github.com/unidoc/unioffice/common";_bf "github.com/unidoc/unioffice/common/license";_b "github.com/unidoc/unioffice/common/tempstorage";_cf "github.com/unidoc/unioffice/measurement";_dgf "github.com/unidoc/unioffice/schema/soo/dml";_ef "github.com/unidoc/unioffice/schema/soo/dml/chart";_ea "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_gbg "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ba "github.com/unidoc/unioffice/schema/soo/sml";_gdd "github.com/unidoc/unioffice/spreadsheet/format";_cgd "github.com/unidoc/unioffice/spreadsheet/formula";_dg "github.com/unidoc/unioffice/spreadsheet/reference";_cfa "github.com/unidoc/unioffice/spreadsheet/update";_da "github.com/unidoc/unioffice/vmldrawing";_e "github.com/unidoc/unioffice/zippkg";_gd "image";_ad "image/jpeg";_c "io";_ge "log";_ce "math";_gg "math/big";_af "os";_fb "path/filepath";_ff "regexp";_f "sort";_cg "strconv";_d "strings";_ag "time";);

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_edda Drawing )AddImage (img _bfd .ImageRef ,at AnchorType )Anchor {_afgg :=0;for _edff ,_ceed :=range _edda ._dea .Images {if _ceed ==img {_afgg =_edff +1;break ;};};var _efb string ;for _dbg ,_deea :=range _edda ._dea ._cbgc {if _deea ==_edda ._bacd {_aege :=_ade .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_afgg ,img .Format ());_eegf :=_edda ._dea ._dbagc [_dbg ].AddRelationship (_aege ,_g .ImageType );_efb =_eegf .ID ();break ;};};var _gdgf Anchor ;var _gadd *_ea .CT_Picture ;switch at {case AnchorTypeAbsolute :_ggbg :=_dgcf ();_edda ._bacd .EG_Anchor =append (_edda ._bacd .EG_Anchor ,&_ea .EG_Anchor {AbsoluteAnchor :_ggbg });_ggbg .Choice =&_ea .EG_ObjectChoicesChoice {};_ggbg .Choice .Pic =_ea .NewCT_Picture ();_gadd =_ggbg .Choice .Pic ;_gdgf =AbsoluteAnchor {_ggbg };case AnchorTypeOneCell :_eebe :=_ddf ();_edda ._bacd .EG_Anchor =append (_edda ._bacd .EG_Anchor ,&_ea .EG_Anchor {OneCellAnchor :_eebe });_eebe .Choice =&_ea .EG_ObjectChoicesChoice {};_eebe .Choice .Pic =_ea .NewCT_Picture ();_gadd =_eebe .Choice .Pic ;_gdgf =OneCellAnchor {_eebe };case AnchorTypeTwoCell :_adfb :=_aebf ();_edda ._bacd .EG_Anchor =append (_edda ._bacd .EG_Anchor ,&_ea .EG_Anchor {TwoCellAnchor :_adfb });_adfb .Choice =&_ea .EG_ObjectChoicesChoice {};_adfb .Choice .Pic =_ea .NewCT_Picture ();_gadd =_adfb .Choice .Pic ;_gdgf =TwoCellAnchor {_adfb };};_gadd .NvPicPr .CNvPr .IdAttr =uint32 (len (_edda ._bacd .EG_Anchor ));_gadd .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_gadd .BlipFill .Blip =_dgf .NewCT_Blip ();_gadd .BlipFill .Blip .EmbedAttr =_g .String (_efb );_gadd .BlipFill .Stretch =_dgf .NewCT_StretchInfoProperties ();_gadd .SpPr =_dgf .NewCT_ShapeProperties ();_gadd .SpPr .Xfrm =_dgf .NewCT_Transform2D ();_gadd .SpPr .Xfrm .Off =_dgf .NewCT_Point2D ();_gadd .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_g .Int64 (0);_gadd .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_g .Int64 (0);_gadd .SpPr .Xfrm .Ext =_dgf .NewCT_PositiveSize2D ();_gadd .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_cf .Pixel72 )/_cf .EMU );_gadd .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_cf .Pixel72 )/_cf .EMU );_gadd .SpPr .PrstGeom =_dgf .NewCT_PresetGeometry2D ();_gadd .SpPr .PrstGeom .PrstAttr =_dgf .ST_ShapeTypeRect ;_gadd .SpPr .Ln =_dgf .NewCT_LineProperties ();_gadd .SpPr .Ln .NoFill =_dgf .NewCT_NoFillProperties ();return _gdgf ;};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_ddcc Cell )SetCachedFormulaResult (s string ){_ddcc ._eeg .V =&s };

// X returns the inner wrapped XML type.
func (_ceeb Font )X ()*_ba .CT_Font {return _ceeb ._gcc };func (_fcc RichTextRun )ensureRpr (){if _fcc ._fgfg .RPr ==nil {_fcc ._fgfg .RPr =_ba .NewCT_RPrElt ();};};

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_dea *Workbook ;_bacd *_ea .WsDr ;};func (_adb Cell )clearValue (){_adb ._eeg .F =nil ;_adb ._eeg .Is =nil ;_adb ._eeg .V =nil ;_adb ._eeg .TAttr =_ba .ST_CellTypeUnset ;};func (_gcgb PatternFill )X ()*_ba .CT_PatternFill {return _gcgb ._fefe };

// IsSheetLocked returns whether the sheet is locked.
func (_gbaf SheetProtection )IsSheetLocked ()bool {return _gbaf ._baca .SheetAttr !=nil &&*_gbaf ._baca .SheetAttr ;};

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_gee Cell )Reference ()string {if _gee ._eeg .RAttr !=nil {return *_gee ._eeg .RAttr ;};return "";};

// Comment is a single comment within a sheet.
type Comment struct{_gcbe *Workbook ;_fdd *_ba .CT_Comment ;_aaf *_ba .Comments ;};

// LockObject controls the locking of the sheet objects.
func (_abfg SheetProtection )LockObject (b bool ){if !b {_abfg ._baca .ObjectsAttr =nil ;}else {_abfg ._baca .ObjectsAttr =_g .Bool (true );};};func (_bdfb *Sheet )removeColumnFromMergedCells (_eede uint32 )error {if _bdfb ._edeb .MergeCells ==nil ||_bdfb ._edeb .MergeCells .MergeCell ==nil {return nil ;};_bdeb :=[]*_ba .CT_MergeCell {};for _ ,_ceg :=range _bdfb .MergedCells (){_eada :=_feae (_ceg .Reference (),_eede ,true );if _eada !=""{_ceg .SetReference (_eada );_bdeb =append (_bdeb ,_ceg .X ());};};_bdfb ._edeb .MergeCells .MergeCell =_bdeb ;return nil ;};

// X returns the inner wrapped XML type.
func (_dgcd IconScale )X ()*_ba .CT_IconSet {return _dgcd ._dacb };

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_cfeg Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _dcac ,_bcfc Cell ;for _ ,_cde :=range lhs .Cells (){_affd ,_ :=_dg .ParseCellReference (_cde .Reference ());if _affd .Column ==column {_dcac =_cde ;break ;};};for _ ,_cae :=range rhs .Cells (){_aeca ,_ :=_dg .ParseCellReference (_cae .Reference ());if _aeca .Column ==column {_bcfc =_cae ;break ;};};return _cfeg .LessCells (_dcac ,_bcfc );};

// Column returns the cell column
func (_eec Cell )Column ()(string ,error ){_cff ,_dgb :=_dg .ParseCellReference (_eec .Reference ());if _dgb !=nil {return "",_dgb ;};return _cff .Column ,nil ;};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_abg CellStyle )HasNumberFormat ()bool {return _abg ._daa .NumFmtIdAttr !=nil &&_abg ._daa .ApplyNumberFormatAttr !=nil &&*_abg ._daa .ApplyNumberFormatAttr ;};

// SetBold causes the text to be displayed in bold.
func (_dbac RichTextRun )SetBold (b bool ){_dbac .ensureRpr ();_dbac ._fgfg .RPr .B =_ba .NewCT_BooleanProperty ();_dbac ._fgfg .RPr .B .ValAttr =_g .Bool (b );};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_eeae StyleSheet )Fills ()Fills {return Fills {_eeae ._gfde .Fills }};

// X returns the inner wrapped XML type.
func (_bgd DataBarScale )X ()*_ba .CT_DataBar {return _bgd ._abb };

// ClearProtection removes any protections applied to teh sheet.
func (_edffc *Sheet )ClearProtection (){_edffc ._edeb .SheetProtection =nil };

// BottomRight is a no-op.
func (_beg OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Type returns the type of anchor
func (_aga AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_beda Row )AddNamedCell (col string )Cell {_becb :=_ba .NewCT_Cell ();_becb .RAttr =_g .Stringf ("\u0025\u0073\u0025\u0064",col ,_beda .RowNumber ());_fceb :=-1;_ace :=_dg .ColumnToIndex (col );for _eeeg ,_fabc :=range _beda ._agbf .C {_dcgd ,_bcbbc :=_dg .ParseCellReference (*_fabc .RAttr );if _bcbbc !=nil {return Cell {};};if _ace < _dcgd .ColumnIdx {_fceb =_eeeg ;break ;};};if _fceb ==-1{_beda ._agbf .C =append (_beda ._agbf .C ,_becb );}else {_beda ._agbf .C =append (_beda ._agbf .C [:_fceb ],append ([]*_ba .CT_Cell {_becb },_beda ._agbf .C [_fceb :]...)...);};return Cell {_beda ._bdaf ,_beda ._edfa ,_beda ._agbf ,_becb };};

// Name returns the name of the table
func (_dbcb Table )Name ()string {if _dbcb ._eega .NameAttr !=nil {return *_dbcb ._eega .NameAttr ;};return "";};

// SetWidth controls the width of a column.
func (_cbg Column )SetWidth (w _cf .Distance ){_cbg ._eaac .WidthAttr =_g .Float64 (float64 (w /_cf .Character ));};

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_ggec *Workbook ;_cgg *_ba .CT_NumFmt ;};

// CellStyle is a formatting style for a cell.  CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_fga *Workbook ;_daa *_ba .CT_Xf ;_ebe *_ba .CT_CellXfs ;};

// GetValueAsNumber retrieves the cell's value as a number
func (_bcf Cell )GetValueAsNumber ()(float64 ,error ){if _bcf ._eeg .V ==nil &&_bcf ._eeg .Is ==nil {return 0,nil ;};if _bcf ._eeg .TAttr ==_ba .ST_CellTypeS ||!_gdd .IsNumber (*_bcf ._eeg .V ){return _ce .NaN (),_de .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _cg .ParseFloat (*_bcf ._eeg .V ,64);};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_cfaa Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_cfaa .SetNumber (v );_cfaa .SetStyle (_cfaa ._agg .StyleSheet .GetOrCreateStandardNumberFormat (f ));};var _afge *_ff .Regexp =_ff .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_defb Cell )SetStyleIndex (idx uint32 ){_defb ._eeg .SAttr =_g .Uint32 (idx )};

// AddMergedCells merges cells within a sheet.
func (_gcge *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _gcge ._edeb .MergeCells ==nil {_gcge ._edeb .MergeCells =_ba .NewCT_MergeCells ();};_fec :=_ba .NewCT_MergeCell ();_fec .RefAttr =_ade .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_gcge ._edeb .MergeCells .MergeCell =append (_gcge ._edeb .MergeCells .MergeCell ,_fec );_gcge ._edeb .MergeCells .CountAttr =_g .Uint32 (uint32 (len (_gcge ._edeb .MergeCells .MergeCell )));return MergedCell {_gcge ._ebee ,_gcge ,_fec };};func (_gagab *Workbook )createCustomProperties (){_gagab .CustomProperties =_bfd .NewCustomProperties ();_gagab .addCustomRelationships ();};

// SetHeight sets the row height in points.
func (_bbeb Row )SetHeight (d _cf .Distance ){_bbeb ._agbf .HtAttr =_g .Float64 (float64 (d ));_bbeb ._agbf .CustomHeightAttr =_g .Bool (true );};

// Row is a row within a spreadsheet.
type Row struct{_bdaf *Workbook ;_edfa *Sheet ;_agbf *_ba .CT_Row ;};

// SetShowValue controls if the cell value is displayed.
func (_ffedg DataBarScale )SetShowValue (b bool ){_ffedg ._abb .ShowValueAttr =_g .Bool (b )};

// IsWindowLocked returns whether the workbook windows are locked.
func (_bffd WorkbookProtection )IsWindowLocked ()bool {return _bffd ._aba .LockWindowsAttr !=nil &&*_bffd ._aba .LockWindowsAttr ;};

// AddBorder creates a new empty border that can be applied to a cell style.
func (_daacf StyleSheet )AddBorder ()Border {_aaabg :=_ba .NewCT_Border ();_daacf ._gfde .Borders .Border =append (_daacf ._gfde .Borders .Border ,_aaabg );_daacf ._gfde .Borders .CountAttr =_g .Uint32 (uint32 (len (_daacf ._gfde .Borders .Border )));return Border {_aaabg ,_daacf ._gfde .Borders };};func _feb (_efda bool )int {if _efda {return 1;};return 0;};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_dddf *_ba .CT_DataValidation };

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_gaed PatternFill )SetFgColor (c _gb .Color ){_gaed ._fefe .FgColor =_ba .NewCT_Color ();_gaed ._fefe .FgColor .RgbAttr =c .AsRGBAString ();};func (_cdg DataValidation )clear (){_cdg ._daec .Formula1 =_g .String ("\u0030");_cdg ._daec .Formula2 =_g .String ("\u0030");};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_gcgg NumberFormat )ID ()uint32 {return _gcgg ._cgg .NumFmtIdAttr };

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_dff CellStyle )NumberFormat ()uint32 {if _dff ._daa .NumFmtIdAttr ==nil {return 0;};return *_dff ._daa .NumFmtIdAttr ;};

// RowOffset returns the offset from the row cell.
func (_fgd CellMarker )RowOffset ()_cf .Distance {if _fgd ._ccb .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _cf .Distance (float64 (*_fgd ._ccb .RowOff .ST_CoordinateUnqualified )*_cf .EMU );};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_debe Drawing )AddChart (at AnchorType )(_dc .Chart ,Anchor ){_ccdf :=_ef .NewChartSpace ();_debe ._dea ._bgfa =append (_debe ._dea ._bgfa ,_ccdf );_fcbdg :=_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .ChartContentType ,len (_debe ._dea ._bgfa ));_debe ._dea .ContentTypes .AddOverride (_fcbdg ,_g .ChartContentType );var _aab string ;for _fee ,_eddf :=range _debe ._dea ._cbgc {if _eddf ==_debe ._bacd {_fcaf :=_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .DrawingType ,_g .ChartType ,len (_debe ._dea ._bgfa ));_bgdc :=_debe ._dea ._dbagc [_fee ].AddRelationship (_fcaf ,_g .ChartType );_aab =_bgdc .ID ();break ;};};var _dade Anchor ;var _fdcc *_ea .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_cgec :=_dgcf ();_debe ._bacd .EG_Anchor =append (_debe ._bacd .EG_Anchor ,&_ea .EG_Anchor {AbsoluteAnchor :_cgec });_cgec .Choice =&_ea .EG_ObjectChoicesChoice {};_cgec .Choice .GraphicFrame =_ea .NewCT_GraphicalObjectFrame ();_fdcc =_cgec .Choice .GraphicFrame ;_dade =AbsoluteAnchor {_cgec };case AnchorTypeOneCell :_bdbc :=_ddf ();_debe ._bacd .EG_Anchor =append (_debe ._bacd .EG_Anchor ,&_ea .EG_Anchor {OneCellAnchor :_bdbc });_bdbc .Choice =&_ea .EG_ObjectChoicesChoice {};_bdbc .Choice .GraphicFrame =_ea .NewCT_GraphicalObjectFrame ();_fdcc =_bdbc .Choice .GraphicFrame ;_dade =OneCellAnchor {_bdbc };case AnchorTypeTwoCell :_cbgb :=_aebf ();_debe ._bacd .EG_Anchor =append (_debe ._bacd .EG_Anchor ,&_ea .EG_Anchor {TwoCellAnchor :_cbgb });_cbgb .Choice =&_ea .EG_ObjectChoicesChoice {};_cbgb .Choice .GraphicFrame =_ea .NewCT_GraphicalObjectFrame ();_fdcc =_cbgb .Choice .GraphicFrame ;_dade =TwoCellAnchor {_cbgb };};_fdcc .NvGraphicFramePr =_ea .NewCT_GraphicalObjectFrameNonVisual ();_fdcc .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_debe ._bacd .EG_Anchor ));_fdcc .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_fdcc .Graphic =_dgf .NewGraphic ();_fdcc .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_cbgf :=_ef .NewChart ();_cbgf .IdAttr =_aab ;_fdcc .Graphic .GraphicData .Any =[]_g .Any {_cbgf };_dgga :=_dc .MakeChart (_ccdf );_dgga .Properties ().SetSolidFill (_gb .White );_dgga .SetDisplayBlanksAs (_ef .ST_DispBlanksAsGap );return _dgga ,_dade ;};

// X returns the inner wrapped XML type.
func (_dbcc MergedCell )X ()*_ba .CT_MergeCell {return _dbcc ._ddgc };

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// SetType sets the type of the rule.
func (_efcc ConditionalFormattingRule )SetType (t _ba .ST_CfType ){_efcc ._bcca .TypeAttr =t };

// SheetCount returns the number of sheets in the workbook.
func (_bbfb Workbook )SheetCount ()int {return len (_bbfb ._fgc )};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_dgec *_ba .CT_ColorScale };

// SetFont applies a font to a cell style.  The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_ccfb CellStyle )SetFont (f Font ){_ccfb ._daa .FontIdAttr =_g .Uint32 (f .Index ());_ccfb ._daa .ApplyFontAttr =_g .Bool (true );};type Fills struct{_caabg *_ba .CT_Fills };

// HasFormula returns true if the cell contains formula.
func (_cad *evalContext )HasFormula (cellRef string )bool {return _cad ._abgg .Cell (cellRef ).HasFormula ();};

// SetWidth sets the width of the anchored object.
func (_ga AbsoluteAnchor )SetWidth (w _cf .Distance ){_ga ._deb .Ext .CxAttr =int64 (w /_cf .EMU )};

// SetRow set the row of the cell marker.
func (_debb CellMarker )SetRow (row int32 ){_debb ._ccb .Row =row };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gdeg *Sheet )RecalculateFormulas (){_dedd :=_cgd .NewEvaluator ();_fcbac :=_gdeg .FormulaContext ();for _ ,_dace :=range _gdeg .Rows (){for _ ,_gdaa :=range _dace .Cells (){if _gdaa .X ().F !=nil {_eeff :=_gdaa .X ().F .Content ;if _gdaa .X ().F .TAttr ==_ba .ST_CellFormulaTypeShared &&len (_eeff )==0{continue ;};_efgc :=_dedd .Eval (_fcbac ,_eeff ).AsString ();if _efgc .Type ==_cgd .ResultTypeError {_g .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_eeff ,_efgc .ErrorMessage );_gdaa .X ().V =nil ;}else {if _efgc .Type ==_cgd .ResultTypeNumber {_gdaa .X ().TAttr =_ba .ST_CellTypeN ;}else {_gdaa .X ().TAttr =_ba .ST_CellTypeInlineStr ;};_gdaa .X ().V =_g .String (_efgc .Value ());if _gdaa .X ().F .TAttr ==_ba .ST_CellFormulaTypeArray {if _efgc .Type ==_cgd .ResultTypeArray {_gdeg .setArray (_gdaa .Reference (),_efgc );}else if _efgc .Type ==_cgd .ResultTypeList {_gdeg .setList (_gdaa .Reference (),_efgc );};}else if _gdaa .X ().F .TAttr ==_ba .ST_CellFormulaTypeShared &&_gdaa .X ().F .RefAttr !=nil {_bfbf ,_fdcf ,_edbge :=_dg .ParseRangeReference (*_gdaa .X ().F .RefAttr );if _edbge !=nil {_ge .Printf ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_edbge );continue ;};_gdeg .setShared (_gdaa .Reference (),_bfbf ,_fdcf ,_eeff );};};};};};};func (_aad ConditionalFormattingRule )InitializeDefaults (){_aad .SetType (_ba .ST_CfTypeCellIs );_aad .SetOperator (_ba .ST_ConditionalFormattingOperatorGreaterThan );_aad .SetPriority (1);};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_fcfc *Workbook )AddDrawing ()Drawing {_badg :=_ea .NewWsDr ();_fcfc ._cbgc =append (_fcfc ._cbgc ,_badg );_bfcb :=_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .DrawingType ,len (_fcfc ._cbgc ));_fcfc .ContentTypes .AddOverride (_bfcb ,_g .DrawingContentType );_fcfc ._dbagc =append (_fcfc ._dbagc ,_bfd .NewRelationships ());return Drawing {_fcfc ,_badg };};

// AnchorType is the type of anchor.
type AnchorType byte ;

// Comments returns the comments for a sheet.
func (_cbge *Sheet )Comments ()Comments {for _cbdb ,_bcba :=range _cbge ._ebee ._fgc {if _bcba ==_cbge ._edeb {if _cbge ._ebee ._eabg [_cbdb ]==nil {_cbge ._ebee ._eabg [_cbdb ]=_ba .NewComments ();_cbge ._ebee ._gcga [_cbdb ].AddAutoRelationship (_g .DocTypeSpreadsheet ,_g .WorksheetType ,_cbdb +1,_g .CommentsType );_cbge ._ebee .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .CommentsType ,_cbdb +1),_g .CommentsContentType );};if len (_cbge ._ebee ._effd )==0{_cbge ._ebee ._effd =append (_cbge ._ebee ._effd ,_da .NewCommentDrawing ());_bfdc :=_cbge ._ebee ._gcga [_cbdb ].AddAutoRelationship (_g .DocTypeSpreadsheet ,_g .WorksheetType ,1,_g .VMLDrawingType );if _cbge ._edeb .LegacyDrawing ==nil {_cbge ._edeb .LegacyDrawing =_ba .NewCT_LegacyDrawing ();};_cbge ._edeb .LegacyDrawing .IdAttr =_bfdc .ID ();};return Comments {_cbge ._ebee ,_cbge ._ebee ._eabg [_cbdb ]};};};_g .Log ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};func (_fcf Border )SetRight (style _ba .ST_BorderStyle ,c _gb .Color ){if _fcf ._cba .Right ==nil {_fcf ._cba .Right =_ba .NewCT_BorderPr ();};_fcf ._cba .Right .Color =_ba .NewCT_Color ();_fcf ._cba .Right .Color .RgbAttr =c .AsRGBAString ();_fcf ._cba .Right .StyleAttr =style ;};type ConditionalFormattingRule struct{_bcca *_ba .CT_CfRule };const _gdga ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";func (_effg Sheet )validateRowCellNumbers ()error {_dceb :=map[uint32 ]struct{}{};for _ ,_egff :=range _effg ._edeb .SheetData .Row {if _egff .RAttr !=nil {if _ ,_eacg :=_dceb [*_egff .RAttr ];_eacg {return _ade .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_effg .Name (),*_egff .RAttr );};_dceb [*_egff .RAttr ]=struct{}{};};_badb :=map[string ]struct{}{};for _ ,_aadc :=range _egff .C {if _aadc .RAttr ==nil {continue ;};if _ ,_ced :=_badb [*_aadc .RAttr ];_ced {return _ade .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_effg .Name (),*_aadc .RAttr );};_badb [*_aadc .RAttr ]=struct{}{};};};return nil ;};func NewPatternFill (fills *_ba .CT_Fills )PatternFill {_ddfa :=_ba .NewCT_Fill ();_ddfa .PatternFill =_ba .NewCT_PatternFill ();return PatternFill {_ddfa .PatternFill ,_ddfa };};

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_accc *evalContext )LastRow (col string )int {_dbag :=_accc ._abgg ;_cbd :=int (_dg .ColumnToIndex (col ));_daca :=1;for _ ,_cgbg :=range _dbag ._edeb .SheetData .Row {if _cgbg .RAttr !=nil {_gacc :=Row {_dbag ._ebee ,_dbag ,_cgbg };_adbf :=len (_gacc .Cells ());if _adbf > _cbd {_daca =int (_gacc .RowNumber ());};};};return _daca ;};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_ccfd *evalContext )IsDBCS ()bool {_dgbe :=_ccfd ._abgg ._ebee .CoreProperties .X ().Language ;if _dgbe ==nil {return false ;};_efeb :=string (_dgbe .Data );for _ ,_fbea :=range _cgcc {if _efeb ==_fbea {return true ;};};return false ;};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_eaeb StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_edba :=range _eaeb .CellStyles (){if _edba .HasNumberFormat ()&&_edba .NumberFormat ()==uint32 (f ){return _edba ;};};_gdac :=_eaeb .AddCellStyle ();_gdac .SetNumberFormatStandard (f );return _gdac ;};

// Tables returns a slice of all defined tables in the workbook.
func (_abcec *Workbook )Tables ()[]Table {if _abcec ._eedb ==nil {return nil ;};_ebfe :=[]Table {};for _ ,_adgc :=range _abcec ._eedb {_ebfe =append (_ebfe ,Table {_adgc });};return _ebfe ;};

// StyleSheet is a document style sheet.
type StyleSheet struct{_aced *Workbook ;_gfde *_ba .StyleSheet ;};

// Reference returns the region of cells that are merged.
func (_agaf MergedCell )Reference ()string {return _agaf ._ddgc .RefAttr };

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_cffb Cell )GetCachedFormulaResult ()string {if _cffb ._eeg .V !=nil {return *_cffb ._eeg .V ;};return "";};

// SetHeightCells is a no-op.
func (_dgc AbsoluteAnchor )SetHeightCells (int32 ){};func (_afae *Sheet )setShared (_badbf string ,_cfcd ,_ccab _dg .CellReference ,_cged string ){_ffgd :=_afae .FormulaContext ();_fcee :=_cgd .NewEvaluator ();for _bfagd :=_cfcd .RowIdx ;_bfagd <=_ccab .RowIdx ;_bfagd ++{for _bccc :=_cfcd .ColumnIdx ;_bccc <=_ccab .ColumnIdx ;_bccc ++{_gacbf :=_bfagd -_cfcd .RowIdx ;_feba :=_bccc -_cfcd .ColumnIdx ;_ffgd .SetOffset (_feba ,_gacbf );_abgga :=_fcee .Eval (_ffgd ,_cged );_gfb :=_ade .Sprintf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_bccc ),_bfagd );_edfg :=_afae .Cell (_gfb );if _abgga .Type ==_cgd .ResultTypeNumber {_edfg .X ().TAttr =_ba .ST_CellTypeN ;}else {_edfg .X ().TAttr =_ba .ST_CellTypeInlineStr ;};_edfg .X ().V =_g .String (_abgga .Value ());};};_ =_fcee ;_ =_ffgd ;};func _ddf ()*_ea .CT_OneCellAnchor {_ada :=_ea .NewCT_OneCellAnchor ();return _ada };

// GetFormat sets the number format code.
func (_gfcd NumberFormat )GetFormat ()string {return _gfcd ._cgg .FormatCodeAttr };

// X returns the inner wrapped XML type.
func (_babe NumberFormat )X ()*_ba .CT_NumFmt {return _babe ._cgg };

// X returns the inner wrapped XML type.
func (_bag Cell )X ()*_ba .CT_Cell {return _bag ._eeg };

// X returns the inner wrapped XML type.
func (_cfef SheetProtection )X ()*_ba .CT_SheetProtection {return _cfef ._baca };func _aebf ()*_ea .CT_TwoCellAnchor {_gdba :=_ea .NewCT_TwoCellAnchor ();_gdba .EditAsAttr =_ea .ST_EditAsOneCell ;_gdba .From .Col =5;_gdba .From .Row =0;_gdba .From .ColOff .ST_CoordinateUnqualified =_g .Int64 (0);_gdba .From .RowOff .ST_CoordinateUnqualified =_g .Int64 (0);_gdba .To .Col =10;_gdba .To .Row =20;_gdba .To .ColOff .ST_CoordinateUnqualified =_g .Int64 (0);_gdba .To .RowOff .ST_CoordinateUnqualified =_g .Int64 (0);return _gdba ;};type PatternFill struct{_fefe *_ba .CT_PatternFill ;_eac *_ba .CT_Fill ;};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_abfc *Sheet )SetFrozen (firstRow ,firstCol bool ){_abfc ._edeb .SheetViews =nil ;_egdb :=_abfc .AddView ();_egdb .SetState (_ba .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_egdb .SetYSplit (1);_egdb .SetXSplit (1);_egdb .SetTopLeft ("\u0042\u0032");case firstRow :_egdb .SetYSplit (1);_egdb .SetTopLeft ("\u0041\u0032");case firstCol :_egdb .SetXSplit (1);_egdb .SetTopLeft ("\u0042\u0031");};};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_ac Cell )GetFormattedValue ()string {_efd :=_ac .getFormat ();switch _ac ._eeg .TAttr {case _ba .ST_CellTypeB :_cda ,_ :=_ac .GetValueAsBool ();if _cda {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _ba .ST_CellTypeN :_dgfc ,_ :=_ac .GetValueAsNumber ();return _gdd .Number (_dgfc ,_efd );case _ba .ST_CellTypeE :if _ac ._eeg .V !=nil {return *_ac ._eeg .V ;};return "";case _ba .ST_CellTypeS ,_ba .ST_CellTypeInlineStr :return _gdd .String (_ac .GetString (),_efd );case _ba .ST_CellTypeStr :_bg :=_ac .GetString ();if _gdd .IsNumber (_bg ){_bfe ,_ :=_cg .ParseFloat (_bg ,64);return _gdd .Number (_bfe ,_efd );};return _gdd .String (_bg ,_efd );case _ba .ST_CellTypeUnset :fallthrough;default:_ae ,_ :=_ac .GetRawValue ();if len (_ae )==0{return "";};_bagdg ,_fbg :=_ac .GetValueAsNumber ();if _fbg ==nil {return _gdd .Number (_bagdg ,_efd );};return _gdd .String (_ae ,_efd );};};var _cgcc []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_cfcc SheetView )SetZoom (pct uint32 ){_cfcc ._adgd .ZoomScaleAttr =&pct };

// SetHidden marks the defined name as hidden.
func (_eff DefinedName )SetLocalSheetID (id uint32 ){_eff ._dcd .LocalSheetIdAttr =_g .Uint32 (id )};func (_bgf *evalContext )Sheet (name string )_cgd .Context {for _ ,_gbc :=range _bgf ._abgg ._ebee .Sheets (){if _gbc .Name ()==name {return _gbc .FormulaContext ();};};return _cgd .InvalidReferenceContext ;};

// GetFormat returns a cell data format.
func (_edf *evalContext )GetFormat (cellRef string )string {return _edf ._abgg .Cell (cellRef ).getFormat ();};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_faeg :_ba .NewSst (),_ceae :make (map[string ]int )};};

// Protection allows control over the workbook protections.
func (_abeg *Workbook )Protection ()WorkbookProtection {if _abeg ._badbd .WorkbookProtection ==nil {_abeg ._badbd .WorkbookProtection =_ba .NewCT_WorkbookProtection ();};return WorkbookProtection {_abeg ._badbd .WorkbookProtection };};

// Type returns the type of the rule
func (_fge ConditionalFormattingRule )Type ()_ba .ST_CfType {return _fge ._bcca .TypeAttr };

// SetAllowBlank controls if blank values are accepted.
func (_fbdg DataValidation )SetAllowBlank (b bool ){if !b {_fbdg ._daec .AllowBlankAttr =nil ;}else {_fbdg ._daec .AllowBlankAttr =_g .Bool (true );};};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_aa Cell )SetInlineString (s string ){_aa .clearValue ();_aa ._eeg .Is =_ba .NewCT_Rst ();_aa ._eeg .Is .T =_g .String (s );_aa ._eeg .TAttr =_ba .ST_CellTypeInlineStr ;};type DifferentialStyle struct{_geff *_ba .CT_Dxf ;_gbdg *Workbook ;_fba *_ba .CT_Dxfs ;};

// SetHeightAuto sets the row height to be automatically determined.
func (_dbcce Row )SetHeightAuto (){_dbcce ._agbf .HtAttr =nil ;_dbcce ._agbf .CustomHeightAttr =nil };

// ClearFont clears any font configuration from the cell style.
func (_gda CellStyle )ClearFont (){_gda ._daa .FontIdAttr =nil ;_gda ._daa .ApplyFontAttr =nil };

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_ccfg Comparer )LessCells (lhs ,rhs Cell )bool {if _ccfg .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_dgd ,_ged :=lhs .getRawSortValue ();_aag ,_befgd :=rhs .getRawSortValue ();switch {case _ged &&_befgd :_aea ,_ :=_cg .ParseFloat (_dgd ,64);_gfg ,_ :=_cg .ParseFloat (_aag ,64);return _aea < _gfg ;case _ged :return true ;case _befgd :return false ;};_dgd =lhs .GetFormattedValue ();_aag =rhs .GetFormattedValue ();return _dgd < _aag ;};func (_gebc *Sheet )getAllCellsInFormulaArrays (_dgef bool )(map[string ]bool ,error ){_cgafd :=_cgd .NewEvaluator ();_gdbf :=_gebc .FormulaContext ();_aee :=map[string ]bool {};for _ ,_dgeb :=range _gebc .Rows (){for _ ,_fcfg :=range _dgeb .Cells (){if _fcfg .X ().F !=nil {_dcbb :=_fcfg .X ().F .Content ;if _fcfg .X ().F .TAttr ==_ba .ST_CellFormulaTypeArray {_daaba :=_cgafd .Eval (_gdbf ,_dcbb ).AsString ();if _daaba .Type ==_cgd .ResultTypeError {_g .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_dcbb ,_daaba .ErrorMessage );_fcfg .X ().V =nil ;};if _daaba .Type ==_cgd .ResultTypeArray {_gdde ,_gfgb :=_dg .ParseCellReference (_fcfg .Reference ());if _gfgb !=nil {return map[string ]bool {},_gfgb ;};if (_dgef &&len (_daaba .ValueArray )==1)||(!_dgef &&len (_daaba .ValueArray [0])==1){continue ;};for _ceda ,_dfdc :=range _daaba .ValueArray {_cedg :=_gdde .RowIdx +uint32 (_ceda );for _eea :=range _dfdc {_gdfc :=_dg .IndexToColumn (_gdde .ColumnIdx +uint32 (_eea ));_aee [_ade .Sprintf ("\u0025\u0073\u0025\u0064",_gdfc ,_cedg )]=true ;};};}else if _daaba .Type ==_cgd .ResultTypeList {_bfda ,_cafg :=_dg .ParseCellReference (_fcfg .Reference ());if _cafg !=nil {return map[string ]bool {},_cafg ;};if _dgef ||len (_daaba .ValueList )==1{continue ;};_dfgg :=_bfda .RowIdx ;for _ebb :=range _daaba .ValueList {_ccda :=_dg .IndexToColumn (_bfda .ColumnIdx +uint32 (_ebb ));_aee [_ade .Sprintf ("\u0025\u0073\u0025\u0064",_ccda ,_dfgg )]=true ;};};};};};};return _aee ,nil ;};

// SetHeight sets the height of the anchored object.
func (_dee AbsoluteAnchor )SetHeight (h _cf .Distance ){_dee ._deb .Ext .CyAttr =int64 (h /_cf .EMU )};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_cace SheetView )SetState (st _ba .ST_PaneState ){_cace .ensurePane ();_cace ._adgd .Pane .StateAttr =st ;};type evalContext struct{_abgg *Sheet ;_efe ,_ecad uint32 ;_egcb map[string ]struct{};};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_ffbg TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_ffbg ._afgbc .From }};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_gcc *_ba .CT_Font ;_abc *_ba .StyleSheet ;};

// IsNumber returns true if the cell is a number type cell.
func (_dbc Cell )IsNumber ()bool {switch _dbc ._eeg .TAttr {case _ba .ST_CellTypeN :return true ;case _ba .ST_CellTypeS ,_ba .ST_CellTypeB :return false ;};return _dbc ._eeg .V !=nil &&_gdd .IsNumber (*_dbc ._eeg .V );};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_bba *Sheet )RemoveMergedCell (mc MergedCell ){for _aegee ,_fadf :=range _bba ._edeb .MergeCells .MergeCell {if _fadf ==mc .X (){copy (_bba ._edeb .MergeCells .MergeCell [_aegee :],_bba ._edeb .MergeCells .MergeCell [_aegee +1:]);_bba ._edeb .MergeCells .MergeCell [len (_bba ._edeb .MergeCells .MergeCell )-1]=nil ;_bba ._edeb .MergeCells .MergeCell =_bba ._edeb .MergeCells .MergeCell [:len (_bba ._edeb .MergeCells .MergeCell )-1];};};};

// SetPasswordHash sets the password hash to the input.
func (_eeba SheetProtection )SetPasswordHash (pwHash string ){_eeba ._baca .PasswordAttr =_g .String (pwHash );};

// SetPassword sets the password hash to a hash of the input password.
func (_cbbce WorkbookProtection )SetPassword (pw string ){_cbbce .SetPasswordHash (PasswordHash (pw ))};func (_eeec Row )renumberAs (_fabd uint32 ){_eeec ._agbf .RAttr =_g .Uint32 (_fabd );for _ ,_deg :=range _eeec .Cells (){_cffd ,_gaeb :=_dg .ParseCellReference (_deg .Reference ());if _gaeb ==nil {_gaad :=_ade .Sprintf ("\u0025\u0073\u0025\u0064",_cffd .Column ,_fabd );_deg ._eeg .RAttr =_g .String (_gaad );};};};

// X returns the inner wrapped XML type.
func (_dga Border )X ()*_ba .CT_Border {return _dga ._cba };

// IsSheetLocked returns whether the sheet objects are locked.
func (_egdeb SheetProtection )IsObjectLocked ()bool {return _egdeb ._baca .ObjectsAttr !=nil &&*_egdeb ._baca .ObjectsAttr ;};var _gefd =[...]uint8 {0,18,37};func (_decg *Workbook )addCustomRelationships (){_decg .ContentTypes .AddOverride ("/\u0064o\u0063\u0050\u0072\u006f\u0070\u0073\u002f\u0063u\u0073\u0074\u006f\u006d.x\u006d\u006c","\u0061\u0070\u0070\u006c\u0069\u0063a\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065n\u0078\u006d\u006c\u0066\u006fr\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0063\u0075\u0073\u0074\u006f\u006d\u002d\u0070r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073+\u0078\u006d\u006c");_decg .Rels .AddRelationship ("\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c",_g .CustomPropertiesType );};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_cfbg *Workbook )SetActiveSheet (s Sheet ){for _cddb ,_efaf :=range _cfbg ._fgc {if s ._edeb ==_efaf {_cfbg .SetActiveSheetIndex (uint32 (_cddb ));};};};

// SetItalic causes the text to be displayed in italic.
func (_abba RichTextRun )SetItalic (b bool ){_abba .ensureRpr ();_abba ._fgfg .RPr .I =_ba .NewCT_BooleanProperty ();_abba ._fgfg .RPr .I .ValAttr =_g .Bool (b );};

// LockSheet controls the locking of the sheet.
func (_gfed SheetProtection )LockSheet (b bool ){if !b {_gfed ._baca .SheetAttr =nil ;}else {_gfed ._baca .SheetAttr =_g .Bool (true );};};

// ClearNumberFormat removes any number formatting from the style.
func (_bbg CellStyle )ClearNumberFormat (){_bbg ._daa .NumFmtIdAttr =nil ;_bbg ._daa .ApplyNumberFormatAttr =nil ;};

// SetPassword sets the password hash to a hash of the input password.
func (_dcfa SheetProtection )SetPassword (pw string ){_dcfa .SetPasswordHash (PasswordHash (pw ))};

// Name returns the sheet name
func (_cffg Sheet )Name ()string {return _cffg ._ggeg .NameAttr };func (_cd Border )SetBottom (style _ba .ST_BorderStyle ,c _gb .Color ){if _cd ._cba .Bottom ==nil {_cd ._cba .Bottom =_ba .NewCT_BorderPr ();};_cd ._cba .Bottom .Color =_ba .NewCT_Color ();_cd ._cba .Bottom .Color .RgbAttr =c .AsRGBAString ();_cd ._cba .Bottom .StyleAttr =style ;};func (_dce ConditionalFormattingRule )clear (){_dce ._bcca .OperatorAttr =_ba .ST_ConditionalFormattingOperatorUnset ;_dce ._bcca .ColorScale =nil ;_dce ._bcca .IconSet =nil ;_dce ._bcca .Formula =nil ;};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_gbbc *Workbook )AddImage (i _bfd .Image )(_bfd .ImageRef ,error ){_bfbbg :=_bfd .MakeImageRef (i ,&_gbbc .DocBase ,_gbbc ._fcad );if i .Data ==nil &&i .Path ==""{return _bfbbg ,_de .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _bfbbg ,_de .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _bfbbg ,_de .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};if i .Path !=""{_fgegb :=_b .Add (i .Path );if _fgegb !=nil {return _bfbbg ,_fgegb ;};};_gbbc .Images =append (_gbbc .Images ,_bfbbg );return _bfbbg ,nil ;};

// GetLocked returns true if the cell is locked.
func (_bgg *evalContext )GetLocked (cellRef string )bool {return _bgg ._abgg .Cell (cellRef ).getLocked ()};var ErrorNotFound =_de .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// AddView adds a sheet view.
func (_fbb *Sheet )AddView ()SheetView {if _fbb ._edeb .SheetViews ==nil {_fbb ._edeb .SheetViews =_ba .NewCT_SheetViews ();};_acf :=_ba .NewCT_SheetView ();_fbb ._edeb .SheetViews .SheetView =append (_fbb ._edeb .SheetViews .SheetView ,_acf );return SheetView {_acf };};

// X returns the inner wrapped XML type.
func (_dgaf *Workbook )X ()*_ba .Workbook {return _dgaf ._badbd };

// SetConditionValue sets the condition value to be used for style applicaton.
func (_dfgf ConditionalFormattingRule )SetConditionValue (v string ){_dfgf ._bcca .Formula =[]string {v }};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_gffe *Workbook )AddDefinedName (name ,ref string )DefinedName {if _gffe ._badbd .DefinedNames ==nil {_gffe ._badbd .DefinedNames =_ba .NewCT_DefinedNames ();};_bdba :=_ba .NewCT_DefinedName ();_bdba .Content =ref ;_bdba .NameAttr =name ;_gffe ._badbd .DefinedNames .DefinedName =append (_gffe ._badbd .DefinedNames .DefinedName ,_bdba );return DefinedName {_bdba };};func _dgcf ()*_ea .CT_AbsoluteAnchor {_agd :=_ea .NewCT_AbsoluteAnchor ();return _agd };

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_beca *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_d .Replace (rangeRef ,"\u0024","",-1);_beca ._edeb .AutoFilter =_ba .NewCT_AutoFilter ();_beca ._edeb .AutoFilter .RefAttr =_g .String (rangeRef );_dfbg :="\u0027"+_beca .Name ()+"\u0027\u0021";var _fbf DefinedName ;for _ ,_gbbf :=range _beca ._ebee .DefinedNames (){if _gbbf .Name ()==_gdga {if _d .HasPrefix (_gbbf .Content (),_dfbg ){_fbf =_gbbf ;_fbf .SetContent (_beca .RangeReference (rangeRef ));break ;};};};if _fbf .X ()==nil {_fbf =_beca ._ebee .AddDefinedName (_gdga ,_beca .RangeReference (rangeRef ));};for _bdee ,_faegd :=range _beca ._ebee ._fgc {if _faegd ==_beca ._edeb {_fbf .SetLocalSheetID (uint32 (_bdee ));};};};

// Type returns the type of anchor
func (_dbe OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// SetWidth is a no-op.
func (_faegb TwoCellAnchor )SetWidth (w _cf .Distance ){};

// X returns the inner wrapped XML type.
func (_bcg Column )X ()*_ba .CT_Col {return _bcg ._eaac };

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_dfgb *Workbook )Save (w _c .Writer )error {if !_bf .GetLicenseKey ().IsLicensed ()&&!_ebcd {_ade .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_ade .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return _de .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_effge :=_cb .NewWriter (w );defer _effge .Close ();_defbc :=_g .DocTypeSpreadsheet ;if _dgca :=_e .MarshalXML (_effge ,_g .BaseRelsFilename ,_dfgb .Rels .X ());_dgca !=nil {return _dgca ;};if _dfed :=_e .MarshalXMLByType (_effge ,_defbc ,_g .ExtendedPropertiesType ,_dfgb .AppProperties .X ());_dfed !=nil {return _dfed ;};if _affb :=_e .MarshalXMLByType (_effge ,_defbc ,_g .CorePropertiesType ,_dfgb .CoreProperties .X ());_affb !=nil {return _affb ;};_eeee :=_g .AbsoluteFilename (_defbc ,_g .OfficeDocumentType ,0);if _abdg :=_e .MarshalXML (_effge ,_eeee ,_dfgb ._badbd );_abdg !=nil {return _abdg ;};if _ffaag :=_e .MarshalXML (_effge ,_e .RelationsPathFor (_eeee ),_dfgb ._fcad .X ());_ffaag !=nil {return _ffaag ;};if _fbcgd :=_e .MarshalXMLByType (_effge ,_defbc ,_g .StylesType ,_dfgb .StyleSheet .X ());_fbcgd !=nil {return _fbcgd ;};for _dbeg ,_affg :=range _dfgb ._bbf {if _cffgd :=_e .MarshalXMLByTypeIndex (_effge ,_defbc ,_g .ThemeType ,_dbeg +1,_affg );_cffgd !=nil {return _cffgd ;};};for _gbgaf ,_gdbdc :=range _dfgb ._fgc {_gdbdc .Dimension .RefAttr =Sheet {_dfgb ,nil ,_gdbdc }.Extents ();_abe :=_g .AbsoluteFilename (_defbc ,_g .WorksheetType ,_gbgaf +1);_e .MarshalXML (_effge ,_abe ,_gdbdc );_e .MarshalXML (_effge ,_e .RelationsPathFor (_abe ),_dfgb ._gcga [_gbgaf ].X ());};if _dgdd :=_e .MarshalXMLByType (_effge ,_defbc ,_g .SharedStringsType ,_dfgb .SharedStrings .X ());_dgdd !=nil {return _dgdd ;};if _dfgb .CustomProperties .X ()!=nil {if _eaee :=_e .MarshalXMLByType (_effge ,_defbc ,_g .CustomPropertiesType ,_dfgb .CustomProperties .X ());_eaee !=nil {return _eaee ;};};if _dfgb .Thumbnail !=nil {_cbfe :=_g .AbsoluteFilename (_defbc ,_g .ThumbnailType ,0);_cegd ,_gagag :=_effge .Create (_cbfe );if _gagag !=nil {return _gagag ;};if _aabg :=_ad .Encode (_cegd ,_dfgb .Thumbnail ,nil );_aabg !=nil {return _aabg ;};};for _bced ,_cdcc :=range _dfgb ._bgfa {_eabba :=_g .AbsoluteFilename (_defbc ,_g .ChartType ,_bced +1);_e .MarshalXML (_effge ,_eabba ,_cdcc );};for _ebf ,_eag :=range _dfgb ._eedb {_bebe :=_g .AbsoluteFilename (_defbc ,_g .TableType ,_ebf +1);_e .MarshalXML (_effge ,_bebe ,_eag );};for _bbaa ,_dcff :=range _dfgb ._cbgc {_gadcg :=_g .AbsoluteFilename (_defbc ,_g .DrawingType ,_bbaa +1);_e .MarshalXML (_effge ,_gadcg ,_dcff );if !_dfgb ._dbagc [_bbaa ].IsEmpty (){_e .MarshalXML (_effge ,_e .RelationsPathFor (_gadcg ),_dfgb ._dbagc [_bbaa ].X ());};};for _debd ,_cbcb :=range _dfgb ._effd {_e .MarshalXML (_effge ,_g .AbsoluteFilename (_defbc ,_g .VMLDrawingType ,_debd +1),_cbcb );};for _ecd ,_cebg :=range _dfgb .Images {if _efec :=_bfd .AddImageToZip (_effge ,_cebg ,_ecd +1,_g .DocTypeSpreadsheet );_efec !=nil {return _efec ;};};if _gdbe :=_e .MarshalXML (_effge ,_g .ContentTypesFilename ,_dfgb .ContentTypes .X ());_gdbe !=nil {return _gdbe ;};for _bfac ,_afcb :=range _dfgb ._eabg {if _afcb ==nil {continue ;};_e .MarshalXML (_effge ,_g .AbsoluteFilename (_defbc ,_g .CommentsType ,_bfac +1),_afcb );};if _efcg :=_dfgb .WriteExtraFiles (_effge );_efcg !=nil {return _efcg ;};return _effge .Close ();};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);func (_agbb Font )SetBold (b bool ){if b {_agbb ._gcc .B =[]*_ba .CT_BooleanProperty {{}};}else {_agbb ._gcc .B =nil ;};};

// TopLeft returns the top-left corner of the anchored object.
func (_efcd OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_efcd ._agc .From }};

// Index returns the index of the differential style.
func (_fcgf DifferentialStyle )Index ()uint32 {for _ccad ,_eef :=range _fcgf ._fba .Dxf {if _fcgf ._geff ==_eef {return uint32 (_ccad );};};return 0;};

// X returns the inner wrapped XML type.
func (_fgbf DefinedName )X ()*_ba .CT_DefinedName {return _fgbf ._dcd };func (_fgbd Font )SetName (name string ){_fgbd ._gcc .Name =[]*_ba .CT_FontName {{ValAttr :name }}};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_gge Cell )SetTime (d _ag .Time ){_gge .clearValue ();d =_ca (d );_fad :=_gge ._agg .Epoch ();if d .Before (_fad ){_g .Log ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_adfa :=d .Sub (_fad );_be :=new (_gg .Float );_bb :=new (_gg .Float );_bb .SetPrec (128);_bb .SetUint64 (uint64 (_adfa ));_gdg :=new (_gg .Float );_gdg .SetUint64 (24*60*60*1e9);_be .Quo (_bb ,_gdg );_gge ._eeg .V =_g .String (_be .Text ('g',20));};func (_fefd PatternFill )ClearBgColor (){_fefd ._fefe .BgColor =nil };const (_eedef ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_faag ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_gbga ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_dddb ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);

// SetFormat sets the number format code.
func (_dfa NumberFormat )SetFormat (f string ){_dfa ._cgg .FormatCodeAttr =f };

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_afgbc *_ea .CT_TwoCellAnchor };

// Name returns the name of the defined name.
func (_eae DefinedName )Name ()string {return _eae ._dcd .NameAttr };

// SetNumber sets the cell type to number, and the value to the given number
func (_ddc Cell )SetNumber (v float64 ){_ddc .clearValue ();if _ce .IsNaN (v )||_ce .IsInf (v ,0){_ddc ._eeg .TAttr =_ba .ST_CellTypeE ;_ddc ._eeg .V =_g .String ("\u0023\u004e\u0055M\u0021");return ;};_ddc ._eeg .TAttr =_ba .ST_CellTypeN ;_ddc ._eeg .V =_g .String (_cg .FormatFloat (v ,'f',-1,64));};

// Operator returns the operator for the rule
func (_egdf ConditionalFormattingRule )Operator ()_ba .ST_ConditionalFormattingOperator {return _egdf ._bcca .OperatorAttr ;};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_dcd *_ba .CT_DefinedName };func (_cgbd DataValidationCompare )SetValue2 (v string ){_cgbd ._bgdf .Formula2 =&v };

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_eaac *_ba .CT_Col };

// New constructs a new workbook.
func New ()*Workbook {_defd :=&Workbook {};_defd ._badbd =_ba .NewWorkbook ();_defd .AppProperties =_bfd .NewAppProperties ();_defd .CoreProperties =_bfd .NewCoreProperties ();_defd .StyleSheet =NewStyleSheet (_defd );_defd .Rels =_bfd .NewRelationships ();_defd ._fcad =_bfd .NewRelationships ();_defd .Rels .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,"",_g .ExtendedPropertiesType ,0),_g .ExtendedPropertiesType );_defd .Rels .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,"",_g .CorePropertiesType ,0),_g .CorePropertiesType );_defd .Rels .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,"",_g .OfficeDocumentType ,0),_g .OfficeDocumentType );_defd ._fcad .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,_g .StylesType ,0),_g .StylesType );_defd .ContentTypes =_bfd .NewContentTypes ();_defd .ContentTypes .AddDefault ("\u0076\u006d\u006c",_g .VMLDrawingContentType );_defd .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_defd .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .StylesType ,0),_g .SMLStyleSheetContentType );_defd .SharedStrings =NewSharedStrings ();_defd .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .SharedStringsType ,0),_g .SharedStringsContentType );_defd ._fcad .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,_g .SharedStringsType ,0),_g .SharedStringsType );return _defd ;};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_agag *Sheet )AddHyperlink (url string )_bfd .Hyperlink {for _bgcb ,_cabg :=range _agag ._ebee ._fgc {if _cabg ==_agag ._edeb {return _agag ._ebee ._gcga [_bgcb ].AddHyperlink (url );};};return _bfd .Hyperlink {};};func _cbbcd (_bgb string )bool {_bgb =_d .Replace (_bgb ,"\u0024","",-1);if _fcfa :=_afge .FindStringSubmatch (_d .ToLower (_bgb ));len (_fcfa )> 2{_eed :=_fcfa [1];_bggb ,_fea :=_cg .Atoi (_fcfa [2]);if _fea !=nil {return false ;};return _bggb <=1048576&&_eed <="\u007a\u007a";};return false ;};

// SetLocked sets cell locked or not.
func (_adde *evalContext )SetLocked (cellRef string ,locked bool ){_adde ._abgg .Cell (cellRef ).setLocked (locked );};func (_cbbd Font )SetSize (size float64 ){_cbbd ._gcc .Sz =[]*_ba .CT_FontSize {{ValAttr :size }}};

// SetWrapped configures the cell to wrap text.
func (_bdg CellStyle )SetWrapped (b bool ){if _bdg ._daa .Alignment ==nil {_bdg ._daa .Alignment =_ba .NewCT_CellAlignment ();};if !b {_bdg ._daa .Alignment .WrapTextAttr =nil ;}else {_bdg ._daa .Alignment .WrapTextAttr =_g .Bool (true );_bdg ._daa .ApplyAlignmentAttr =_g .Bool (true );};};func (_efed *Sheet )setList (_ggecc string ,_dbfea _cgd .Result )error {_gfgf ,_agbfb :=_dg .ParseCellReference (_ggecc );if _agbfb !=nil {return _agbfb ;};_cffdc :=_efed .Row (_gfgf .RowIdx );for _bceb ,_gfef :=range _dbfea .ValueList {_acec :=_cffdc .Cell (_dg .IndexToColumn (_gfgf .ColumnIdx +uint32 (_bceb )));if _gfef .Type !=_cgd .ResultTypeEmpty {if _gfef .IsBoolean {_acec .SetBool (_gfef .ValueNumber !=0);}else {_acec .SetCachedFormulaResult (_gfef .String ());};};};return nil ;};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_cbe ,_cbf int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_bcc _cf .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_gea int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_aff _cf .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_db int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_afb _cf .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_gdb _cf .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_egbe *Workbook )ClearCachedFormulaResults (){for _ ,_ggac :=range _egbe .Sheets (){_ggac .ClearCachedFormulaResults ();};};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// AddFormatValue adds a format value (databars require two).
func (_afga DataBarScale )AddFormatValue (t _ba .ST_CfvoType ,val string ){_fade :=_ba .NewCT_Cfvo ();_fade .TypeAttr =t ;_fade .ValAttr =_g .String (val );_afga ._abb .Cfvo =append (_afga ._abb .Cfvo ,_fade );};

// X returns the inner wrapped XML type.
func (_fgf ColorScale )X ()*_ba .CT_ColorScale {return _fgf ._dgec };

// ClearAutoFilter removes the autofilters from the sheet.
func (_gga *Sheet )ClearAutoFilter (){_gga ._edeb .AutoFilter =nil ;_bcbe :="\u0027"+_gga .Name ()+"\u0027\u0021";for _ ,_cdce :=range _gga ._ebee .DefinedNames (){if _cdce .Name ()==_gdga {if _d .HasPrefix (_cdce .Content (),_bcbe ){_gga ._ebee .RemoveDefinedName (_cdce );break ;};};};};

// SetHeightCells is a no-op.
func (_bed OneCellAnchor )SetHeightCells (int32 ){};

// SetWidthCells is a no-op.
func (_gccc OneCellAnchor )SetWidthCells (int32 ){};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_decd TwoCellAnchor )SetHeightCells (h int32 ){_decd .SetHeight (0);_fggd :=_decd .TopLeft ();_ebbe :=_decd .BottomRight ();_ebbe .SetRow (_fggd .Row ()+h );};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gcda *Workbook )RecalculateFormulas (){for _ ,_bfcbe :=range _gcda .Sheets (){_bfcbe .RecalculateFormulas ();};};func (_gcgd CellStyle )Index ()uint32 {for _cag ,_cbc :=range _gcgd ._ebe .Xf {if _gcgd ._daa ==_cbc {return uint32 (_cag );};};return 0;};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_eggc ConditionalFormattingRule )SetDataBar ()DataBarScale {_eggc .clear ();_eggc .SetType (_ba .ST_CfTypeDataBar );_eggc ._bcca .DataBar =_ba .NewCT_DataBar ();_cbad :=DataBarScale {_eggc ._bcca .DataBar };_cbad .SetShowValue (true );_cbad .SetMinLength (10);_cbad .SetMaxLength (90);return _cbad ;};

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_ed Cell )SetFormulaShared (formula string ,rows ,cols uint32 )error {_ed .clearValue ();_ed ._eeg .TAttr =_ba .ST_CellTypeStr ;_ed ._eeg .F =_ba .NewCT_CellFormula ();_ed ._eeg .F .TAttr =_ba .ST_CellFormulaTypeShared ;_ed ._eeg .F .Content =formula ;_cdc ,_gac :=_dg .ParseCellReference (_ed .Reference ());if _gac !=nil {return _gac ;};_bd :=uint32 (0);for _ ,_gef :=range _ed ._afe .Rows (){for _ ,_bdd :=range _gef ._agbf .C {if _bdd .F !=nil &&_bdd .F .SiAttr !=nil &&*_bdd .F .SiAttr >=_bd {_bd =*_bdd .F .SiAttr ;};};};_bd ++;_aded :=_ade .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_cdc .Column ,_cdc .RowIdx ,_dg .IndexToColumn (_cdc .ColumnIdx +cols ),_cdc .RowIdx +rows );_ed ._eeg .F .RefAttr =_g .String (_aded );_ed ._eeg .F .SiAttr =_g .Uint32 (_bd );_bfc :=Sheet {_ed ._agg ,_ed ._afe ._ggeg ,_ed ._afe ._edeb };for _dcb :=_cdc .RowIdx ;_dcb <=_cdc .RowIdx +rows ;_dcb ++{for _bfae :=_cdc .ColumnIdx ;_bfae <=_cdc .ColumnIdx +cols ;_bfae ++{if _dcb ==_cdc .RowIdx &&_bfae ==_cdc .ColumnIdx {continue ;};_adgg :=_ade .Sprintf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_bfae ),_dcb );_bfc .Cell (_adgg ).Clear ();_bfc .Cell (_adgg ).X ().F =_ba .NewCT_CellFormula ();_bfc .Cell (_adgg ).X ().F .TAttr =_ba .ST_CellFormulaTypeShared ;_bfc .Cell (_adgg ).X ().F .SiAttr =_g .Uint32 (_bd );};};return nil ;};func (_eda *Sheet )removeColumnFromNamedRanges (_cbfc uint32 )error {for _ ,_bdebe :=range _eda ._ebee .DefinedNames (){_eabb :=_bdebe .Name ();_fcd :=_bdebe .Content ();_fgag :=_d .Split (_fcd ,"\u0021");if len (_fgag )!=2{return _de .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_fcd );};_fcac :=_fgag [0];if _eda .Name ()==_fcac {_gcgdc :=_eda ._ebee .RemoveDefinedName (_bdebe );if _gcgdc !=nil {return _gcgdc ;};_dacf :=_feae (_fgag [1],_cbfc ,true );if _dacf !=""{_abge :=_fcac +"\u0021"+_dacf ;_eda ._ebee .AddDefinedName (_eabb ,_abge );};};};_agdc :=0;if _eda ._edeb .TableParts !=nil &&_eda ._edeb .TableParts .TablePart !=nil {_agdc =len (_eda ._edeb .TableParts .TablePart );};if _agdc !=0{_fabaa :=0;for _ ,_gbee :=range _eda ._ebee .Sheets (){if _gbee .Name ()==_eda .Name (){break ;}else {if _gbee ._edeb .TableParts !=nil &&_gbee ._edeb .TableParts .TablePart !=nil {_fabaa +=len (_gbee ._edeb .TableParts .TablePart );};};};_ffad :=_eda ._ebee ._eedb [_fabaa :_fabaa +_agdc ];for _cef ,_gbbg :=range _ffad {_caea :=_gbbg ;_caea .RefAttr =_feae (_caea .RefAttr ,_cbfc ,false );_eda ._ebee ._eedb [_fabaa +_cef ]=_caea ;};};return nil ;};func (_febab *Workbook )ensureSharedStringsRelationships (){_ffdd :=false ;for _ ,_cfce :=range _febab .ContentTypes .X ().Override {if _cfce .ContentTypeAttr ==_g .SharedStringsContentType {_ffdd =true ;break ;};};if !_ffdd {_febab .ContentTypes .AddOverride (_dgfad ,_g .SharedStringsContentType );};_aead :=false ;for _ ,_fcfaa :=range _febab ._fcad .Relationships (){if _fcfaa .X ().TargetAttr ==_bccb {_aead =true ;break ;};};if !_aead {_febab ._fcad .AddRelationship (_bccb ,_g .SharedStringsType );};};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_gegg ConditionalFormattingRule )SetColorScale ()ColorScale {_gegg .clear ();_gegg .SetType (_ba .ST_CfTypeColorScale );_gegg ._bcca .ColorScale =_ba .NewCT_ColorScale ();return ColorScale {_gegg ._bcca .ColorScale };};

// SetReference sets the regin of cells that the merged cell applies to.
func (_dbba MergedCell )SetReference (ref string ){_dbba ._ddgc .RefAttr =ref };

// X returns the inner wrapped XML type.
func (_caaf ConditionalFormatting )X ()*_ba .CT_ConditionalFormatting {return _caaf ._fde };

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_eabf StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _eabf ._gfde .Dxfs ==nil {_eabf ._gfde .Dxfs =_ba .NewCT_Dxfs ();};_gbcc :=_ba .NewCT_Dxf ();_eabf ._gfde .Dxfs .Dxf =append (_eabf ._gfde .Dxfs .Dxf ,_gbcc );_eabf ._gfde .Dxfs .CountAttr =_g .Uint32 (uint32 (len (_eabf ._gfde .Dxfs .Dxf )));return DifferentialStyle {_gbcc ,_eabf ._aced ,_eabf ._gfde .Dxfs };};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_dfg Cell )SetDate (d _ag .Time ){_dfg .clearValue ();d =_ca (d );_dge :=_dfg ._agg .Epoch ();if d .Before (_dge ){_g .Log ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_edg :=d .Sub (_dge );_aae :=new (_gg .Float );_cc :=new (_gg .Float );_cc .SetPrec (128);_cc .SetUint64 (uint64 (_edg ));_afg :=new (_gg .Float );_afg .SetUint64 (24*60*60*1e9);_aae .Quo (_cc ,_afg );_bef ,_ :=_aae .Uint64 ();_dfg ._eeg .V =_g .Stringf ("\u0025\u0064",_bef );};

// SetDateWithStyle sets a date with the default date style applied.
func (_adfg Cell )SetDateWithStyle (d _ag .Time ){_adfg .SetDate (d );for _ ,_gfa :=range _adfg ._agg .StyleSheet .CellStyles (){if _gfa .HasNumberFormat ()&&_gfa .NumberFormat ()==uint32 (StandardFormatDate ){_adfg .SetStyle (_gfa );return ;};};_edd :=_adfg ._agg .StyleSheet .AddCellStyle ();_edd .SetNumberFormatStandard (StandardFormatDate );_adfg .SetStyle (_edd );};const (DVCompareTypeWholeNumber =DVCompareType (_ba .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_ba .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_ba .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_ba .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_ba .ST_DataValidationTypeTextLength ););

// SetOperator sets the operator for the rule.
func (_cbfg ConditionalFormattingRule )SetOperator (t _ba .ST_ConditionalFormattingOperator ){_cbfg ._bcca .OperatorAttr =t ;};

// Author returns the author of the comment
func (_bbc Comment )Author ()string {if _bbc ._fdd .AuthorIdAttr < uint32 (len (_bbc ._aaf .Authors .Author )){return _bbc ._aaf .Authors .Author [_bbc ._fdd .AuthorIdAttr ];};return "";};

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_cfgc Cell )SetStyle (cs CellStyle ){_cfgc .SetStyleIndex (cs .Index ())};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_agc *_ea .CT_OneCellAnchor };

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_eaa Cell )SetFormulaArray (s string ){_eaa .clearValue ();_eaa ._eeg .TAttr =_ba .ST_CellTypeStr ;_eaa ._eeg .F =_ba .NewCT_CellFormula ();_eaa ._eeg .F .TAttr =_ba .ST_CellFormulaTypeArray ;_eaa ._eeg .F .Content =s ;};func (_dffc SortOrder )String ()string {if _dffc >=SortOrder (len (_gefd )-1){return _ade .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_dffc );};return _dcbg [_gefd [_dffc ]:_gefd [_dffc +1]];};func (_bfa Border )SetDiagonal (style _ba .ST_BorderStyle ,c _gb .Color ,up ,down bool ){if _bfa ._cba .Diagonal ==nil {_bfa ._cba .Diagonal =_ba .NewCT_BorderPr ();};_bfa ._cba .Diagonal .Color =_ba .NewCT_Color ();_bfa ._cba .Diagonal .Color .RgbAttr =c .AsRGBAString ();_bfa ._cba .Diagonal .StyleAttr =style ;if up {_bfa ._cba .DiagonalUpAttr =_g .Bool (true );};if down {_bfa ._cba .DiagonalDownAttr =_g .Bool (true );};};

// AddCell adds a cell to a spreadsheet.
func (_bfdea Row )AddCell ()Cell {_bdafc :=uint32 (len (_bfdea ._agbf .C ));var _febf *string ;if _bdafc > 0{_bfeb :=_g .Stringf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_bdafc -1),_bfdea .RowNumber ());if _bfdea ._agbf .C [_bdafc -1].RAttr !=nil &&*_bfdea ._agbf .C [_bdafc -1].RAttr ==*_bfeb {_febf =_g .Stringf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_bdafc ),_bfdea .RowNumber ());};};_ecb :=_ba .NewCT_Cell ();_bfdea ._agbf .C =append (_bfdea ._agbf .C ,_ecb );if _febf ==nil {_dggf :=uint32 (0);for _ ,_ccaf :=range _bfdea ._agbf .C {if _ccaf .RAttr !=nil {_agdf ,_ :=_dg .ParseCellReference (*_ccaf .RAttr );if _agdf .ColumnIdx >=_dggf {_dggf =_agdf .ColumnIdx +1;};};};_febf =_g .Stringf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_dggf ),_bfdea .RowNumber ());};_ecb .RAttr =_febf ;return Cell {_bfdea ._bdaf ,_bfdea ._edfa ,_bfdea ._agbf ,_ecb };};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_gfd ,_fgdg :=_af .Open (filename );if _fgdg !=nil {return nil ,_ade .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fgdg );};defer _gfd .Close ();_cfgf ,_fgdg :=_af .Stat (filename );if _fgdg !=nil {return nil ,_ade .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fgdg );};_gadda ,_fgdg :=Read (_gfd ,_cfgf .Size ());if _fgdg !=nil {return nil ,_fgdg ;};_gdca ,_ :=_fb .Abs (_fb .Dir (filename ));_gadda ._gff =_fb .Join (_gdca ,filename );return _gadda ,nil ;};

// X returns the inner wrapped XML type.
func (_afaf RichText )X ()*_ba .CT_Rst {return _afaf ._aef };

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_dfee *Sheet )SetDrawing (d Drawing ){var _dfdd _bfd .Relationships ;for _eggd ,_ccgg :=range _dfee ._ebee ._fgc {if _ccgg ==_dfee ._edeb {_dfdd =_dfee ._ebee ._gcga [_eggd ];break ;};};var _ffab string ;for _dfb ,_bebg :=range d ._dea ._cbgc {if _bebg ==d ._bacd {_dfbb :=_dfdd .AddAutoRelationship (_g .DocTypeSpreadsheet ,_g .WorksheetType ,_dfb +1,_g .DrawingType );_ffab =_dfbb .ID ();break ;};};_dfee ._edeb .Drawing =_ba .NewCT_Drawing ();_dfee ._edeb .Drawing .IdAttr =_ffab ;};

// Reference returns the table reference (the cells within the table)
func (_gebb Table )Reference ()string {return _gebb ._eega .RefAttr };func (_cdea *Sheet )addNumberedRowFast (_dbfee uint32 )Row {_cfec :=_ba .NewCT_Row ();_cfec .RAttr =_g .Uint32 (_dbfee );_cdea ._edeb .SheetData .Row =append (_cdea ._edeb .SheetData .Row ,_cfec );return Row {_cdea ._ebee ,_cdea ,_cfec };};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_cgdb Cell )SetFormulaRaw (s string ){_cgdb .clearValue ();_cgdb ._eeg .TAttr =_ba .ST_CellTypeStr ;_cgdb ._eeg .F =_ba .NewCT_CellFormula ();_cgdb ._eeg .F .Content =s ;};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_egf Comment )SetCellReference (cellRef string ){_egf ._fdd .RefAttr =cellRef };func (_baac *evalContext )Cell (ref string ,ev _cgd .Evaluator )_cgd .Result {if !_cbbcd (ref ){return _cgd .MakeErrorResultType (_cgd .ErrorTypeName ,"");};_dfgc :=_baac ._abgg .Name ()+"\u0021"+ref ;if _eeb ,_aebb :=ev .GetFromCache (_dfgc );_aebb {return _eeb ;};_ccbe ,_cffbf :=_dg .ParseCellReference (ref );if _cffbf !=nil {return _cgd .MakeErrorResult (_ade .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_cffbf ));};if _baac ._efe !=0&&!_ccbe .AbsoluteColumn {_ccbe .ColumnIdx +=_baac ._efe ;_ccbe .Column =_dg .IndexToColumn (_ccbe .ColumnIdx );};if _baac ._ecad !=0&&!_ccbe .AbsoluteRow {_ccbe .RowIdx +=_baac ._ecad ;};_eee :=_baac ._abgg .Cell (_ccbe .String ());if _eee .HasFormula (){if _ ,_fbe :=_baac ._egcb [ref ];_fbe {return _cgd .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_baac ._egcb [ref ]=struct{}{};_acdba :=ev .Eval (_baac ,_eee .GetFormula ());delete (_baac ._egcb ,ref );ev .SetCache (_dfgc ,_acdba );return _acdba ;};if _eee .IsEmpty (){_bfg :=_cgd .MakeEmptyResult ();ev .SetCache (_dfgc ,_bfg );return _bfg ;}else if _eee .IsNumber (){_ffed ,_ :=_eee .GetValueAsNumber ();_bfaf :=_cgd .MakeNumberResult (_ffed );ev .SetCache (_dfgc ,_bfaf );return _bfaf ;}else if _eee .IsBool (){_cfc ,_ :=_eee .GetValueAsBool ();_dcf :=_cgd .MakeBoolResult (_cfc );ev .SetCache (_dfgc ,_dcf );return _dcf ;};_ddcg ,_ :=_eee .GetRawValue ();if _eee .IsError (){_bccf :=_cgd .MakeErrorResult ("");_bccf .ValueString =_ddcg ;ev .SetCache (_dfgc ,_bccf );return _bccf ;};_fdef :=_cgd .MakeStringResult (_ddcg );ev .SetCache (_dfgc ,_fdef );return _fdef ;};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_gca *Sheet )RemoveColumn (column string )error {_caeb ,_cdga :=_gca .getAllCellsInFormulaArraysForColumn ();if _cdga !=nil {return _cdga ;};_daeg :=_dg .ColumnToIndex (column );for _ ,_cfd :=range _gca .Rows (){_gcfc :=_ade .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_cfd .X ().RAttr );if _ ,_bbce :=_caeb [_gcfc ];_bbce {return nil ;};};for _ ,_cfff :=range _gca .Rows (){_fggc :=_cfff ._agbf .C ;for _eddd ,_bagg :=range _fggc {_bccg ,_geb :=_dg .ParseCellReference (*_bagg .RAttr );if _geb !=nil {return _geb ;};if _bccg .ColumnIdx ==_daeg {_cfff ._agbf .C =append (_fggc [:_eddd ],_gca .slideCellsLeft (_fggc [_eddd +1:])...);break ;}else if _bccg .ColumnIdx > _daeg {_cfff ._agbf .C =append (_fggc [:_eddd ],_gca .slideCellsLeft (_fggc [_eddd :])...);break ;};};};_cdga =_gca .updateAfterRemove (_daeg ,_cfa .UpdateActionRemoveColumn );if _cdga !=nil {return _cdga ;};_cdga =_gca .removeColumnFromNamedRanges (_daeg );if _cdga !=nil {return _cdga ;};_cdga =_gca .removeColumnFromMergedCells (_daeg );if _cdga !=nil {return _cdga ;};for _ ,_afgd :=range _gca ._ebee .Sheets (){_afgd .RecalculateFormulas ();};return nil ;};

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_gede StyleSheet )AddCellStyle ()CellStyle {_bafbg :=_ba .NewCT_Xf ();_gede ._gfde .CellXfs .Xf =append (_gede ._gfde .CellXfs .Xf ,_bafbg );_gede ._gfde .CellXfs .CountAttr =_g .Uint32 (uint32 (len (_gede ._gfde .CellXfs .Xf )));return CellStyle {_gede ._aced ,_bafbg ,_gede ._gfde .CellXfs };};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_ecaa *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_cbde :=range _ecaa .Sheets (){if _cbde .Name ()==name {return _cbde ,nil ;};};return Sheet {},ErrorNotFound ;};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_daac *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_aebbd :=_ba .NewCT_ConditionalFormatting ();_daac ._edeb .ConditionalFormatting =append (_daac ._edeb .ConditionalFormatting ,_aebbd );_gba :=make (_ba .ST_Sqref ,0,0);_aebbd .SqrefAttr =&_gba ;for _ ,_eabe :=range cellRanges {*_aebbd .SqrefAttr =append (*_aebbd .SqrefAttr ,_eabe );};return ConditionalFormatting {_aebbd };};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_aedf *Workbook )RemoveSheetByName (name string )error {_afgf :=-1;for _cdfgf ,_cegc :=range _aedf .Sheets (){if name ==_cegc .Name (){_afgf =_cdfgf ;break ;};};if _afgf ==-1{return ErrorNotFound ;};return _aedf .RemoveSheet (_afgf );};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_baad Sheet )Validate ()error {_bfbb :=[]func ()error {_baad .validateRowCellNumbers ,_baad .validateMergedCells ,_baad .validateSheetNames };for _ ,_fdbaae :=range _bfbb {if _edec :=_fdbaae ();_edec !=nil {return _edec ;};};if _edecf :=_baad ._edeb .Validate ();_edecf !=nil {return _edecf ;};return _baad ._edeb .Validate ();};

// SetHyperlink sets a hyperlink on a cell.
func (_gadc Cell )SetHyperlink (hl _bfd .Hyperlink ){_ec :=_gadc ._afe ._edeb ;if _ec .Hyperlinks ==nil {_ec .Hyperlinks =_ba .NewCT_Hyperlinks ();};_dac :=_bfd .Relationship (hl );_bab :=_ba .NewCT_Hyperlink ();_bab .RefAttr =_gadc .Reference ();_bab .IdAttr =_g .String (_dac .ID ());_ec .Hyperlinks .Hyperlink =append (_ec .Hyperlinks .Hyperlink ,_bab );};const _fd ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_gdbd Cell )GetString ()string {switch _gdbd ._eeg .TAttr {case _ba .ST_CellTypeInlineStr :if _gdbd ._eeg .Is !=nil &&_gdbd ._eeg .Is .T !=nil {return *_gdbd ._eeg .Is .T ;};if _gdbd ._eeg .V !=nil {return *_gdbd ._eeg .V ;};case _ba .ST_CellTypeS :if _gdbd ._eeg .V ==nil {return "";};_bgc ,_dfga :=_cg .Atoi (*_gdbd ._eeg .V );if _dfga !=nil {return "";};_aec ,_dfga :=_gdbd ._agg .SharedStrings .GetString (_bgc );if _dfga !=nil {return "";};return _aec ;};if _gdbd ._eeg .V ==nil {return "";};return *_gdbd ._eeg .V ;};var _ebcd =false ;

// SetColOffset sets the column offset of the top-left anchor.
func (_fce OneCellAnchor )SetColOffset (m _cf .Distance ){_fce .TopLeft ().SetColOffset (m )};

// X returns the inner wrapped XML type.
func (_adag RichTextRun )X ()*_ba .CT_RElt {return _adag ._fgfg };

// Priority returns the rule priority
func (_bdb ConditionalFormattingRule )Priority ()int32 {return _bdb ._bcca .PriorityAttr };

// PasswordHash returns the hash of the workbook password.
func (_gdegg SheetProtection )PasswordHash ()string {if _gdegg ._baca .PasswordAttr ==nil {return "";};return *_gdegg ._baca .PasswordAttr ;};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_cgda Cell )GetValueAsTime ()(_ag .Time ,error ){if _cgda ._eeg .TAttr !=_ba .ST_CellTypeUnset {return _ag .Time {},_de .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _cgda ._eeg .V ==nil {return _ag .Time {},_de .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_fcb ,_ ,_adbd :=_gg .ParseFloat (*_cgda ._eeg .V ,10,128,_gg .ToNearestEven );if _adbd !=nil {return _ag .Time {},_adbd ;};_cgc :=new (_gg .Float );_cgc .SetUint64 (uint64 (24*_ag .Hour ));_fcb .Mul (_fcb ,_cgc );_ggf ,_ :=_fcb .Uint64 ();_cdf :=_cgda ._agg .Epoch ().Add (_ag .Duration (_ggf ));return _adf (_cdf ),nil ;};

// SetTopLeft sets the top left visible cell after the split.
func (_ccdc SheetView )SetTopLeft (cellRef string ){_ccdc .ensurePane ();_ccdc ._adgd .Pane .TopLeftCellAttr =&cellRef ;};

// SetCol set the column of the cell marker.
func (_ece CellMarker )SetCol (col int32 ){_ece ._ccb .Col =col };

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_dacbb Row )Cell (col string )Cell {_bdc :=_ade .Sprintf ("\u0025\u0073\u0025\u0064",col ,_dacbb .RowNumber ());for _ ,_ffa :=range _dacbb ._agbf .C {if _ffa .RAttr !=nil &&*_ffa .RAttr ==_bdc {return Cell {_dacbb ._bdaf ,_dacbb ._edfa ,_dacbb ._agbf ,_ffa };};};return _dacbb .AddNamedCell (col );};func (_gbb Cell )getLabelPrefix ()string {if _gbb ._eeg .SAttr ==nil {return "";};_df :=*_gbb ._eeg .SAttr ;_dbd :=_gbb ._agg .StyleSheet .GetCellStyle (_df );switch _dbd ._daa .Alignment .HorizontalAttr {case _ba .ST_HorizontalAlignmentLeft :return "\u0027";case _ba .ST_HorizontalAlignmentRight :return "\u0022";case _ba .ST_HorizontalAlignmentCenter :return "\u005e";case _ba .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// SetMinLength sets the minimum bar length in percent.
func (_efef DataBarScale )SetMinLength (l uint32 ){_efef ._abb .MinLengthAttr =_g .Uint32 (l )};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_dfd IconScale )AddFormatValue (t _ba .ST_CfvoType ,val string ){_egfb :=_ba .NewCT_Cfvo ();_egfb .TypeAttr =t ;_egfb .ValAttr =_g .String (val );_dfd ._dacb .Cfvo =append (_dfd ._dacb .Cfvo ,_egfb );};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_afcda *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _afcda .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _aegc _bfd .Relationship ;for _ ,_cfegb :=range _afcda ._fcad .Relationships (){if _cfegb .ID ()==_afcda ._badbd .Sheets .Sheet [ind ].IdAttr {var _feace bool ;if _aegc ,_feace =_afcda ._fcad .CopyRelationship (_cfegb .ID ());!_feace {return Sheet {},ErrorNotFound ;};break ;};};_afcda .ContentTypes .CopyOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .WorksheetContentType ,ind +1),_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .WorksheetContentType ,len (_afcda .ContentTypes .X ().Override )));_ebeg :=*_afcda ._fgc [ind ];_afcda ._fgc =append (_afcda ._fgc ,&_ebeg );var _eaeg uint32 =0;for _ ,_daegc :=range _afcda ._badbd .Sheets .Sheet {if _daegc .SheetIdAttr > _eaeg {_eaeg =_daegc .SheetIdAttr ;};};_eaeg ++;_acbdf :=*_afcda ._badbd .Sheets .Sheet [ind ];_acbdf .IdAttr =_aegc .ID ();_acbdf .NameAttr =copiedSheetName ;_acbdf .SheetIdAttr =_eaeg ;_afcda ._badbd .Sheets .Sheet =append (_afcda ._badbd .Sheets .Sheet ,&_acbdf );_acgb :=_bfd .NewRelationshipsCopy (_afcda ._gcga [ind ]);_afcda ._gcga =append (_afcda ._gcga ,_acgb );_geda :=_afcda ._eabg [ind ];if _geda ==nil {_afcda ._eabg =append (_afcda ._eabg ,nil );}else {_gbcd :=*_geda ;_afcda ._eabg =append (_afcda ._eabg ,&_gbcd );};_ddgb :=Sheet {_afcda ,&_acbdf ,&_ebeg };return _ddgb ,nil ;};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_abb *_ba .CT_DataBar };

// Protection controls the protection on an individual sheet.
func (_eeeb *Sheet )Protection ()SheetProtection {if _eeeb ._edeb .SheetProtection ==nil {_eeeb ._edeb .SheetProtection =_ba .NewCT_SheetProtection ();};return SheetProtection {_eeeb ._edeb .SheetProtection };};

// IsBool returns true if the cell boolean value.
func (_cagd *evalContext )IsBool (cellRef string )bool {return _cagd ._abgg .Cell (cellRef ).IsBool ()};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_gbge *Sheet )InsertRow (rowNum int )Row {_dbafd :=uint32 (rowNum );for _ ,_bce :=range _gbge .Rows (){if _bce ._agbf .RAttr !=nil &&*_bce ._agbf .RAttr >=_dbafd {*_bce ._agbf .RAttr ++;for _ ,_aegea :=range _bce .Cells (){_fdbaa ,_abf :=_dg .ParseCellReference (_aegea .Reference ());if _abf !=nil {continue ;};_fdbaa .RowIdx ++;_aegea ._eeg .RAttr =_g .String (_fdbaa .String ());};};};for _ ,_feg :=range _gbge .MergedCells (){_bfaff ,_fddb ,_abd :=_dg .ParseRangeReference (_feg .Reference ());if _abd !=nil {continue ;};if int (_bfaff .RowIdx )>=rowNum {_bfaff .RowIdx ++;};if int (_fddb .RowIdx )>=rowNum {_fddb .RowIdx ++;};_bge :=_ade .Sprintf ("\u0025\u0073\u003a%\u0073",_bfaff ,_fddb );_feg .SetReference (_bge );};return _gbge .AddNumberedRow (_dbafd );};

// X returns the inner wrapped XML type.
func (_baba Sheet )X ()*_ba .Worksheet {return _baba ._edeb };

// SetHidden controls the visibility of a column.
func (_fcbf Column )SetHidden (b bool ){if !b {_fcbf ._eaac .HiddenAttr =nil ;}else {_fcbf ._eaac .HiddenAttr =_g .Bool (true );};};func (_cded Sheet )validateSheetNames ()error {if len (_cded .Name ())> 31{return _ade .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_cded .Name (),len (_cded .Name ()));};return nil ;};

// X returns the inner XML entity for a stylesheet.
func (_adbfa StyleSheet )X ()*_ba .StyleSheet {return _adbfa ._gfde };func (_ffdf *Workbook )onNewRelationship (_aaabc *_e .DecodeMap ,_bddfb ,_defa string ,_efedd []*_cb .File ,_eaege *_gbg .Relationship ,_efgd _e .Target )error {_bcccc :=_g .DocTypeSpreadsheet ;switch _defa {case _g .OfficeDocumentType :_ffdf ._badbd =_ba .NewWorkbook ();_aaabc .AddTarget (_bddfb ,_ffdf ._badbd ,_defa ,0);_ffdf ._fcad =_bfd .NewRelationships ();_aaabc .AddTarget (_e .RelationsPathFor (_bddfb ),_ffdf ._fcad .X (),_defa ,0);_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,0);case _g .CorePropertiesType :_aaabc .AddTarget (_bddfb ,_ffdf .CoreProperties .X (),_defa ,0);_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,0);case _g .CustomPropertiesType :_aaabc .AddTarget (_bddfb ,_ffdf .CustomProperties .X (),_defa ,0);_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,0);case _g .ExtendedPropertiesType :_aaabc .AddTarget (_bddfb ,_ffdf .AppProperties .X (),_defa ,0);_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,0);case _g .WorksheetType :_adge :=_ba .NewWorksheet ();_gfgd :=uint32 (len (_ffdf ._fgc ));_ffdf ._fgc =append (_ffdf ._fgc ,_adge );_aaabc .AddTarget (_bddfb ,_adge ,_defa ,_gfgd );_dgddg :=_bfd .NewRelationships ();_aaabc .AddTarget (_e .RelationsPathFor (_bddfb ),_dgddg .X (),_defa ,0);_ffdf ._gcga =append (_ffdf ._gcga ,_dgddg );_ffdf ._eabg =append (_ffdf ._eabg ,nil );_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,len (_ffdf ._fgc ));case _g .StylesType :_ffdf .StyleSheet =NewStyleSheet (_ffdf );_aaabc .AddTarget (_bddfb ,_ffdf .StyleSheet .X (),_defa ,0);_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,0);case _g .ThemeType :_gaae :=_dgf .NewTheme ();_ffdf ._bbf =append (_ffdf ._bbf ,_gaae );_aaabc .AddTarget (_bddfb ,_gaae ,_defa ,0);_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,len (_ffdf ._bbf ));case _g .SharedStringsType :_ffdf .SharedStrings =NewSharedStrings ();_aaabc .AddTarget (_bddfb ,_ffdf .SharedStrings .X (),_defa ,0);_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,0);case _g .ThumbnailType :for _cgae ,_geadd :=range _efedd {if _geadd ==nil {continue ;};if _geadd .Name ==_bddfb {_aegd ,_cdgaa :=_geadd .Open ();if _cdgaa !=nil {return _ade .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_cdgaa );};_ffdf .Thumbnail ,_ ,_cdgaa =_gd .Decode (_aegd );_aegd .Close ();if _cdgaa !=nil {return _ade .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_cdgaa );};_efedd [_cgae ]=nil ;};};case _g .ImageType :for _cdfd ,_fecd :=range _efedd {if _fecd ==nil {continue ;};if _fecd .Name ==_bddfb {_affa ,_gcae :=_e .ExtractToDiskTmp (_fecd ,_ffdf .TmpPath );if _gcae !=nil {return _gcae ;};_aefe ,_gcae :=_bfd .ImageFromStorage (_affa );if _gcae !=nil {return _gcae ;};_cbeb :=_bfd .MakeImageRef (_aefe ,&_ffdf .DocBase ,_ffdf ._fcad );_ffdf .Images =append (_ffdf .Images ,_cbeb );_efedd [_cdfd ]=nil ;};};_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,len (_ffdf .Images ));case _g .DrawingType :_bfeg :=_ea .NewWsDr ();_gecg :=uint32 (len (_ffdf ._cbgc ));_aaabc .AddTarget (_bddfb ,_bfeg ,_defa ,_gecg );_ffdf ._cbgc =append (_ffdf ._cbgc ,_bfeg );_fabf :=_bfd .NewRelationships ();_aaabc .AddTarget (_e .RelationsPathFor (_bddfb ),_fabf .X (),_defa ,_gecg );_ffdf ._dbagc =append (_ffdf ._dbagc ,_fabf );_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,len (_ffdf ._cbgc ));case _g .VMLDrawingType :_bfaa :=_da .NewContainer ();_fcca :=uint32 (len (_ffdf ._effd ));_aaabc .AddTarget (_bddfb ,_bfaa ,_defa ,_fcca );_ffdf ._effd =append (_ffdf ._effd ,_bfaa );case _g .CommentsType :_ffdf ._eabg [_efgd .Index ]=_ba .NewComments ();_aaabc .AddTarget (_bddfb ,_ffdf ._eabg [_efgd .Index ],_defa ,_efgd .Index );_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,len (_ffdf ._eabg ));case _g .ChartType :_ecbf :=_ef .NewChartSpace ();_cgfd :=uint32 (len (_ffdf ._bgfa ));_aaabc .AddTarget (_bddfb ,_ecbf ,_defa ,_cgfd );_ffdf ._bgfa =append (_ffdf ._bgfa ,_ecbf );_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,len (_ffdf ._bgfa ));case _g .TableType :_aggb :=_ba .NewTable ();_ccbb :=uint32 (len (_ffdf ._eedb ));_aaabc .AddTarget (_bddfb ,_aggb ,_defa ,_ccbb );_ffdf ._eedb =append (_ffdf ._eedb ,_aggb );_eaege .TargetAttr =_g .RelativeFilename (_bcccc ,_efgd .Typ ,_defa ,len (_ffdf ._eedb ));default:_g .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_bddfb ,_defa );};return nil ;};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_cbgfa *Sheet )ClearSheetViews (){_cbgfa ._edeb .SheetViews =nil };type Table struct{_eega *_ba .Table };

// MoveTo is a no-op.
func (_cbb AbsoluteAnchor )MoveTo (x ,y int32 ){};func (_dbaf Cell )GetRawValue ()(string ,error ){switch _dbaf ._eeg .TAttr {case _ba .ST_CellTypeInlineStr :if _dbaf ._eeg .Is ==nil ||_dbaf ._eeg .Is .T ==nil {return "",nil ;};return *_dbaf ._eeg .Is .T ,nil ;case _ba .ST_CellTypeS :if _dbaf ._eeg .V ==nil {return "",nil ;};_acc ,_gcg :=_cg .Atoi (*_dbaf ._eeg .V );if _gcg !=nil {return "",_gcg ;};return _dbaf ._agg .SharedStrings .GetString (_acc );case _ba .ST_CellTypeStr :if _dbaf ._eeg .F !=nil {return _dbaf ._eeg .F .Content ,nil ;};};if _dbaf ._eeg .V ==nil {return "",nil ;};return *_dbaf ._eeg .V ,nil ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_agae *evalContext )GetLabelPrefix (cellRef string )string {return _agae ._abgg .Cell (cellRef ).getLabelPrefix ();};

// GetEpoch returns a workbook's time epoch.
func (_fdefc *evalContext )GetEpoch ()_ag .Time {return _fdefc ._abgg ._ebee .Epoch ()};

// SetRowOffset sets the row offset of the top-left anchor.
func (_gcd OneCellAnchor )SetRowOffset (m _cf .Distance ){_gcd .TopLeft ().SetRowOffset (m )};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_bgdf *_ba .CT_DataValidation };

// SetRowOffset sets the row offset of the two cell anchor
func (_ddaf TwoCellAnchor )SetRowOffset (m _cf .Distance ){_bcbad :=m -_ddaf .TopLeft ().RowOffset ();_ddaf .TopLeft ().SetRowOffset (m );_ddaf .BottomRight ().SetRowOffset (_ddaf .BottomRight ().RowOffset ()+_bcbad );};

// Clear clears the cell's value and type.
func (_cea Cell )Clear (){_cea .clearValue ();_cea ._eeg .TAttr =_ba .ST_CellTypeUnset };type WorkbookProtection struct{_aba *_ba .CT_WorkbookProtection };

// Index returns the index of the border for use with a cell style.
func (_ee Border )Index ()uint32 {for _dba ,_fe :=range _ee ._dae .Border {if _fe ==_ee ._cba {return uint32 (_dba );};};return 0;};func (_fgdc Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _gaga ,_egbf ,_cgbe ,_facc uint32 =1,1,0,0;for _ ,_ege :=range _fgdc .Rows (){if _ege .RowNumber ()< _gaga {_gaga =_ege .RowNumber ();}else if _ege .RowNumber ()> _egbf {_egbf =_ege .RowNumber ();};for _ ,_aaga :=range _ege .Cells (){_aece ,_geea :=_dg .ParseCellReference (_aaga .Reference ());if _geea ==nil {if _aece .ColumnIdx < _cgbe {_cgbe =_aece .ColumnIdx ;}else if _aece .ColumnIdx > _facc {_facc =_aece .ColumnIdx ;};};};};return _dg .IndexToColumn (_cgbe ),_gaga ,_dg .IndexToColumn (_facc ),_egbf ;};func (_geeaa *Sheet )setArray (_bacg string ,_eadg _cgd .Result )error {_dbde ,_afcd :=_dg .ParseCellReference (_bacg );if _afcd !=nil {return _afcd ;};for _acgebd ,_cdfg :=range _eadg .ValueArray {_effe :=_geeaa .Row (_dbde .RowIdx +uint32 (_acgebd ));for _bcab ,_bedc :=range _cdfg {_ddfg :=_effe .Cell (_dg .IndexToColumn (_dbde .ColumnIdx +uint32 (_bcab )));if _bedc .Type !=_cgd .ResultTypeEmpty {if _bedc .IsBoolean {_ddfg .SetBool (_bedc .ValueNumber !=0);}else {_ddfg .SetCachedFormulaResult (_bedc .String ());};};};};return nil ;};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_fgea :=NumberFormat {_cgg :_ba .NewCT_NumFmt ()};_fgea ._cgg .NumFmtIdAttr =uint32 (id );_fgea ._cgg .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_fgea ._cgg .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_fgea ._cgg .FormatCodeAttr ="\u0030";case StandardFormat2 :_fgea ._cgg .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_fgea ._cgg .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_fgea ._cgg .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_fgea ._cgg .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_fgea ._cgg .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_fgea ._cgg .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_fgea ._cgg .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_fgea ._cgg .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_fgea ._cgg .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_fgea ._cgg .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_fgea ._cgg .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_fgea ._cgg .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_fgea ._cgg .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_fgea ._cgg .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_fgea ._cgg .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_fgea ._cgg .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_fgea ._cgg .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_fgea ._cgg .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_fgea ._cgg .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_fgea ._cgg .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_fgea ._cgg .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_fgea ._cgg .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_fgea ._cgg .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_fgea ._cgg .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_fgea ._cgg .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_fgea ._cgg .FormatCodeAttr ="\u0040";};return _fgea ;};

// SetColOffset sets the column offset of the two cell anchor.
func (_cdbe TwoCellAnchor )SetColOffset (m _cf .Distance ){_geeg :=m -_cdbe .TopLeft ().ColOffset ();_cdbe .TopLeft ().SetColOffset (m );_cdbe .BottomRight ().SetColOffset (_cdbe .BottomRight ().ColOffset ()+_geeg );};

// SetRotation configures the cell to be rotated.
func (_efg CellStyle )SetRotation (deg uint8 ){if _efg ._daa .Alignment ==nil {_efg ._daa .Alignment =_ba .NewCT_CellAlignment ();};_efg ._daa .ApplyAlignmentAttr =_g .Bool (true );_efg ._daa .Alignment .TextRotationAttr =_g .Uint8 (deg );};

// SetSize sets the text size for a rich text run.
func (_aebbg RichTextRun )SetSize (m _cf .Distance ){_aebbg .ensureRpr ();_aebbg ._fgfg .RPr .Sz =_ba .NewCT_FontSize ();_aebbg ._fgfg .RPr .Sz .ValAttr =float64 (m /_cf .Point );};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _c .ReaderAt ,size int64 )(*Workbook ,error ){_gcf :=New ();_gefe ,_fgga :=_b .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _fgga !=nil {return nil ,_fgga ;};_gcf .TmpPath =_gefe ;_dgfg ,_fgga :=_cb .NewReader (r ,size );if _fgga !=nil {return nil ,_ade .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_fgga );};_aafd :=[]*_cb .File {};_aafd =append (_aafd ,_dgfg .File ...);_gbgd :=false ;for _ ,_aaef :=range _aafd {if _aaef .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_gbgd =true ;break ;};};if _gbgd {_gcf .createCustomProperties ();};_fda :=_e .DecodeMap {};_fda .SetOnNewRelationshipFunc (_gcf .onNewRelationship );_fda .AddTarget (_g .ContentTypesFilename ,_gcf .ContentTypes .X (),"",0);_fda .AddTarget (_g .BaseRelsFilename ,_gcf .Rels .X (),"",0);if _bbe :=_fda .Decode (_aafd );_bbe !=nil {return nil ,_bbe ;};for _ ,_agbd :=range _aafd {if _agbd ==nil {continue ;};if _gada :=_gcf .AddExtraFileFromZip (_agbd );_gada !=nil {return nil ,_gada ;};};if _gbgd {_dde :=false ;for _ ,_dbfe :=range _gcf .Rels .X ().Relationship {if _dbfe .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_dde =true ;break ;};};if !_dde {_gcf .addCustomRelationships ();};};return _gcf ,nil ;};func (_dfe Fill )SetPatternFill ()PatternFill {_dfe ._dbf .GradientFill =nil ;_dfe ._dbf .PatternFill =_ba .NewCT_PatternFill ();_dfe ._dbf .PatternFill .PatternTypeAttr =_ba .ST_PatternTypeSolid ;return PatternFill {_dfe ._dbf .PatternFill ,_dfe ._dbf };};func (_ffc Border )SetLeft (style _ba .ST_BorderStyle ,c _gb .Color ){if _ffc ._cba .Left ==nil {_ffc ._cba .Left =_ba .NewCT_BorderPr ();};_ffc ._cba .Left .Color =_ba .NewCT_Color ();_ffc ._cba .Left .Color .RgbAttr =c .AsRGBAString ();_ffc ._cba .Left .StyleAttr =style ;};

// IsEmpty checks if the cell style contains nothing.
func (_fcg CellStyle )IsEmpty ()bool {return _fcg ._fga ==nil ||_fcg ._daa ==nil ||_fcg ._ebe ==nil ||_fcg ._ebe .Xf ==nil ;};

// GetFormula returns the formula for a cell.
func (_fcbd Cell )GetFormula ()string {if _fcbd ._eeg .F !=nil {return _fcbd ._eeg .F .Content ;};return "";};

// SetBorder applies a border to a cell style.  The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_caf CellStyle )SetBorder (b Border ){_caf ._daa .BorderIdAttr =_g .Uint32 (b .Index ());_caf ._daa .ApplyBorderAttr =_g .Bool (true );};

// RemoveDefinedName removes an existing defined name.
func (_gbce *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _de .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _gdcc ,_afafb :=range _gbce ._badbd .DefinedNames .DefinedName {if _afafb ==dn .X (){copy (_gbce ._badbd .DefinedNames .DefinedName [_gdcc :],_gbce ._badbd .DefinedNames .DefinedName [_gdcc +1:]);_gbce ._badbd .DefinedNames .DefinedName [len (_gbce ._badbd .DefinedNames .DefinedName )-1]=nil ;_gbce ._badbd .DefinedNames .DefinedName =_gbce ._badbd .DefinedNames .DefinedName [:len (_gbce ._badbd .DefinedNames .DefinedName )-1];return nil ;};};return _de .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// SetPriority sets the rule priority
func (_ccfgd ConditionalFormattingRule )SetPriority (p int32 ){_ccfgd ._bcca .PriorityAttr =p };

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_fgfg *_ba .CT_RElt };

// AddRule adds and returns a new rule that can be configured.
func (_addd ConditionalFormatting )AddRule ()ConditionalFormattingRule {_bea :=_ba .NewCT_CfRule ();_addd ._fde .CfRule =append (_addd ._fde .CfRule ,_bea );_cee :=ConditionalFormattingRule {_bea };_cee .InitializeDefaults ();_cee .SetPriority (int32 (len (_addd ._fde .CfRule )+1));return _cee ;};

// Row returns the row of the cell marker.
func (_bac CellMarker )Row ()int32 {return _bac ._ccb .Row };

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_fde *_ba .CT_ConditionalFormatting };

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_cfbd Sheet )Extents ()string {_beaf ,_ggc ,_ccggg ,_dfff :=_cfbd .ExtentsIndex ();return _ade .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_beaf ,_ggc ,_ccggg ,_dfff );};var (_dcfb =[...]uint8 {0,21,46,61,76,91};_aage =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_gebcd =[...]uint8 {0,16,32,48,64};_dgbc =[...]uint8 {0,16,32,48,64,80};);

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_deae *Sheet )Row (rowNum uint32 )Row {for _ ,_badc :=range _deae ._edeb .SheetData .Row {if _badc .RAttr !=nil &&*_badc .RAttr ==rowNum {return Row {_deae ._ebee ,_deae ,_badc };};};return _deae .AddNumberedRow (rowNum );};func _adf (_gad _ag .Time )_ag .Time {_gad =_gad .UTC ();return _ag .Date (_gad .Year (),_gad .Month (),_gad .Day (),_gad .Hour (),_gad .Minute (),_gad .Second (),_gad .Nanosecond (),_ag .Local );};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_dffe CellStyle )SetVerticalAlignment (a _ba .ST_VerticalAlignment ){if _dffe ._daa .Alignment ==nil {_dffe ._daa .Alignment =_ba .NewCT_CellAlignment ();};_dffe ._daa .ApplyAlignmentAttr =_g .Bool (true );_dffe ._daa .Alignment .VerticalAttr =a ;};func (_bfbe Sheet )validateMergedCells ()error {_fcgc :=map[uint64 ]struct{}{};for _ ,_afca :=range _bfbe .MergedCells (){_dgff ,_fac ,_gacd :=_dg .ParseRangeReference (_afca .Reference ());if _gacd !=nil {return _ade .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_bfbe .Name (),_afca .Reference ());};for _acbe :=_dgff .RowIdx ;_acbe <=_fac .RowIdx ;_acbe ++{for _cfb :=_dgff .ColumnIdx ;_cfb <=_fac .ColumnIdx ;_cfb ++{_fcbb :=uint64 (_acbe )<<32|uint64 (_cfb );if _ ,_ecea :=_fcgc [_fcbb ];_ecea {return _ade .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_bfbe .Name ());};_fcgc [_fcbb ]=struct{}{};};};};return nil ;};func (_fa Cell )getFormat ()string {if _fa ._eeg .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_gbe :=*_fa ._eeg .SAttr ;_gec :=_fa ._agg .StyleSheet .GetCellStyle (_gbe );_geg :=_fa ._agg .StyleSheet .GetNumberFormat (_gec .NumberFormat ());return _geg .GetFormat ();};func (_bcbb Font )SetColor (c _gb .Color ){_edb :=_ba .NewCT_Color ();_aafe :="\u0066\u0066"+*c .AsRGBString ();_edb .RgbAttr =&_aafe ;_bcbb ._gcc .Color =[]*_ba .CT_Color {_edb };};

// ClearFill clears any fill configuration from the cell style.
func (_afa CellStyle )ClearFill (){_afa ._daa .FillIdAttr =nil ;_afa ._daa .ApplyFillAttr =nil };

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_babc *Sheet )Column (idx uint32 )Column {for _ ,_bbec :=range _babc ._edeb .Cols {for _ ,_bbbb :=range _bbec .Col {if idx >=_bbbb .MinAttr &&idx <=_bbbb .MaxAttr {return Column {_bbbb };};};};var _gaddb *_ba .CT_Cols ;if len (_babc ._edeb .Cols )==0{_gaddb =_ba .NewCT_Cols ();_babc ._edeb .Cols =append (_babc ._edeb .Cols ,_gaddb );}else {_gaddb =_babc ._edeb .Cols [0];};_dcad :=_ba .NewCT_Col ();_dcad .MinAttr =idx ;_dcad .MaxAttr =idx ;_gaddb .Col =append (_gaddb .Col ,_dcad );return Column {_dcad };};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_gdda *Sheet )Cell (cellRef string )Cell {_gedg ,_fdba :=_dg .ParseCellReference (cellRef );if _fdba !=nil {_g .Log ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_fdba );return _gdda .AddRow ().AddCell ();};return _gdda .Row (_gedg .RowIdx ).Cell (_gedg .Column );};

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_gde Row )Cells ()[]Cell {_dfag :=[]Cell {};_gcgde :=-1;for _ ,_dec :=range _gde ._agbf .C {if _dec .RAttr ==nil {_g .Log ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_fcbdb ,_gegd :=_dg .ParseCellReference (*_dec .RAttr );if _gegd !=nil {_g .Log ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_dec .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_eba :=int (_fcbdb .ColumnIdx );if _eba -_gcgde > 1{for _fgbc :=_gcgde +1;_fgbc < _eba ;_fgbc ++{_dfag =append (_dfag ,_gde .Cell (_dg .IndexToColumn (uint32 (_fgbc ))));};};_gcgde =_eba ;_dfag =append (_dfag ,Cell {_gde ._bdaf ,_gde ._edfa ,_gde ._agbf ,_dec });};return _dfag ;};

// Comments returns the list of comments for this sheet
func (_dfc Comments )Comments ()[]Comment {_deegc :=[]Comment {};for _ ,_cfe :=range _dfc ._caa .CommentList .Comment {_deegc =append (_deegc ,Comment {_dfc ._efc ,_cfe ,_dfc ._caa });};return _deegc ;};func (_dbedg Sheet )IsValid ()bool {return _dbedg ._edeb !=nil };

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_ebce :=uint16 (0);if len (s )> 0{for _fdbb :=len (s )-1;_fdbb >=0;_fdbb --{_cfgcb :=s [_fdbb ];_ebce =((_ebce >>14)&0x01)|((_ebce <<1)&0x7fff);_ebce ^=uint16 (_cfgcb );};_ebce =((_ebce >>14)&0x01)|((_ebce <<1)&0x7fff);_ebce ^=uint16 (len (s ));_ebce ^=(0x8000|('N'<<8)|'K');};return _ade .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_ebce ));};

// SetStyle sets the style to be used for conditional rules
func (_fae ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_fae ._bcca .DxfIdAttr =_g .Uint32 (d .Index ());};

// SetColor sets the text color.
func (_gbf RichTextRun )SetColor (c _gb .Color ){_gbf .ensureRpr ();_gbf ._fgfg .RPr .Color =_ba .NewCT_Color ();_eab :="\u0066\u0066"+*c .AsRGBString ();_gbf ._fgfg .RPr .Color .RgbAttr =&_eab ;};

// ColOffset returns the offset from the row cell.
func (_eaae CellMarker )ColOffset ()_cf .Distance {if _eaae ._ccb .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _cf .Distance (float64 (*_eaae ._ccb .ColOff .ST_CoordinateUnqualified )*_cf .EMU );};

// LockStructure controls the locking of the workbook structure.
func (_bbbf WorkbookProtection )LockStructure (b bool ){if !b {_bbbf ._aba .LockStructureAttr =nil ;}else {_bbbf ._aba .LockStructureAttr =_g .Bool (true );};};

// Validate attempts to validate the structure of a workbook.
func (_gdef *Workbook )Validate ()error {if _gdef ==nil ||_gdef ._badbd ==nil {return _de .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_feec :=uint32 (0);for _ ,_gaf :=range _gdef ._badbd .Sheets .Sheet {if _gaf .SheetIdAttr > _feec {_feec =_gaf .SheetIdAttr ;};};if _feec !=uint32 (len (_gdef ._fgc )){return _ade .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_feec ,len (_gdef ._fgc ));};_dbccf :=map[string ]struct{}{};for _dfcc ,_dgdf :=range _gdef ._badbd .Sheets .Sheet {_fbgf :=Sheet {_gdef ,_dgdf ,_gdef ._fgc [_dfcc ]};if _ ,_bafc :=_dbccf [_fbgf .Name ()];_bafc {return _ade .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_dfcc ,_fbgf .Name ());};_dbccf [_fbgf .Name ()]=struct{}{};if _ffgb :=_fbgf .ValidateWithPath (_ade .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_dfcc ));_ffgb !=nil {return _ffgb ;};if _aegb :=_fbgf .Validate ();_aegb !=nil {return _aegb ;};};return nil ;};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_faee Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_cfaaa :=[]Cell {};for _cbdf :=uint32 (0);_cbdf <=lastColIdx ;_cbdf ++{_adc :=_faee .Cell (_dg .IndexToColumn (_cbdf ));_cfaaa =append (_cfaaa ,_adc );};return _cfaaa ;};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_gdc DataValidation )SetRange (cellRange string ){_gdc ._daec .SqrefAttr =_ba .ST_Sqref {cellRange }};func (_fgg Cell )getLocked ()bool {if _fgg ._eeg .SAttr ==nil {return false ;};_gc :=*_fgg ._eeg .SAttr ;_baf :=_fgg ._agg .StyleSheet .GetCellStyle (_gc );return *_baf ._daa .Protection .LockedAttr ;};

// GetFilename returns the filename of the context's workbook.
func (_cfcg *evalContext )GetFilename ()string {return _cfcg ._abgg ._ebee .GetFilename ()};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// SetUnderline controls if the run is underlined.
func (_ccdg RichTextRun )SetUnderline (u _ba .ST_UnderlineValues ){_ccdg .ensureRpr ();_ccdg ._fgfg .RPr .U =_ba .NewCT_UnderlineProperty ();_ccdg ._fgfg .RPr .U .ValAttr =u ;};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_fg AbsoluteAnchor )SetRowOffset (m _cf .Distance ){_fg ._deb .Pos .YAttr .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_cf .EMU ));};

// IsBool returns true if the cell is a boolean type cell.
func (_gbec Cell )IsBool ()bool {return _gbec ._eeg .TAttr ==_ba .ST_CellTypeB };

// AddDataValidation adds a data validation rule to a sheet.
func (_geac *Sheet )AddDataValidation ()DataValidation {if _geac ._edeb .DataValidations ==nil {_geac ._edeb .DataValidations =_ba .NewCT_DataValidations ();};_ggd :=_ba .NewCT_DataValidation ();_ggd .ShowErrorMessageAttr =_g .Bool (true );_geac ._edeb .DataValidations .DataValidation =append (_geac ._edeb .DataValidations .DataValidation ,_ggd );_geac ._edeb .DataValidations .CountAttr =_g .Uint32 (uint32 (len (_geac ._edeb .DataValidations .DataValidation )));return DataValidation {_ggd };};

// X returns the inner wrapped XML type.
func (_adeb Table )X ()*_ba .Table {return _adeb ._eega };func (_egdd *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _egdd .getAllCellsInFormulaArrays (false );};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_adgd *_ba .CT_SheetView };

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_effb TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_effb ._afgbc .To }};

// X returns the inner wrapped XML type.
func (_bae DifferentialStyle )X ()*_ba .CT_Dxf {return _bae ._geff };

// Sheets returns the sheets from the workbook.
func (_fggdb *Workbook )Sheets ()[]Sheet {_dbeb :=[]Sheet {};for _geeag ,_cgee :=range _fggdb ._fgc {_aacd :=_fggdb ._badbd .Sheets .Sheet [_geeag ];_bace :=Sheet {_fggdb ,_aacd ,_cgee };_dbeb =append (_dbeb ,_bace );};return _dbeb ;};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_fagf *Workbook )SetActiveSheetIndex (idx uint32 ){if _fagf ._badbd .BookViews ==nil {_fagf ._badbd .BookViews =_ba .NewCT_BookViews ();};if len (_fagf ._badbd .BookViews .WorkbookView )==0{_fagf ._badbd .BookViews .WorkbookView =append (_fagf ._badbd .BookViews .WorkbookView ,_ba .NewCT_BookView ());};_fagf ._badbd .BookViews .WorkbookView [0].ActiveTabAttr =_g .Uint32 (idx );};

// SetIcons sets the icon set to use for display.
func (_fff IconScale )SetIcons (t _ba .ST_IconSetType ){_fff ._dacb .IconSetAttr =t };

// IconScale maps values to icons.
type IconScale struct{_dacb *_ba .CT_IconSet };

// SetPasswordHash sets the password hash to the input.
func (_bdgb WorkbookProtection )SetPasswordHash (pwHash string ){_bdgb ._aba .WorkbookPasswordAttr =_g .String (pwHash );};func _feae (_eeea string ,_fefc uint32 ,_afgb bool )string {_cabd ,_ecg ,_dfbga :=_dg .ParseRangeReference (_eeea );if _dfbga ==nil {_eggg ,_aeag :=_cabd .ColumnIdx ,_ecg .ColumnIdx ;if _fefc >=_eggg &&_fefc <=_aeag {if _eggg ==_aeag {if _afgb {return "";}else {return _eeea ;};}else {_faccg :=_ecg .Update (_cfa .UpdateActionRemoveColumn );return _ade .Sprintf ("\u0025\u0073\u003a%\u0073",_cabd .String (),_faccg .String ());};}else if _fefc < _eggg {_cdfb :=_cabd .Update (_cfa .UpdateActionRemoveColumn );_geab :=_ecg .Update (_cfa .UpdateActionRemoveColumn );return _ade .Sprintf ("\u0025\u0073\u003a%\u0073",_cdfb .String (),_geab .String ());};}else {_bbd ,_gbeg ,_daab :=_dg .ParseColumnRangeReference (_eeea );if _daab !=nil {return "";};_ffede ,_gdaf :=_bbd .ColumnIdx ,_gbeg .ColumnIdx ;if _fefc >=_ffede &&_fefc <=_gdaf {if _ffede ==_gdaf {if _afgb {return "";}else {return _eeea ;};}else {_afeba :=_gbeg .Update (_cfa .UpdateActionRemoveColumn );return _ade .Sprintf ("\u0025\u0073\u003a%\u0073",_bbd .String (),_afeba .String ());};}else if _fefc < _ffede {_dag :=_bbd .Update (_cfa .UpdateActionRemoveColumn );_eaba :=_gbeg .Update (_cfa .UpdateActionRemoveColumn );return _ade .Sprintf ("\u0025\u0073\u003a%\u0073",_dag .String (),_eaba .String ());};};return "";};func (_fcag CellStyle )SetShrinkToFit (b bool ){if _fcag ._daa .Alignment ==nil {_fcag ._daa .Alignment =_ba .NewCT_CellAlignment ();};_fcag ._daa .ApplyAlignmentAttr =_g .Bool (true );if !b {_fcag ._daa .Alignment .ShrinkToFitAttr =nil ;}else {_fcag ._daa .Alignment .ShrinkToFitAttr =_g .Bool (b );};};

// CellStyles returns the list of defined cell styles
func (_gdbb StyleSheet )CellStyles ()[]CellStyle {_efad :=[]CellStyle {};for _ ,_bbcc :=range _gdbb ._gfde .CellXfs .Xf {_efad =append (_efad ,CellStyle {_gdbb ._aced ,_bbcc ,_gdbb ._gfde .CellXfs });};return _efad ;};

// Rows returns all of the rows in a sheet.
func (_babed *Sheet )Rows ()[]Row {_ebga :=[]Row {};for _ ,_dadg :=range _babed ._edeb .SheetData .Row {_ebga =append (_ebga ,Row {_babed ._ebee ,_babed ,_dadg });};return _ebga ;};

// Content returns the content of the defined range (the range in most cases)/
func (_dgfa DefinedName )Content ()string {return _dgfa ._dcd .Content };

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_faeg *_ba .Sst ;_ceae map[string ]int ;};

// X returns the inner wrapped XML type.
func (_fcfe SheetView )X ()*_ba .CT_SheetView {return _fcfe ._adgd };func _ca (_acd _ag .Time )_ag .Time {_acd =_acd .Local ();return _ag .Date (_acd .Year (),_acd .Month (),_acd .Day (),_acd .Hour (),_acd .Minute (),_acd .Second (),_acd .Nanosecond (),_ag .UTC );};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_cfg Cell )SetString (s string )int {_cfg ._agg .ensureSharedStringsRelationships ();_cfg .clearValue ();_bdf :=_cfg ._agg .SharedStrings .AddString (s );_cfg ._eeg .V =_g .String (_cg .Itoa (_bdf ));_cfg ._eeg .TAttr =_ba .ST_CellTypeS ;return _bdf ;};func (_gcb Cell )getRawSortValue ()(string ,bool ){if _gcb .HasFormula (){_ddd :=_gcb .GetCachedFormulaResult ();return _ddd ,_gdd .IsNumber (_ddd );};_afc ,_ :=_gcb .GetRawValue ();return _afc ,_gdd .IsNumber (_afc );};func (_bbgc StandardFormat )String ()string {switch {case 0<=_bbgc &&_bbgc <=4:return _eedef [_dcfb [_bbgc ]:_dcfb [_bbgc +1]];case 9<=_bbgc &&_bbgc <=22:_bbgc -=9;return _faag [_aage [_bbgc ]:_aage [_bbgc +1]];case 37<=_bbgc &&_bbgc <=40:_bbgc -=37;return _gbga [_gebcd [_bbgc ]:_gebcd [_bbgc +1]];case 45<=_bbgc &&_bbgc <=49:_bbgc -=45;return _dddb [_dgbc [_bbgc ]:_dgbc [_bbgc +1]];default:return _ade .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_bbgc );};};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_bff CellStyle )SetNumberFormatStandard (s StandardFormat ){_bff ._daa .NumFmtIdAttr =_g .Uint32 (uint32 (s ));_bff ._daa .ApplyNumberFormatAttr =_g .Bool (true );};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_gfc *evalContext )LastColumn (rowFrom ,rowTo int )string {_deed :=_gfc ._abgg ;_fgb :=1;for _egcg :=rowFrom ;_egcg <=rowTo ;_egcg ++{_ebg :=len (_deed .Row (uint32 (_egcg )).Cells ());if _ebg > _fgb {_fgb =_ebg ;};};return _dg .IndexToColumn (uint32 (_fgb -1));};func _daee (_cca *Sheet )*evalContext {return &evalContext {_abgg :_cca ,_egcb :make (map[string ]struct{})};};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_cefb *Workbook )Close ()error {if _cefb .TmpPath !=""{return _b .RemoveAll (_cefb .TmpPath );};return nil ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_cdbd *Sheet )ClearCachedFormulaResults (){for _ ,_geed :=range _cdbd .Rows (){for _ ,_ddca :=range _geed .Cells (){if _ddca .X ().F !=nil {_ddca .X ().V =nil ;};};};};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_bafb CellStyle )SetHorizontalAlignment (a _ba .ST_HorizontalAlignment ){if _bafb ._daa .Alignment ==nil {_bafb ._daa .Alignment =_ba .NewCT_CellAlignment ();};_bafb ._daa .Alignment .HorizontalAttr =a ;_bafb ._daa .ApplyAlignmentAttr =_g .Bool (true );};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_ccc *Sheet )AddNumberedRow (rowNum uint32 )Row {_abbf :=_ba .NewCT_Row ();_abbf .RAttr =_g .Uint32 (rowNum );_ccc ._edeb .SheetData .Row =append (_ccc ._edeb .SheetData .Row ,_abbf );_f .Slice (_ccc ._edeb .SheetData .Row ,func (_bga ,_acef int )bool {_bbbe :=_ccc ._edeb .SheetData .Row [_bga ].RAttr ;_eebee :=_ccc ._edeb .SheetData .Row [_acef ].RAttr ;if _bbbe ==nil {return true ;};if _eebee ==nil {return true ;};return *_bbbe < *_eebee ;});return Row {_ccc ._ebee ,_ccc ,_abbf };};

// AddFormatValue adds a format value to be used to determine the cell background.
func (_gag ColorScale )AddFormatValue (t _ba .ST_CfvoType ,val string ){_acge :=_ba .NewCT_Cfvo ();_acge .TypeAttr =t ;_acge .ValAttr =_g .String (val );_gag ._dgec .Cfvo =append (_gag ._dgec .Cfvo ,_acge );};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_dbccd Sheet )ValidateWithPath (path string )error {return _dbccd ._edeb .ValidateWithPath (path )};var _bccb =_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,_g .SharedStringsType ,0);

// SetHeight is a nop-op.
func (_cceb TwoCellAnchor )SetHeight (h _cf .Distance ){};

// X returns the inner wrapped XML type.
func (_defg WorkbookProtection )X ()*_ba .CT_WorkbookProtection {return _defg ._aba };

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_faa *Sheet )SheetViews ()[]SheetView {if _faa ._edeb .SheetViews ==nil {return nil ;};_fbga :=[]SheetView {};for _ ,_edgd :=range _faa ._edeb .SheetViews .SheetView {_fbga =append (_fbga ,SheetView {_edgd });};return _fbga ;};

// X returns the inner wrapped XML type.
func (_bgba SharedStrings )X ()*_ba .Sst {return _bgba ._faeg };

// AddCommentWithStyle adds a new comment styled in a default way
func (_agf Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_efa :=_agf .AddComment (cellRef ,author );_acdb :=_efa .AddRun ();_acdb .SetBold (true );_acdb .SetSize (10);_acdb .SetColor (_gb .Black );_acdb .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_acdb .SetText (author +"\u003a");_acdb =_efa .AddRun ();_acdb .SetSize (10);_acdb .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_acdb .SetColor (_gb .Black );_acdb .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_cdd ,_aac :=_dg .ParseCellReference (cellRef );if _aac !=nil {return _aac ;};_agf ._efc ._effd [0].Shape =append (_agf ._efc ._effd [0].Shape ,_da .NewCommentShape (int64 (_cdd .ColumnIdx ),int64 (_cdd .RowIdx -1)));return nil ;};func (_bbb PatternFill )ClearFgColor (){_bbb ._fefe .FgColor =nil };

// SetPattern sets the pattern of the fill.
func (_fdbbb PatternFill )SetPattern (p _ba .ST_PatternType ){_fdbbb ._fefe .PatternTypeAttr =p };

// SetName sets the sheet name.
func (_bca *Sheet )SetName (name string ){_bca ._ggeg .NameAttr =name };

// SetContent sets the defined name content.
func (_ceb DefinedName )SetContent (s string ){_ceb ._dcd .Content =s };func (_gedc Font )Index ()uint32 {for _cdfe ,_fdb :=range _gedc ._abc .Fonts .Font {if _gedc ._gcc ==_fdb {return uint32 (_cdfe );};};return 0;};const (DVCompareOpEqual =DVCompareOp (_ba .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_ba .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_ba .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_ba .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_ba .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_ba .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_ba .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_ba .ST_DataValidationOperatorLessThanOrEqual ););type Fill struct{_dbf *_ba .CT_Fill ;_bafba *_ba .CT_Fills ;};func (_deeg Cell )setLocked (_eg bool ){_fbc :=_deeg ._eeg .SAttr ;if _fbc !=nil {_bfdf :=_deeg ._agg .StyleSheet .GetCellStyle (*_fbc );if _bfdf ._daa .Protection ==nil {_bfdf ._daa .Protection =_ba .NewCT_CellProtection ();};_bfdf ._daa .Protection .LockedAttr =&_eg ;};};

// AddSheet adds a new sheet to a workbook.
func (_efag *Workbook )AddSheet ()Sheet {_fcdg :=_ba .NewCT_Sheet ();_fcdg .SheetIdAttr =1;for _ ,_bafa :=range _efag ._badbd .Sheets .Sheet {if _fcdg .SheetIdAttr <=_bafa .SheetIdAttr {_fcdg .SheetIdAttr =_bafa .SheetIdAttr +1;};};_efag ._badbd .Sheets .Sheet =append (_efag ._badbd .Sheets .Sheet ,_fcdg );_fcdg .NameAttr =_ade .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_fcdg .SheetIdAttr );_fgee :=_ba .NewWorksheet ();_fgee .Dimension =_ba .NewCT_SheetDimension ();_fgee .Dimension .RefAttr ="\u0041\u0031";_efag ._fgc =append (_efag ._fgc ,_fgee );_begd :=_bfd .NewRelationships ();_efag ._gcga =append (_efag ._gcga ,_begd );_fgee .SheetData =_ba .NewCT_SheetData ();_efag ._eabg =append (_efag ._eabg ,nil );_agbe :=_g .DocTypeSpreadsheet ;_cggcf :=_efag ._fcad .AddAutoRelationship (_agbe ,_g .OfficeDocumentType ,len (_efag ._badbd .Sheets .Sheet ),_g .WorksheetType );_fcdg .IdAttr =_cggcf .ID ();_efag .ContentTypes .AddOverride (_g .AbsoluteFilename (_agbe ,_g .WorksheetContentType ,len (_efag ._badbd .Sheets .Sheet )),_g .WorksheetContentType );return Sheet {_efag ,_fcdg ,_fgee };};

// AddFont adds a new empty font to the stylesheet.
func (_gdfg StyleSheet )AddFont ()Font {_fcae :=_ba .NewCT_Font ();_gdfg ._gfde .Fonts .Font =append (_gdfg ._gfde .Fonts .Font ,_fcae );_gdfg ._gfde .Fonts .CountAttr =_g .Uint32 (uint32 (len (_gdfg ._gfde .Fonts .Font )));return Font {_fcae ,_gdfg ._gfde };};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_ggcg *Sheet )SetBorder (cellRange string ,border Border )error {_fgbdc ,_eddb ,_fecc :=_dg .ParseRangeReference (cellRange );if _fecc !=nil {return _fecc ;};_faf :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_aeaa :=_ggcg ._ebee .StyleSheet .AddBorder ();_faf .SetBorder (_aeaa );_aeaa ._cba .Top =border ._cba .Top ;_aeaa ._cba .Left =border ._cba .Left ;_eccc :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_effgd :=_ggcg ._ebee .StyleSheet .AddBorder ();_eccc .SetBorder (_effgd );_effgd ._cba .Top =border ._cba .Top ;_effgd ._cba .Right =border ._cba .Right ;_adga :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_dgag :=_ggcg ._ebee .StyleSheet .AddBorder ();_adga .SetBorder (_dgag );_dgag ._cba .Top =border ._cba .Top ;_ffaa :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_fgda :=_ggcg ._ebee .StyleSheet .AddBorder ();_ffaa .SetBorder (_fgda );_fgda ._cba .Left =border ._cba .Left ;_ddeb :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_dfgcd :=_ggcg ._ebee .StyleSheet .AddBorder ();_ddeb .SetBorder (_dfgcd );_dfgcd ._cba .Right =border ._cba .Right ;_ceef :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_fbgd :=_ggcg ._ebee .StyleSheet .AddBorder ();_ceef .SetBorder (_fbgd );_fbgd ._cba .Bottom =border ._cba .Bottom ;_cbbcb :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_ffcg :=_ggcg ._ebee .StyleSheet .AddBorder ();_cbbcb .SetBorder (_ffcg );_ffcg ._cba .Bottom =border ._cba .Bottom ;_ffcg ._cba .Left =border ._cba .Left ;_ggbea :=_ggcg ._ebee .StyleSheet .AddCellStyle ();_gadf :=_ggcg ._ebee .StyleSheet .AddBorder ();_ggbea .SetBorder (_gadf );_gadf ._cba .Bottom =border ._cba .Bottom ;_gadf ._cba .Right =border ._cba .Right ;_cggc :=_fgbdc .RowIdx ;_fgbb :=_fgbdc .ColumnIdx ;_dcbd :=_eddb .RowIdx ;_eccf :=_eddb .ColumnIdx ;for _cffgg :=_cggc ;_cffgg <=_dcbd ;_cffgg ++{for _dfcg :=_fgbb ;_dfcg <=_eccf ;_dfcg ++{_cgeg :=_ade .Sprintf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_dfcg ),_cffgg );switch {case _cffgg ==_cggc &&_dfcg ==_fgbb :_ggcg .Cell (_cgeg ).SetStyle (_faf );case _cffgg ==_cggc &&_dfcg ==_eccf :_ggcg .Cell (_cgeg ).SetStyle (_eccc );case _cffgg ==_dcbd &&_dfcg ==_fgbb :_ggcg .Cell (_cgeg ).SetStyle (_cbbcb );case _cffgg ==_dcbd &&_dfcg ==_eccf :_ggcg .Cell (_cgeg ).SetStyle (_ggbea );case _cffgg ==_cggc :_ggcg .Cell (_cgeg ).SetStyle (_adga );case _cffgg ==_dcbd :_ggcg .Cell (_cgeg ).SetStyle (_ceef );case _dfcg ==_fgbb :_ggcg .Cell (_cgeg ).SetStyle (_ffaa );case _dfcg ==_eccf :_ggcg .Cell (_cgeg ).SetStyle (_ddeb );};};};return nil ;};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_ccag *Workbook )RemoveSheet (ind int )error {if _ccag .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_edfc :=range _ccag ._fcad .Relationships (){if _edfc .ID ()==_ccag ._badbd .Sheets .Sheet [ind ].IdAttr {_ccag ._fcad .Remove (_edfc );break ;};};_ccag .ContentTypes .RemoveOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .WorksheetContentType ,ind +1));copy (_ccag ._fgc [ind :],_ccag ._fgc [ind +1:]);_ccag ._fgc =_ccag ._fgc [:len (_ccag ._fgc )-1];_daef :=_ccag ._badbd .Sheets .Sheet [ind ];copy (_ccag ._badbd .Sheets .Sheet [ind :],_ccag ._badbd .Sheets .Sheet [ind +1:]);_ccag ._badbd .Sheets .Sheet =_ccag ._badbd .Sheets .Sheet [:len (_ccag ._badbd .Sheets .Sheet )-1];for _fada :=range _ccag ._badbd .Sheets .Sheet {if _ccag ._badbd .Sheets .Sheet [_fada ].SheetIdAttr > _daef .SheetIdAttr {_ccag ._badbd .Sheets .Sheet [_fada ].SheetIdAttr --;};};copy (_ccag ._gcga [ind :],_ccag ._gcga [ind +1:]);_ccag ._gcga =_ccag ._gcga [:len (_ccag ._gcga )-1];copy (_ccag ._eabg [ind :],_ccag ._eabg [ind +1:]);_ccag ._eabg =_ccag ._eabg [:len (_ccag ._eabg )-1];return nil ;};var _dgfad =_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .SharedStringsType ,0);

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_bfd .DocBase ;_badbd *_ba .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_eabg []*_ba .Comments ;_fgc []*_ba .Worksheet ;_gcga []_bfd .Relationships ;_fcad _bfd .Relationships ;_bbf []*_dgf .Theme ;_cbgc []*_ea .WsDr ;_dbagc []_bfd .Relationships ;_effd []*_da .Container ;_bgfa []*_ef .ChartSpace ;_eedb []*_ba .Table ;_gff string ;};

// ClearProtection clears all workbook protections.
func (_eacb *Workbook )ClearProtection (){_eacb ._badbd .WorkbookProtection =nil };func (_cfgb DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_cfgb .clear ();_cfgb ._daec .TypeAttr =_ba .ST_DataValidationType (t );_cfgb ._daec .OperatorAttr =_ba .ST_DataValidationOperator (op );return DataValidationCompare {_cfgb ._daec };};

// SetFont sets the font name for a rich text run.
func (_gbfg RichTextRun )SetFont (s string ){_gbfg .ensureRpr ();_gbfg ._fgfg .RPr .RFont =_ba .NewCT_FontName ();_gbfg ._fgfg .RPr .RFont .ValAttr =s ;};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_fc AbsoluteAnchor )SetColOffset (m _cf .Distance ){_fc ._deb .Pos .XAttr .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_cf .EMU ));};func (_ebcg Fills )AddFill ()Fill {_bcge :=_ba .NewCT_Fill ();_ebcg ._caabg .Fill =append (_ebcg ._caabg .Fill ,_bcge );_ebcg ._caabg .CountAttr =_g .Uint32 (uint32 (len (_ebcg ._caabg .Fill )));return Fill {_bcge ,_ebcg ._caabg };};

// SetHeight sets the height of the anchored object.
func (_cdb OneCellAnchor )SetHeight (h _cf .Distance ){_cdb ._agc .Ext .CyAttr =int64 (h /_cf .EMU )};

// SetStyle sets the cell style for an entire column.
func (_dca Column )SetStyle (cs CellStyle ){_dca ._eaac .StyleAttr =_g .Uint32 (cs .Index ())};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_baa Cell )AddHyperlink (url string ){for _bcb ,_bddc :=range _baa ._agg ._fgc {if _bddc ==_baa ._afe ._edeb {_baa .SetHyperlink (_baa ._agg ._gcga [_bcb ].AddHyperlink (url ));return ;};};};func (_ddcec Fill )Index ()uint32 {if _ddcec ._bafba ==nil {return 0;};for _geef ,_cbcee :=range _ddcec ._bafba .Fill {if _ddcec ._dbf ==_cbcee {return uint32 (_geef );};};return 0;};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_bda Cell )SetBool (v bool ){_bda .clearValue ();_bda ._eeg .V =_g .String (_cg .Itoa (_feb (v )));_bda ._eeg .TAttr =_ba .ST_CellTypeB ;};const (DVOpGreater =_ba .ST_DataValidationOperatorGreaterThanOrEqual ;);

// Comments is the container for comments for a single sheet.
type Comments struct{_efc *Workbook ;_caa *_ba .Comments ;};

// X returns the inner wrapped XML type.
func (_cce Comment )X ()*_ba .CT_Comment {return _cce ._fdd };func NewFills ()Fills {return Fills {_ba .NewCT_Fills ()}};

// GetOrCreateCustomProperties returns the custom properties of the document (and if they not exist yet, creating them first)
func (_aega *Workbook )GetOrCreateCustomProperties ()_bfd .CustomProperties {if _aega .CustomProperties .X ()==nil {_aega .createCustomProperties ();};return _aega .CustomProperties ;};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_cdbg *Workbook )RemoveCalcChain (){var _cafb string ;for _ ,_ffbd :=range _cdbg ._fcad .Relationships (){if _ffbd .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_cafb ="\u0078\u006c\u002f"+_ffbd .Target ();_cdbg ._fcad .Remove (_ffbd );break ;};};if _cafb ==""{return ;};_cdbg .ContentTypes .RemoveOverride (_cafb );for _gefa ,_ffbc :=range _cdbg .ExtraFiles {if _ffbc .ZipPath ==_cafb {_cdbg .ExtraFiles [_gefa ]=_cdbg .ExtraFiles [len (_cdbg .ExtraFiles )-1];_cdbg .ExtraFiles =_cdbg .ExtraFiles [:len (_cdbg .ExtraFiles )-1];return ;};};};

// Fonts returns the list of fonts defined in the stylesheet.
func (_bddfa StyleSheet )Fonts ()[]Font {_efae :=[]Font {};for _ ,_afcg :=range _bddfa ._gfde .Fonts .Font {_efae =append (_efae ,Font {_afcg ,_bddfa ._gfde });};return _efae ;};func (_gf Border )SetTop (style _ba .ST_BorderStyle ,c _gb .Color ){if _gf ._cba .Top ==nil {_gf ._cba .Top =_ba .NewCT_BorderPr ();};_gf ._cba .Top .Color =_ba .NewCT_Color ();_gf ._cba .Top .Color .RgbAttr =c .AsRGBAString ();_gf ._cba .Top .StyleAttr =style ;};

// Border is a cell border configuraton.
type Border struct{_cba *_ba .CT_Border ;_dae *_ba .CT_Borders ;};

// SetWidth sets the width of the anchored object.
func (_dgdg OneCellAnchor )SetWidth (w _cf .Distance ){_dgdg ._agc .Ext .CxAttr =int64 (w /_cf .EMU )};

// X returns the inner wrapped XML type.
func (_ggb ConditionalFormattingRule )X ()*_ba .CT_CfRule {return _ggb ._bcca };

// SetHidden hides or unhides the row
func (_bdef Row )SetHidden (hidden bool ){if !hidden {_bdef ._agbf .HiddenAttr =nil ;}else {_bdef ._agbf .HiddenAttr =_g .Bool (true );};};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_egdc *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_dgeg :=_egdc ._edeb .SheetData .Row ;_ggfc :=_egdc .Rows ();for _bcag ,_acff :=range _ggfc {if _acff .RowNumber ()==firstRow {_dgeg =_egdc ._edeb .SheetData .Row [_bcag :];break ;};};_aaff :=Comparer {Order :order };_f .Slice (_dgeg ,func (_dfac ,_daea int )bool {return _aaff .LessRows (column ,Row {_egdc ._ebee ,_egdc ,_dgeg [_dfac ]},Row {_egdc ._ebee ,_egdc ,_dgeg [_daea ]});});for _aed ,_dcfc :=range _egdc .Rows (){_agbc :=uint32 (_aed +1);if _dcfc .RowNumber ()!=_agbc {_dcfc .renumberAs (_agbc );};};};

// X returns the inner wrapped XML type.
func (_bec Row )X ()*_ba .CT_Row {return _bec ._agbf };

// GetValueAsBool retrieves the cell's value as a boolean
func (_cbbc Cell )GetValueAsBool ()(bool ,error ){if _cbbc ._eeg .TAttr !=_ba .ST_CellTypeB {return false ,_de .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _cbbc ._eeg .V ==nil {return false ,_de .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _cg .ParseBool (*_cbbc ._eeg .V );};

// DataValidation controls cell validation
type DataValidation struct{_daec *_ba .CT_DataValidation };

// IsError returns true if the cell is an error type cell.
func (_ede Cell )IsError ()bool {return _ede ._eeg .TAttr ==_ba .ST_CellTypeE };

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_gbba DataValidationList )SetRange (cellRange string ){_gbba ._dddf .Formula1 =_g .String (cellRange );_gbba ._dddf .Formula2 =_g .String ("\u0030");};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_cdgc StyleSheet )RemoveFont (f Font )error {for _eacga ,_dggeb :=range _cdgc ._gfde .Fonts .Font {if _dggeb ==f .X (){_cdgc ._gfde .Fonts .Font =append (_cdgc ._gfde .Fonts .Font [:_eacga ],_cdgc ._gfde .Fonts .Font [_eacga +1:]...);return nil ;};};return _de .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// X returns the inner wrapped XML type.
func (_aca DataValidation )X ()*_ba .CT_DataValidation {return _aca ._daec };

// Col returns the column of the cell marker.
func (_egd CellMarker )Col ()int32 {return _egd ._ccb .Col };

// SetColOffset sets a column offset in absolute distance.
func (_dbb CellMarker )SetColOffset (m _cf .Distance ){_dbb ._ccb .ColOff .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_cf .EMU ));};

// LockWindow controls the locking of the workbook windows.
func (_ebac WorkbookProtection )LockWindow (b bool ){if !b {_ebac ._aba .LockWindowsAttr =nil ;}else {_ebac ._aba .LockWindowsAttr =_g .Bool (true );};};

// ClearBorder clears any border configuration from the cell style.
func (_gbd CellStyle )ClearBorder (){_gbd ._daa .BorderIdAttr =nil ;_gbd ._daa .ApplyBorderAttr =nil };

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_egb DataValidationCompare )SetValue (v string ){_egb ._bgdf .Formula1 =&v };

// MergedCells returns the merged cell regions within the sheet.
func (_fgeaa *Sheet )MergedCells ()[]MergedCell {if _fgeaa ._edeb .MergeCells ==nil {return nil ;};_faba :=[]MergedCell {};for _ ,_gedcb :=range _fgeaa ._edeb .MergeCells .MergeCell {_faba =append (_faba ,MergedCell {_fgeaa ._ebee ,_fgeaa ,_gedcb });};return _faba ;};

// GetString retrieves a string from the shared strings table by index.
func (_cfggb SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_ade .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_cfggb ._faeg .Si ){return "",_ade .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_cfggb ._faeg .Si ));};_eacd :=_cfggb ._faeg .Si [id ];if _eacd .T !=nil {return *_eacd .T ,nil ;};return "",nil ;};

// SetHidden marks the defined name as hidden.
func (_cbce DefinedName )SetHidden (b bool ){_cbce ._dcd .HiddenAttr =_g .Bool (b )};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_ba .Comments )Comments {return Comments {w ,x }};

// SetError sets the cell type to error and the value to the given error message.
func (_cge Cell )SetError (msg string ){_cge .clearValue ();_cge ._eeg .V =_g .String (msg );_cge ._eeg .TAttr =_ba .ST_CellTypeE ;};

// MoveTo repositions the anchor without changing the objects size.
func (_feac TwoCellAnchor )MoveTo (col ,row int32 ){_baea :=_feac .TopLeft ();_dcebe :=_feac .BottomRight ();_fdefg :=_dcebe .Col ()-_baea .Col ();_bgaf :=_dcebe .Row ()-_baea .Row ();_baea .SetCol (col );_baea .SetRow (row );_dcebe .SetCol (col +_fdefg );_dcebe .SetRow (row +_bgaf );};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_ffac *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_ffdda :=-1;for _gdad ,_eaebc :=range _ffac .Sheets (){if name ==_eaebc .Name (){_ffdda =_gdad ;break ;};};if _ffdda ==-1{return Sheet {},ErrorNotFound ;};return _ffac .CopySheet (_ffdda ,copiedSheetName );};

// AddGradientStop adds a color gradient stop.
func (_aeb ColorScale )AddGradientStop (color _gb .Color ){_gece :=_ba .NewCT_Color ();_gece .RgbAttr =color .AsRGBAString ();_aeb ._dgec .Color =append (_aeb ._dgec .Color ,_gece );};

// TopLeft is a no-op.
func (_bc AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// SetWidthCells is a no-op.
func (_eb AbsoluteAnchor )SetWidthCells (int32 ){};

// Type returns the type of anchor
func (_fbebb TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_bad ConditionalFormattingRule )SetIcons ()IconScale {_bad .clear ();_bad .SetType (_ba .ST_CfTypeIconSet );_bad ._bcca .IconSet =_ba .NewCT_IconSet ();_acdc :=IconScale {_bad ._bcca .IconSet };_acdc .SetIcons (_ba .ST_IconSetType3TrafficLights1 );return _acdc ;};

// IsHidden returns whether the row is hidden or not.
func (_acgeb Row )IsHidden ()bool {return _acgeb ._agbf .HiddenAttr !=nil &&*_acgeb ._agbf .HiddenAttr };const _dcbg ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";

// CellMarker represents a cell position
type CellMarker struct{_ccb *_ea .CT_Marker };

// AddString adds a string to the shared string cache.
func (_aaaa SharedStrings )AddString (v string )int {if _egde ,_afbb :=_aaaa ._ceae [v ];_afbb {return _egde ;};_ebceb :=_ba .NewCT_Rst ();_ebceb .T =_g .String (v );_aaaa ._faeg .Si =append (_aaaa ._faeg .Si ,_ebceb );_fgfb :=len (_aaaa ._faeg .Si )-1;_aaaa ._ceae [v ]=_fgfb ;_aaaa ._faeg .CountAttr =_g .Uint32 (uint32 (len (_aaaa ._faeg .Si )));_aaaa ._faeg .UniqueCountAttr =_aaaa ._faeg .CountAttr ;return _fgfb ;};

// IsEmpty returns true if the cell is empty.
func (_ccd Cell )IsEmpty ()bool {return _ccd ._eeg .TAttr ==_ba .ST_CellTypeUnset &&_ccd ._eeg .V ==nil &&_ccd ._eeg .F ==nil ;};func (_bcfcd *evalContext )SetOffset (col ,row uint32 ){_bcfcd ._efe =col ;_bcfcd ._ecad =row };

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// Cell is a single cell within a sheet.
type Cell struct{_agg *Workbook ;_afe *Sheet ;_adg *_ba .CT_Row ;_eeg *_ba .CT_Cell ;};

// X returns the inner wrapped XML type.
func (_acce Drawing )X ()*_ea .WsDr {return _acce ._bacd };

// IsStructureLocked returns whether the workbook structure is locked.
func (_agfg WorkbookProtection )IsStructureLocked ()bool {return _agfg ._aba .LockStructureAttr !=nil &&*_agfg ._aba .LockStructureAttr ;};func (_cdfc DataValidation )SetList ()DataValidationList {_cdfc .clear ();_cdfc ._daec .TypeAttr =_ba .ST_DataValidationTypeList ;_cdfc ._daec .OperatorAttr =_ba .ST_DataValidationOperatorEqual ;return DataValidationList {_cdfc ._daec };};

// SetColor sets teh color of the databar.
func (_fdc DataBarScale )SetColor (c _gb .Color ){_fdc ._abb .Color =_ba .NewCT_Color ();_fdc ._abb .Color .RgbAttr =c .AsRGBAString ();};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_cdaf *Workbook )GetFilename ()string {return _cdaf ._gff };

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_add Cell )SetStringByID (id int ){_add ._agg .ensureSharedStringsRelationships ();_add .clearValue ();_add ._eeg .V =_g .String (_cg .Itoa (id ));_add ._eeg .TAttr =_ba .ST_CellTypeS ;};func (_beb *evalContext )NamedRange (ref string )_cgd .Reference {for _ ,_acb :=range _beb ._abgg ._ebee .DefinedNames (){if _acb .Name ()==ref {return _cgd .MakeRangeReference (_acb .Content ());};};for _ ,_geaa :=range _beb ._abgg ._ebee .Tables (){if _geaa .Name ()==ref {return _cgd .MakeRangeReference (_ade .Sprintf ("\u0025\u0073\u0021%\u0073",_beb ._abgg .Name (),_geaa .Reference ()));};};return _cgd .ReferenceInvalid ;};

// SaveToFile writes the workbook out to a file.
func (_bcbc *Workbook )SaveToFile (path string )error {_fbff ,_ggde :=_af .Create (path );if _ggde !=nil {return _ggde ;};defer _fbff .Close ();return _bcbc .Save (_fbff );};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_dadc *Sheet )InitialView ()SheetView {if _dadc ._edeb .SheetViews ==nil ||len (_dadc ._edeb .SheetViews .SheetView )==0{return _dadc .AddView ();};return SheetView {_dadc ._edeb .SheetViews .SheetView [0]};};type MergedCell struct{_bdbe *Workbook ;_ffg *Sheet ;_ddgc *_ba .CT_MergeCell ;};

// GetWidth returns a worksheet's column width.
func (_adeg *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_ccg :=range _adeg ._abgg .X ().Cols [0].Col {if int (_ccg .MinAttr )<=colIdx &&colIdx <=int (_ccg .MaxAttr ){return float64 (int (*_ccg .WidthAttr ));};};return 0;};

// HasFormula returns true if the cell has an asoociated formula.
func (_gcgc Cell )HasFormula ()bool {return _gcgc ._eeg .F !=nil };

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_agfa :=_ba .NewStyleSheet ();_agfa .CellStyleXfs =_ba .NewCT_CellStyleXfs ();_agfa .CellXfs =_ba .NewCT_CellXfs ();_agfa .CellStyles =_ba .NewCT_CellStyles ();_cfccb :=_ba .NewCT_CellStyle ();_cfccb .NameAttr =_g .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_cfccb .XfIdAttr =0;_cfccb .BuiltinIdAttr =_g .Uint32 (0);_agfa .CellStyles .CellStyle =append (_agfa .CellStyles .CellStyle ,_cfccb );_agfa .CellStyles .CountAttr =_g .Uint32 (uint32 (len (_agfa .CellStyles .CellStyle )));_cadg :=_ba .NewCT_Xf ();_cadg .NumFmtIdAttr =_g .Uint32 (0);_cadg .FontIdAttr =_g .Uint32 (0);_cadg .FillIdAttr =_g .Uint32 (0);_cadg .BorderIdAttr =_g .Uint32 (0);_agfa .CellStyleXfs .Xf =append (_agfa .CellStyleXfs .Xf ,_cadg );_agfa .CellStyleXfs .CountAttr =_g .Uint32 (uint32 (len (_agfa .CellStyleXfs .Xf )));_gdgc :=NewFills ();_agfa .Fills =_gdgc .X ();_abce :=_gdgc .AddFill ().SetPatternFill ();_abce .SetPattern (_ba .ST_PatternTypeNone );_abce =_gdgc .AddFill ().SetPatternFill ();_abce .SetPattern (_ba .ST_PatternTypeGray125 );_agfa .Fonts =_ba .NewCT_Fonts ();_agfa .Borders =_ba .NewCT_Borders ();_fdbd :=StyleSheet {wb ,_agfa };_fdbd .AddBorder ().InitializeDefaults ();_cebc :=_fdbd .AddFont ();_cebc .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_cebc .SetSize (11);_fbge :=_ba .NewCT_Xf ();*_fbge =*_cadg ;_fbge .XfIdAttr =_g .Uint32 (0);_agfa .CellXfs .Xf =append (_agfa .CellXfs .Xf ,_fbge );_agfa .CellXfs .CountAttr =_g .Uint32 (uint32 (len (_agfa .CellXfs .Xf )));return _fdbd ;};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_ddfc Sheet )RangeReference (n string )string {_agdg :=_d .Split (n ,"\u003a");_agdgg ,_ :=_dg .ParseCellReference (_agdg [0]);_fefa :=_ade .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_agdgg .Column ,_agdgg .RowIdx );if len (_agdg )==1{return _ade .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_ddfc .Name (),_fefa );};_cacd ,_ :=_dg .ParseCellReference (_agdg [1]);_gfgc :=_ade .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_cacd .Column ,_cacd .RowIdx );return _ade .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_ddfc .Name (),_fefa ,_gfgc );};func (_fdec StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_bbdd :=range _fdec ._gfde .NumFmts .NumFmt {if _bbdd .NumFmtIdAttr ==id {return NumberFormat {_fdec ._aced ,_bbdd };};};return NumberFormat {};};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_gaa Cell )SetRichTextString ()RichText {_gaa .clearValue ();_gaa ._eeg .Is =_ba .NewCT_Rst ();_gaa ._eeg .TAttr =_ba .ST_CellTypeInlineStr ;return RichText {_gaa ._eeg .Is };};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_ggg *Workbook )Uses1904Dates ()bool {if _ggg ._badbd .WorkbookPr ==nil ||_ggg ._badbd .WorkbookPr .Date1904Attr ==nil {return false ;};return *_ggg ._badbd .WorkbookPr .Date1904Attr ;};

// Wrapped returns true if the cell will wrap text.
func (_eca CellStyle )Wrapped ()bool {if _eca ._daa .Alignment ==nil {return false ;};if _eca ._daa .Alignment .WrapTextAttr ==nil {return false ;};return *_eca ._daa .Alignment .WrapTextAttr ;};

// DefinedNames returns a slice of all defined names in the workbook.
func (_dfbbc *Workbook )DefinedNames ()[]DefinedName {if _dfbbc ._badbd .DefinedNames ==nil {return nil ;};_eeca :=[]DefinedName {};for _ ,_fgdf :=range _dfbbc ._badbd .DefinedNames .DefinedName {_eeca =append (_eeca ,DefinedName {_fgdf });};return _eeca ;};

// AddRun adds a new run of text to the cell.
func (_adfe RichText )AddRun ()RichTextRun {_ggea :=_ba .NewCT_RElt ();_adfe ._aef .R =append (_adfe ._aef .R ,_ggea );return RichTextRun {_ggea };};

// Sheet is a single sheet within a workbook.
type Sheet struct{_ebee *Workbook ;_ggeg *_ba .CT_Sheet ;_edeb *_ba .Worksheet ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_bcgec Row )RowNumber ()uint32 {if _bcgec ._agbf .RAttr !=nil {return *_bcgec ._agbf .RAttr ;};return 0;};

// SetFill applies a fill to a cell style.  The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_fab CellStyle )SetFill (f Fill ){_fab ._daa .FillIdAttr =_g .Uint32 (f .Index ());_fab ._daa .ApplyFillAttr =_g .Bool (true );};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_cab *Sheet )AddRow ()Row {_aadd :=uint32 (0);_bcd :=uint32 (len (_cab ._edeb .SheetData .Row ));if _bcd > 0&&_cab ._edeb .SheetData .Row [_bcd -1].RAttr !=nil &&*_cab ._edeb .SheetData .Row [_bcd -1].RAttr ==_bcd {return _cab .addNumberedRowFast (_bcd +1);};for _ ,_cgad :=range _cab ._edeb .SheetData .Row {if _cgad .RAttr !=nil &&*_cgad .RAttr > _aadd {_aadd =*_cgad .RAttr ;};};return _cab .AddNumberedRow (_aadd +1);};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_bdbf *Sheet )FormulaContext ()_cgd .Context {return _daee (_bdbf )};func (_ffd PatternFill )SetBgColor (c _gb .Color ){_ffd ._fefe .BgColor =_ba .NewCT_Color ();_ffd ._fefe .BgColor .RgbAttr =c .AsRGBAString ();};

// X returns the inner wrapped XML type.
func (_ddg CellMarker )X ()*_ea .CT_Marker {return _ddg ._ccb };

// SetText sets the text to be displayed.
func (_cdae RichTextRun )SetText (s string ){_cdae ._fgfg .T =s };

// InitializeDefaults initializes a border to its defaulte empty values.
func (_ab Border )InitializeDefaults (){_ab ._cba .Left =_ba .NewCT_BorderPr ();_ab ._cba .Bottom =_ba .NewCT_BorderPr ();_ab ._cba .Right =_ba .NewCT_BorderPr ();_ab ._cba .Top =_ba .NewCT_BorderPr ();_ab ._cba .Diagonal =_ba .NewCT_BorderPr ();};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_befg Comment )SetAuthor (author string ){_befg ._fdd .AuthorIdAttr =Comments {_befg ._gcbe ,_befg ._aaf }.getOrCreateAuthor (author );};type SheetProtection struct{_baca *_ba .CT_SheetProtection };func (_daeb CellStyle )SetNumberFormat (s string ){_ffe :=_daeb ._fga .StyleSheet .AddNumberFormat ();_ffe .SetFormat (s );_daeb ._daa .ApplyNumberFormatAttr =_g .Bool (true );_daeb ._daa .NumFmtIdAttr =_g .Uint32 (_ffe .ID ());};

// Cell returns the actual cell behind the merged region
func (_fgeg MergedCell )Cell ()Cell {_fdefe :=_fgeg .Reference ();if _ffb :=_d .Index (_fgeg .Reference (),"\u003a");_ffb !=-1{_fdefe =_fdefe [0:_ffb ];return _fgeg ._ffg .Cell (_fdefe );};return Cell {};};

// X returns the inner wrapped XML type.
func (_edc Comments )X ()*_ba .Comments {return _edc ._caa };

// BottomRight is a no-op.
func (_dd AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};func (_eaed StyleSheet )GetCellStyle (id uint32 )CellStyle {for _abbc ,_bceg :=range _eaed ._gfde .CellXfs .Xf {if uint32 (_abbc )==id {return CellStyle {_eaed ._aced ,_bceg ,_eaed ._gfde .CellXfs };};};return CellStyle {};};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_aef *_ba .CT_Rst };func (_afed *Sheet )slideCellsLeft (_aeaae []*_ba .CT_Cell )[]*_ba .CT_Cell {for _ ,_fbba :=range _aeaae {_ggead ,_dfefd :=_dg .ParseCellReference (*_fbba .RAttr );if _dfefd !=nil {return _aeaae ;};_fcbc :=_ggead .ColumnIdx -1;_gead :=_dg .IndexToColumn (_fcbc )+_ade .Sprintf ("\u0025\u0064",_ggead .RowIdx );_fbba .RAttr =&_gead ;};return _aeaae ;};

// MaxColumnIdx returns the max used column of the sheet.
func (_dbed Sheet )MaxColumnIdx ()uint32 {_fbdeg :=uint32 (0);for _ ,_afeb :=range _dbed .Rows (){_cgcce :=_afeb ._agbf .C ;if len (_cgcce )> 0{_aaed :=_cgcce [len (_cgcce )-1];_dgee ,_ :=_dg .ParseCellReference (*_aaed .RAttr );if _fbdeg < _dgee .ColumnIdx {_fbdeg =_dgee .ColumnIdx ;};};};return _fbdeg ;};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_fgbg TwoCellAnchor )SetWidthCells (w int32 ){_aedc :=_fgbg .TopLeft ();_bbbc :=_fgbg .BottomRight ();_bbbc .SetCol (_aedc .Col ()+w );};

// SetRowOffset sets a column offset in absolute distance.
func (_egc CellMarker )SetRowOffset (m _cf .Distance ){_egc ._ccb .RowOff .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_cf .EMU ));};func (_fbcg *Sheet )updateAfterRemove (_acea uint32 ,_gcfd _cfa .UpdateAction )error {_bbae :=_fbcg .Name ();_gdf :=&_cfa .UpdateQuery {UpdateType :_gcfd ,ColumnIdx :_acea ,SheetToUpdate :_bbae };for _ ,_dgba :=range _fbcg ._ebee .Sheets (){_gdf .UpdateCurrentSheet =_bbae ==_dgba .Name ();for _ ,_bbcd :=range _dgba .Rows (){for _ ,_fdeg :=range _bbcd .Cells (){if _fdeg .X ().F !=nil {_dgge :=_fdeg .X ().F .Content ;_efdef :=_cgd .ParseString (_dgge );if _efdef ==nil {_fdeg .SetError ("\u0023\u0052\u0045F\u0021");}else {_ffga :=_efdef .Update (_gdf );_fdeg .X ().F .Content =_ade .Sprintf ("\u003d\u0025\u0073",_ffga .String ());};};};};};return nil ;};func (_deeb SheetView )ensurePane (){if _deeb ._adgd .Pane ==nil {_deeb ._adgd .Pane =_ba .NewCT_Pane ();_deeb ._adgd .Pane .ActivePaneAttr =_ba .ST_PaneBottomLeft ;};};

// PasswordHash returns the hash of the workbook password.
func (_ebgab WorkbookProtection )PasswordHash ()string {if _ebgab ._aba .WorkbookPasswordAttr ==nil {return "";};return *_ebgab ._aba .WorkbookPasswordAttr ;};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_ead DataValidationList )SetValues (values []string ){_ead ._dddf .Formula1 =_g .String ("\u0022"+_d .Join (values ,"\u002c")+"\u0022");_ead ._dddf .Formula2 =_g .String ("\u0030");};

// SetMaxLength sets the maximum bar length in percent.
func (_agb DataBarScale )SetMaxLength (l uint32 ){_agb ._abb .MaxLengthAttr =_g .Uint32 (l )};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_bdbcc StyleSheet )AddNumberFormat ()NumberFormat {if _bdbcc ._gfde .NumFmts ==nil {_bdbcc ._gfde .NumFmts =_ba .NewCT_NumFmts ();};_cgadg :=_ba .NewCT_NumFmt ();_cgadg .NumFmtIdAttr =uint32 (200+len (_bdbcc ._gfde .NumFmts .NumFmt ));_bdbcc ._gfde .NumFmts .NumFmt =append (_bdbcc ._gfde .NumFmts .NumFmt ,_cgadg );_bdbcc ._gfde .NumFmts .CountAttr =_g .Uint32 (uint32 (len (_bdbcc ._gfde .NumFmts .NumFmt )));return NumberFormat {_bdbcc ._aced ,_cgadg };};func (_gae Font )SetItalic (b bool ){if b {_gae ._gcc .I =[]*_ba .CT_BooleanProperty {{}};}else {_gae ._gcc .I =nil ;};};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_deb *_ea .CT_AbsoluteAnchor };

// SetXSplit sets the column split point
func (_eafd SheetView )SetXSplit (v float64 ){_eafd .ensurePane ();_eafd ._adgd .Pane .XSplitAttr =_g .Float64 (v );};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_egg Comment )CellReference ()string {return _egg ._fdd .RefAttr };

// SetYSplit sets the row split point
func (_acbc SheetView )SetYSplit (v float64 ){_acbc .ensurePane ();_acbc ._adgd .Pane .YSplitAttr =_g .Float64 (v );};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_abde *Workbook )Epoch ()_ag .Time {if _abde .Uses1904Dates (){_ag .Date (1904,1,1,0,0,0,0,_ag .UTC );};return _ag .Date (1899,12,30,0,0,0,0,_ag .UTC );};func (_dcg Fills )X ()*_ba .CT_Fills {return _dcg ._caabg };

// SetShowRuler controls the visibility of the ruler
func (_bbgd SheetView )SetShowRuler (b bool ){if !b {_bbgd ._adgd .ShowRulerAttr =_g .Bool (false );}else {_bbgd ._adgd .ShowRulerAttr =nil ;};};

// MoveTo moves the top-left of the anchored object.
func (_fbde OneCellAnchor )MoveTo (col ,row int32 ){_fbde .TopLeft ().SetCol (col );_fbde .TopLeft ().SetRow (row );};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_caac Comments )AddComment (cellRef string ,author string )RichText {_ebeb :=_ba .NewCT_Comment ();_caac ._caa .CommentList .Comment =append (_caac ._caa .CommentList .Comment ,_ebeb );_ebeb .RefAttr =cellRef ;_ebeb .AuthorIdAttr =_caac .getOrCreateAuthor (author );_ebeb .Text =_ba .NewCT_Rst ();return RichText {_ebeb .Text };};func (_eege DifferentialStyle )Fill ()Fill {if _eege ._geff .Fill ==nil {_eege ._geff .Fill =_ba .NewCT_Fill ();};return Fill {_eege ._geff .Fill ,nil };};func (_age Comments )getOrCreateAuthor (_egfe string )uint32 {for _ebc ,_cgf :=range _age ._caa .Authors .Author {if _cgf ==_egfe {return uint32 (_ebc );};};_dda :=uint32 (len (_age ._caa .Authors .Author ));_age ._caa .Authors .Author =append (_age ._caa .Authors .Author ,_egfe );return _dda ;};