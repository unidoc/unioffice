//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_ag "archive/zip";_fc "bytes";_fb "errors";_c "fmt";_f "github.com/unidoc/unioffice/v2";_bg "github.com/unidoc/unioffice/v2/chart";_cea "github.com/unidoc/unioffice/v2/color";_fa "github.com/unidoc/unioffice/v2/common";_cf "github.com/unidoc/unioffice/v2/common/logger";
_ce "github.com/unidoc/unioffice/v2/common/tempstorage";_db "github.com/unidoc/unioffice/v2/internal/formatutils";_e "github.com/unidoc/unioffice/v2/internal/license";_ae "github.com/unidoc/unioffice/v2/measurement";_cg "github.com/unidoc/unioffice/v2/schema/soo/dml";
_dc "github.com/unidoc/unioffice/v2/schema/soo/dml/chart";_fgf "github.com/unidoc/unioffice/v2/schema/soo/dml/spreadsheetDrawing";_ge "github.com/unidoc/unioffice/v2/schema/soo/pkg/relationships";_fge "github.com/unidoc/unioffice/v2/schema/soo/sml";_fff "github.com/unidoc/unioffice/v2/spreadsheet/format";
_bac "github.com/unidoc/unioffice/v2/spreadsheet/formula";_gb "github.com/unidoc/unioffice/v2/spreadsheet/reference";_be "github.com/unidoc/unioffice/v2/spreadsheet/update";_ea "github.com/unidoc/unioffice/v2/vmldrawing";_dg "github.com/unidoc/unioffice/v2/zippkg";
_b "image";_ab "image/jpeg";_ad "io";_gdf "math";_ba "math/big";_abd "os";_ff "path";_g "path/filepath";_bb "reflect";_df "regexp";_aa "sort";_fg "strconv";_d "strings";_gd "time";);

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_ggaf *Sheet )AddHyperlink (url string )_fa .Hyperlink {for _ecea ,_bcac :=range _ggaf ._fgca ._egabd {if _bcac ==_ggaf ._defb {return _ggaf ._fgca ._bbea [_ecea ].AddHyperlink (url );};};return _fa .Hyperlink {};};func (_afdec Fill )Index ()uint32 {if _afdec ._eeg ==nil {return 0;
};for _fab ,_cgcg :=range _afdec ._eeg .Fill {if _afdec ._afcd ==_cgcg {return uint32 (_fab );};};return 0;};

// GetValueAsNumber retrieves the cell's value as a number
func (_dbf Cell )GetValueAsNumber ()(float64 ,error ){if _dbf ._dced .V ==nil &&_dbf ._dced .Is ==nil {return 0,nil ;};if _dbf ._dced .TAttr ==_fge .ST_CellTypeS ||!_fff .IsNumber (*_dbf ._dced .V ){return _gdf .NaN (),_fb .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");
};return _fg .ParseFloat (*_dbf ._dced .V ,64);};

// SetHidden marks the defined name as hidden.
func (_bgd DefinedName )SetHidden (b bool ){_bgd ._cgaa .HiddenAttr =_f .Bool (b )};

// X returns the inner wrapped XML type.
func (_cdbfc SheetProtection )X ()*_fge .CT_SheetProtection {return _cdbfc ._bbaf };

// SetWidth sets the width of the anchored object.
func (_gba AbsoluteAnchor )SetWidth (w _ae .Distance ){_gba ._fcc .Ext .CxAttr =int64 (w /_ae .EMU )};func (_aac Cell )getFormat ()string {if _aac ._dced .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_cgd :=*_aac ._dced .SAttr ;_bc :=_aac ._ef .StyleSheet .GetCellStyle (_cgd );
_adgf :=_aac ._ef .StyleSheet .GetNumberFormat (_bc .NumberFormat ());return _adgf .GetFormat ();};

// PasswordHash returns the hash of the workbook password.
func (_abae WorkbookProtection )PasswordHash ()string {if _abae ._edcb .WorkbookPasswordAttr ==nil {return "";};return *_abae ._edcb .WorkbookPasswordAttr ;};

// X returns the inner wrapped XML type.
func (_ffc Border )X ()*_fge .CT_Border {return _ffc ._ed };

// IsNumber returns true if the cell is a number type cell.
func (_fe Cell )IsNumber ()bool {switch _fe ._dced .TAttr {case _fge .ST_CellTypeN :return true ;case _fge .ST_CellTypeS ,_fge .ST_CellTypeB :return false ;};return _fe ._dced .V !=nil &&_fff .IsNumber (*_fe ._dced .V );};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_dceg NumberFormat )ID ()uint32 {return _dceg ._gage .NumFmtIdAttr };

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_beda *Workbook )RemoveSheetByName (name string )error {_ebef :=-1;for _afcb ,_cfbaf :=range _beda .Sheets (){if name ==_cfbaf .Name (){_ebef =_afcb ;break ;};};if _ebef ==-1{return ErrorNotFound ;};return _beda .RemoveSheet (_ebef );};func _gbcd (_ffef string ,_efbf uint32 ,_fdedc bool )string {_acba ,_abdfc ,_cggf :=_gb .ParseRangeReference (_ffef );
if _cggf ==nil {_aacc ,_cddc :=_acba .ColumnIdx ,_abdfc .ColumnIdx ;if _efbf >=_aacc &&_efbf <=_cddc {if _aacc ==_cddc {if _fdedc {return "";}else {return _ffef ;};}else {_gceg :=_abdfc .Update (_be .UpdateActionRemoveColumn );return _c .Sprintf ("\u0025\u0073\u003a%\u0073",_acba .String (),_gceg .String ());
};}else if _efbf < _aacc {_cfff :=_acba .Update (_be .UpdateActionRemoveColumn );_ffaa :=_abdfc .Update (_be .UpdateActionRemoveColumn );return _c .Sprintf ("\u0025\u0073\u003a%\u0073",_cfff .String (),_ffaa .String ());};}else {_eaff ,_dbeb ,_fabfe :=_gb .ParseColumnRangeReference (_ffef );
if _fabfe !=nil {return "";};_abff ,_dfadb :=_eaff .ColumnIdx ,_dbeb .ColumnIdx ;if _efbf >=_abff &&_efbf <=_dfadb {if _abff ==_dfadb {if _fdedc {return "";}else {return _ffef ;};}else {_eged :=_dbeb .Update (_be .UpdateActionRemoveColumn );return _c .Sprintf ("\u0025\u0073\u003a%\u0073",_eaff .String (),_eged .String ());
};}else if _efbf < _abff {_ecgg :=_eaff .Update (_be .UpdateActionRemoveColumn );_edcgd :=_dbeb .Update (_be .UpdateActionRemoveColumn );return _c .Sprintf ("\u0025\u0073\u003a%\u0073",_ecgg .String (),_edcgd .String ());};};return "";};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_afe Comparer )LessCells (lhs ,rhs Cell )bool {if _afe .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_dffc ,_cbb :=lhs .getRawSortValue ();
_ecdf ,_affc :=rhs .getRawSortValue ();switch {case _cbb &&_affc :_efcd ,_ :=_fg .ParseFloat (_dffc ,64);_ggf ,_ :=_fg .ParseFloat (_ecdf ,64);return _efcd < _ggf ;case _cbb :return true ;case _affc :return false ;};_dffc =lhs .GetFormattedValue ();_ecdf =rhs .GetFormattedValue ();
return _dffc < _ecdf ;};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_cdegg *Workbook )SetActiveSheet (s Sheet ){for _ebad ,_cegfe :=range _cdegg ._egabd {if s ._defb ==_cegfe {_cdegg .SetActiveSheetIndex (uint32 (_ebad ));};};};

// GetValueAsBool retrieves the cell's value as a boolean
func (_edc Cell )GetValueAsBool ()(bool ,error ){if _edc ._dced .TAttr !=_fge .ST_CellTypeB {return false ,_fb .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");
};if _edc ._dced .V ==nil {return false ,_fb .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _fg .ParseBool (*_edc ._dced .V );};

// SheetCount returns the number of sheets in the workbook.
func (_feag Workbook )SheetCount ()int {return len (_feag ._egabd )};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_eed Cell )SetFormulaArray (s string ){_dcc :=_bac .ParseString (s );if _dcc ==nil {return ;};_eed .clearValue ();_eed ._dced .TAttr =_fge .ST_CellTypeStr ;_eed ._dced .F =_fge .NewCT_CellFormula ();_eed ._dced .F .TAttr =_fge .ST_CellFormulaTypeArray ;
_eed ._dced .F .Content =s ;};

// X returns the inner wrapped XML type.
func (_fbgfc NumberFormat )X ()*_fge .CT_NumFmt {return _fbgfc ._gage };

// IsEmpty returns true if the cell is empty.
func (_adc Cell )IsEmpty ()bool {return _adc ._dced .TAttr ==_fge .ST_CellTypeUnset &&_adc ._dced .V ==nil &&_adc ._dced .F ==nil ;};

// X returns the inner wrapped XML type.
func (_faaa Comments )X ()*_fge .Comments {return _faaa ._dfef };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_cdgd *Workbook )RecalculateFormulas (){for _ ,_cabfbc :=range _cdgd .Sheets (){_cabfbc .RecalculateFormulas ();};};

// GetWidth returns a worksheet's column width.
func (_cdbd *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_efd :=range _cdbd ._dgf .X ().Cols [0].Col {if int (_efd .MinAttr )<=colIdx &&colIdx <=int (_efd .MaxAttr ){return float64 (int (*_efd .WidthAttr ));};};return 0;};

// Content returns the content of the defined range (the range in most cases)/
func (_egec DefinedName )Content ()string {return _egec ._cgaa .Content };

// Protection controls the protection on an individual sheet.
func (_becd *Sheet )Protection ()SheetProtection {if _becd ._defb .SheetProtection ==nil {_becd ._defb .SheetProtection =_fge .NewCT_SheetProtection ();};return SheetProtection {_becd ._defb .SheetProtection };};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_fba Cell )GetString ()string {switch _fba ._dced .TAttr {case _fge .ST_CellTypeInlineStr :if _fba ._dced .Is !=nil &&_fba ._dced .Is .T !=nil {return *_fba ._dced .Is .T ;};if _fba ._dced .V !=nil {return *_fba ._dced .V ;};case _fge .ST_CellTypeS :if _fba ._dced .V ==nil {return "";
};_ecc ,_cgf :=_fg .Atoi (*_fba ._dced .V );if _cgf !=nil {return "";};_dcg ,_cgf :=_fba ._ef .SharedStrings .GetString (_ecc );if _cgf !=nil {return "";};return _dcg ;};if _fba ._dced .V ==nil {return "";};return *_fba ._dced .V ;};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_gbfe ConditionalFormattingRule )SetConditionValue (v string ){_gbfe ._gcgc .Formula =[]string {v }};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_bbd Cell )SetRichTextString ()RichText {_bbd .clearValue ();_bbd ._dced .Is =_fge .NewCT_Rst ();_bbd ._dced .TAttr =_fge .ST_CellTypeInlineStr ;return RichText {_bbd ._dced .Is };};type Table struct{_ecgbf *_fge .Table };

// AddFormatValue adds a format value to be used to determine the cell background.
func (_ggc ColorScale )AddFormatValue (t _fge .ST_CfvoType ,val string ){_cced :=_fge .NewCT_Cfvo ();_cced .TypeAttr =t ;_cced .ValAttr =_f .String (val );_ggc ._ceea .Cfvo =append (_ggc ._ceea .Cfvo ,_cced );};

// SetRowOffset sets the row offset of the top-left anchor.
func (_ebgd OneCellAnchor )SetRowOffset (m _ae .Distance ){_ebgd .TopLeft ().SetRowOffset (m )};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_gcb Drawing )AddChart (at AnchorType )(_bg .Chart ,Anchor ){_effd :=_dc .NewChartSpace ();_gcb ._dfbc ._cdbc =append (_gcb ._dfbc ._cdbc ,_effd );_dfbg :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .ChartContentType ,len (_gcb ._dfbc ._cdbc ));
_gcb ._dfbc .ContentTypes .AddOverride (_dfbg ,_f .ChartContentType );var _dcf string ;for _eaad ,_bfcg :=range _gcb ._dfbc ._beed {if _bfcg ==_gcb ._caeb {_bfac :=_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,_f .ChartType ,len (_gcb ._dfbc ._cdbc ));
_ffb :=_gcb ._dfbc ._gfgab [_eaad ].AddRelationship (_bfac ,_f .ChartType );_dcf =_ffb .ID ();break ;};};var _beaf Anchor ;var _fccd *_fgf .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_bcge :=_egeb ();_gcb ._caeb .EG_Anchor =append (_gcb ._caeb .EG_Anchor ,&_fgf .EG_Anchor {AnchorChoice :&_fgf .EG_AnchorChoice {AbsoluteAnchor :_bcge }});
_bcge .ObjectChoicesChoice =&_fgf .EG_ObjectChoicesChoice {};_bcge .ObjectChoicesChoice .GraphicFrame =_fgf .NewCT_GraphicalObjectFrame ();_fccd =_bcge .ObjectChoicesChoice .GraphicFrame ;_beaf =AbsoluteAnchor {_bcge };case AnchorTypeOneCell :_fgfa :=_gdd ();
_gcb ._caeb .EG_Anchor =append (_gcb ._caeb .EG_Anchor ,&_fgf .EG_Anchor {AnchorChoice :&_fgf .EG_AnchorChoice {OneCellAnchor :_fgfa }});_fgfa .ObjectChoicesChoice =&_fgf .EG_ObjectChoicesChoice {};_fgfa .ObjectChoicesChoice .GraphicFrame =_fgf .NewCT_GraphicalObjectFrame ();
_fccd =_fgfa .ObjectChoicesChoice .GraphicFrame ;_beaf =OneCellAnchor {_fgfa };case AnchorTypeTwoCell :_bbee :=_def ();_gcb ._caeb .EG_Anchor =append (_gcb ._caeb .EG_Anchor ,&_fgf .EG_Anchor {AnchorChoice :&_fgf .EG_AnchorChoice {TwoCellAnchor :_bbee }});
_bbee .ObjectChoicesChoice =&_fgf .EG_ObjectChoicesChoice {};_bbee .ObjectChoicesChoice .GraphicFrame =_fgf .NewCT_GraphicalObjectFrame ();_fccd =_bbee .ObjectChoicesChoice .GraphicFrame ;_beaf =TwoCellAnchor {_bbee };};_fccd .NvGraphicFramePr =_fgf .NewCT_GraphicalObjectFrameNonVisual ();
_fccd .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_gcb ._caeb .EG_Anchor ));_fccd .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_fccd .Graphic =_cg .NewGraphic ();_fccd .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";
_aeg :=_dc .NewChart ();_aeg .IdAttr =_dcf ;_fccd .Graphic .GraphicData .Any =[]_f .Any {_aeg };_caaf :=_bg .MakeChart (_effd );_caaf .Properties ().SetSolidFill (_cea .White );_caaf .SetDisplayBlanksAs (_dc .ST_DispBlanksAsGap );return _caaf ,_beaf ;};
func (_dddb *Sheet )removeColumnFromNamedRanges (_baca uint32 )error {for _ ,_ebba :=range _dddb ._fgca .DefinedNames (){_abde :=_ebba .Name ();_gcec :=_ebba .Content ();_fgaa :=_d .Split (_gcec ,"\u0021");if len (_fgaa )!=2{return _fb .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_gcec );
};_gfefg :=_fgaa [0];if _dddb .Name ()==_gfefg {_gacd :=_dddb ._fgca .RemoveDefinedName (_ebba );if _gacd !=nil {return _gacd ;};_dbca :=_gbcd (_fgaa [1],_baca ,true );if _dbca !=""{_bgea :=_gfefg +"\u0021"+_dbca ;_dddb ._fgca .AddDefinedName (_abde ,_bgea );
};};};_afeg :=0;if _dddb ._defb .TableParts !=nil &&_dddb ._defb .TableParts .TablePart !=nil {_afeg =len (_dddb ._defb .TableParts .TablePart );};if _afeg !=0{_bgfbc :=0;for _ ,_eecb :=range _dddb ._fgca .Sheets (){if _eecb .Name ()==_dddb .Name (){break ;
}else {if _eecb ._defb .TableParts !=nil &&_eecb ._defb .TableParts .TablePart !=nil {_bgfbc +=len (_eecb ._defb .TableParts .TablePart );};};};_cfga :=_dddb ._fgca ._eafaa [_bgfbc :_bgfbc +_afeg ];for _fgff ,_eade :=range _cfga {_deafa :=_eade ;_deafa .RefAttr =_gbcd (_deafa .RefAttr ,_baca ,false );
_dddb ._fgca ._eafaa [_bgfbc +_fgff ]=_deafa ;};};return nil ;};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// SetHeight sets the height of the anchored object.
func (_agag OneCellAnchor )SetHeight (h _ae .Distance ){_agag ._gfgaf .Ext .CyAttr =int64 (h /_ae .EMU )};func _gee (_bcfcd bool )int {if _bcfcd {return 1;};return 0;};

// SetAllowBlank controls if blank values are accepted.
func (_gdgb DataValidation )SetAllowBlank (b bool ){if !b {_gdgb ._ebga .AllowBlankAttr =nil ;}else {_gdgb ._ebga .AllowBlankAttr =_f .Bool (true );};};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_fgef ConditionalFormattingRule )SetIcons ()IconScale {_fgef .clear ();_fgef .SetType (_fge .ST_CfTypeIconSet );_fgef ._gcgc .IconSet =_fge .NewCT_IconSet ();_egc :=IconScale {_fgef ._gcgc .IconSet };_egc .SetIcons (_fge .ST_IconSetType3TrafficLights1 );
return _egc ;};func (_ecdd *evalContext )Cell (ref string ,ev _bac .Evaluator )_bac .Result {if !_dffg (ref ){return _bac .MakeErrorResultType (_bac .ErrorTypeName ,"");};_abdc :=_ecdd ._dgf .Name ()+"\u0021"+ref ;if _bbad ,_egg :=ev .GetFromCache (_abdc );
_egg {return _bbad ;};_bff ,_edcf :=_gb .ParseCellReference (ref );if _edcf !=nil {return _bac .MakeErrorResult (_c .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_edcf ));};if _ecdd ._gca !=0&&!_bff .AbsoluteColumn {_bff .ColumnIdx +=_ecdd ._gca ;
_bff .Column =_gb .IndexToColumn (_bff .ColumnIdx );};if _ecdd ._cdd !=0&&!_bff .AbsoluteRow {_bff .RowIdx +=_ecdd ._cdd ;};_cdc :=_ecdd ._dgf .Cell (_bff .String ());if _cdc .HasFormula (){if _ ,_fac :=_ecdd ._gdgf [ref ];_fac {return _bac .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );
};_ecdd ._gdgf [ref ]=struct{}{};_ebc :=ev .Eval (_ecdd ,_cdc .GetFormula ());delete (_ecdd ._gdgf ,ref );ev .SetCache (_abdc ,_ebc );return _ebc ;};if _cdc .IsEmpty (){_cbd :=_bac .MakeEmptyResult ();ev .SetCache (_abdc ,_cbd );return _cbd ;}else if _cdc .IsNumber (){_dde ,_ :=_cdc .GetValueAsNumber ();
_cgdc :=_bac .MakeNumberResult (_dde );ev .SetCache (_abdc ,_cgdc );return _cgdc ;}else if _cdc .IsBool (){_caac ,_ :=_cdc .GetValueAsBool ();_acae :=_bac .MakeBoolResult (_caac );ev .SetCache (_abdc ,_acae );return _acae ;};_cdbf ,_ :=_cdc .GetRawValue ();
if _cdc .IsError (){_acbf :=_bac .MakeErrorResult ("");_acbf .ValueString =_cdbf ;ev .SetCache (_abdc ,_acbf );return _acbf ;};_fdab :=_bac .MakeStringResult (_cdbf );ev .SetCache (_abdc ,_fdab );return _fdab ;};func (_beb Cell )GetRawValue ()(string ,error ){switch _beb ._dced .TAttr {case _fge .ST_CellTypeInlineStr :if _beb ._dced .Is ==nil ||_beb ._dced .Is .T ==nil {return "",nil ;
};return *_beb ._dced .Is .T ,nil ;case _fge .ST_CellTypeS :if _beb ._dced .V ==nil {return "",nil ;};_ccee ,_adgg :=_fg .Atoi (*_beb ._dced .V );if _adgg !=nil {return "",_adgg ;};return _beb ._ef .SharedStrings .GetString (_ccee );case _fge .ST_CellTypeStr :if _beb ._dced .F !=nil {return _beb ._dced .F .Content ,nil ;
};};if _beb ._dced .V ==nil {return "",nil ;};return *_beb ._dced .V ,nil ;};

// SetStyle applies a style to a cell avoiding redundancy. The function checks if the given style
// already exists in the saved styles. If found, the existing style is reused; otherwise,
// the new style is added to the saved styles collection. The style is then applied to the cell.
// This style is referenced in the generated XML via CellStyle.Index().
func (_bda Cell )SetStyle (cs CellStyle ){_dcedg :=cs ._add .Xf ;for _ ,_ebe :=range _dcedg {if _bb .DeepEqual (_ebe ,cs ._dece ){cs ._dece =_ebe ;_bda .SetStyleIndex (cs .Index ());return ;};};cs ._add .Xf =append (cs ._add .Xf ,cs ._dece );cs ._add .CountAttr =_f .Uint32 (uint32 (len (cs ._add .Xf )));
_bda .SetStyleIndex (cs .Index ());};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_ebge *_fge .Sst ;_cbdf map[string ]int ;};

// X returns the inner wrapped XML type.
func (_baee SheetView )X ()*_fge .CT_SheetView {return _baee ._gfdfg };

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_febg StyleSheet )Fills ()Fills {return Fills {_febg ._ccde .Fills }};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_aad ,_bd int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_adg _ae .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_faf int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_bdf _ae .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_eb int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_eagb _ae .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_ca _ae .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// Comment is a single comment within a sheet.
type Comment struct{_bcbf *Workbook ;_gade *_fge .CT_Comment ;_bad *_fge .Comments ;};

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_cge CellStyle )GetVerticalAlignment ()_fge .ST_VerticalAlignment {if _cge ._dece .Alignment ==nil {return _fge .ST_VerticalAlignmentUnset ;};return _cge ._dece .Alignment .VerticalAttr ;};func (_fecf StyleSheet )GetCellStyle (id uint32 )CellStyle {for _ggba ,_defe :=range _fecf ._ccde .CellXfs .Xf {if uint32 (_ggba )==id {return CellStyle {_fecf ._eafa ,_defe ,_fecf ._ccde .CellXfs };
};};return CellStyle {};};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_fbgfe *Workbook )GetFilename ()string {return _fbgfe ._deff };func (_dbg Cell )getLabelPrefix ()string {if _dbg ._dced .SAttr ==nil {return "";};_bae :=*_dbg ._dced .SAttr ;_acb :=_dbg ._ef .StyleSheet .GetCellStyle (_bae );switch _acb ._dece .Alignment .HorizontalAttr {case _fge .ST_HorizontalAlignmentLeft :return "\u0027";
case _fge .ST_HorizontalAlignmentRight :return "\u0022";case _fge .ST_HorizontalAlignmentCenter :return "\u005e";case _fge .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// AddGradientStop adds a color gradient stop.
func (_dbaa ColorScale )AddGradientStop (color _cea .Color ){_beg :=_fge .NewCT_Color ();_beg .RgbAttr =color .AsRGBAString ();_dbaa ._ceea .Color =append (_dbaa ._ceea .Color ,_beg );};func (_cged *evalContext )Sheet (name string )_bac .Context {for _ ,_fafa :=range _cged ._dgf ._fgca .Sheets (){if _fafa .Name ()==name {return _fafa .FormulaContext ();
};};return _bac .InvalidReferenceContext ;};const _dce ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_baea CellStyle )SetProtection (protected bool ,hidden bool ){_baea ._dece .Protection =&_fge .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};

// SetRowOffset sets a column offset in absolute distance.
func (_dabd CellMarker )SetRowOffset (m _ae .Distance ){_dabd ._fdd .RowOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ae .EMU ));};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_gced *evalContext )LastColumn (rowFrom ,rowTo int )string {_fafc :=_gced ._dgf ;_agdg :=1;for _dbd :=rowFrom ;_dbd <=rowTo ;_dbd ++{_dag :=len (_fafc .Row (uint32 (_dbd )).Cells ());if _dag > _agdg {_agdg =_dag ;};};return _gb .IndexToColumn (uint32 (_agdg -1));
};

// SetColor sets teh color of the databar.
func (_adcb DataBarScale )SetColor (c _cea .Color ){_adcb ._dcec .Color =_fge .NewCT_Color ();_adcb ._dcec .Color .RgbAttr =c .AsRGBAString ();};

// SetHeightAuto sets the row height to be automatically determined.
func (_gac Row )SetHeightAuto (){_gac ._feg .HtAttr =nil ;_gac ._feg .CustomHeightAttr =nil };func (_cgag Sheet )validateRowCellNumbers ()error {_bag :=map[uint32 ]struct{}{};for _ ,_cfddg :=range _cgag ._defb .SheetData .Row {if _cfddg .RAttr !=nil {if _ ,_dafc :=_bag [*_cfddg .RAttr ];
_dafc {return _c .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_cgag .Name (),*_cfddg .RAttr );};_bag [*_cfddg .RAttr ]=struct{}{};};_eagd :=map[string ]struct{}{};for _ ,_gcc :=range _cfddg .C {if _gcc .RAttr ==nil {continue ;
};if _ ,_gccf :=_eagd [*_gcc .RAttr ];_gccf {return _c .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_cgag .Name (),*_gcc .RAttr );};_eagd [*_gcc .RAttr ]=struct{}{};};};return nil ;
};

// SetPasswordHash sets the password hash to the input.
func (_beeb SheetProtection )SetPasswordHash (pwHash string ){_beeb ._bbaf .PasswordAttr =_f .String (pwHash );};

// GetLocked returns true if the cell is locked.
func (_bgfde *evalContext )GetLocked (cellRef string )bool {return _bgfde ._dgf .Cell (cellRef ).getLocked ();};

// X returns the inner wrapped XML type.
func (_dbff CellMarker )X ()*_fgf .CT_Marker {return _dbff ._fdd };

// ColOffset returns the offset from the row cell.
func (_afd CellMarker )ColOffset ()_ae .Distance {if _afd ._fdd .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ae .Distance (float64 (*_afd ._fdd .ColOff .ST_CoordinateUnqualified )*_ae .EMU );};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_gfg CellStyle )GetHorizontalAlignment ()_fge .ST_HorizontalAlignment {if _gfg ._dece .Alignment ==nil {return _fge .ST_HorizontalAlignmentUnset ;};return _gfg ._dece .Alignment .HorizontalAttr ;};

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_fda Cell )GetCachedFormulaResult ()string {if _fda ._dced .V !=nil {return *_fda ._dced .V ;};return "";};

// Tables returns a slice of all defined tables in the workbook.
func (_fcae *Workbook )Tables ()[]Table {if _fcae ._eafaa ==nil {return nil ;};_gcbf :=[]Table {};for _ ,_ggfa :=range _fcae ._eafaa {_gcbf =append (_gcbf ,Table {_ggfa });};return _gcbf ;};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_cddf *evalContext )IsDBCS ()bool {_cccc :=_cddf ._dgf ._fgca .CoreProperties .X ().Language ;if _cccc ==nil {return false ;};_degf :=string (_cccc .Data );for _ ,_cada :=range _ecfb {if _degf ==_cada {return true ;};};return false ;};

// AddCommentWithStyle adds a new comment styled in a default way
func (_acf Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_aef :=_acf .AddComment (cellRef ,author );_fcf :=_aef .AddRun ();_fcf .SetBold (true );_fcf .SetSize (10);_fcf .SetColor (_cea .Black );_fcf .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");
_fcf .SetText (author +"\u003a");_fcf =_aef .AddRun ();_fcf .SetSize (10);_fcf .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_fcf .SetColor (_cea .Black );_fcf .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_eff ,_cfaf :=_gb .ParseCellReference (cellRef );
if _cfaf !=nil {return _cfaf ;};_acf ._faff ._deea [0].Shape =append (_acf ._faff ._deea [0].Shape ,_ea .NewCommentShape (int64 (_eff .ColumnIdx ),int64 (_eff .RowIdx -1)));return nil ;};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;
StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;
StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;
StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;
StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;
StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// ClearFont clears any font configuration from the cell style.
func (_ffd CellStyle )ClearFont (){_ffd ._dece .FontIdAttr =nil ;_ffd ._dece .ApplyFontAttr =nil };func (_fd Cell )clearValue (){_fd ._dced .F =nil ;_fd ._dced .Is =nil ;_fd ._dced .V =nil ;_fd ._dced .TAttr =_fge .ST_CellTypeUnset ;};func (_cdde *Sheet )getAllCellsInFormulaArrays (_bfe bool )(map[string ]bool ,error ){_aegg :=_bac .NewEvaluator ();
_fgfbe :=_cdde .FormulaContext ();_eeef :=map[string ]bool {};for _ ,_dggca :=range _cdde .Rows (){for _ ,_ddbcf :=range _dggca .Cells (){if _ddbcf .X ().F !=nil {_dgfdb :=_ddbcf .X ().F .Content ;if _ddbcf .X ().F .TAttr ==_fge .ST_CellFormulaTypeArray {_gab :=_aegg .Eval (_fgfbe ,_dgfdb ).AsString ();
if _gab .Type ==_bac .ResultTypeError {_cf .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_dgfdb ,_gab .ErrorMessage );
_ddbcf .X ().V =nil ;};if _gab .Type ==_bac .ResultTypeArray {_eba ,_edcfe :=_gb .ParseCellReference (_ddbcf .Reference ());if _edcfe !=nil {return map[string ]bool {},_edcfe ;};if (_bfe &&len (_gab .ValueArray )==1)||(!_bfe &&len (_gab .ValueArray [0])==1){continue ;
};for _efea ,_agda :=range _gab .ValueArray {_bfafd :=_eba .RowIdx +uint32 (_efea );for _ffg :=range _agda {_aedda :=_gb .IndexToColumn (_eba .ColumnIdx +uint32 (_ffg ));_eeef [_c .Sprintf ("\u0025\u0073\u0025\u0064",_aedda ,_bfafd )]=true ;};};}else if _gab .Type ==_bac .ResultTypeList {_eege ,_ccab :=_gb .ParseCellReference (_ddbcf .Reference ());
if _ccab !=nil {return map[string ]bool {},_ccab ;};if _bfe ||len (_gab .ValueList )==1{continue ;};_bdfg :=_eege .RowIdx ;for _ggafb :=range _gab .ValueList {_gafd :=_gb .IndexToColumn (_eege .ColumnIdx +uint32 (_ggafb ));_eeef [_c .Sprintf ("\u0025\u0073\u0025\u0064",_gafd ,_bdfg )]=true ;
};};};};};};return _eeef ,nil ;};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_bcba Cell )GetValueAsTime ()(_gd .Time ,error ){if _bcba ._dced .TAttr !=_fge .ST_CellTypeUnset {return _gd .Time {},_fb .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");
};if _bcba ._dced .V ==nil {return _gd .Time {},_fb .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_aggg ,_ ,_bcbd :=_ba .ParseFloat (*_bcba ._dced .V ,10,128,_ba .ToNearestEven );if _bcbd !=nil {return _gd .Time {},_bcbd ;
};_bgae :=new (_ba .Float );_bgae .SetUint64 (uint64 (24*_gd .Hour ));_aggg .Mul (_aggg ,_bgae );_efg ,_ :=_aggg .Uint64 ();_bcff :=_bcba ._ef .Epoch ().Add (_gd .Duration (_efg ));return _edd (_bcff ),nil ;};func (_caf CellStyle )Index ()uint32 {for _geec ,_gfc :=range _caf ._add .Xf {if _caf ._dece ==_gfc {return uint32 (_geec );
};};return 0;};type Fill struct{_afcd *_fge .CT_Fill ;_eeg *_fge .CT_Fills ;};func (_ecgd PatternFill )SetBgColor (c _cea .Color ){_ecgd ._acgb .BgColor =_fge .NewCT_Color ();_ecgd ._acgb .BgColor .RgbAttr =c .AsRGBAString ();};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_fgadg *Workbook )Save (w _ad .Writer )error {const _fdbf ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_e .GetLicenseKey ().IsLicensed ()&&!_cfbf {_c .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_c .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return _fb .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_bffad :="\u0075n\u006b\u006e\u006f\u0077\u006e";if _gdec ,_bbaa :=w .(*_abd .File );
_bbaa {_bffad =_gdec .Name ();};if len (_fgadg ._fead )==0{_gfab ,_gdda :=_e .GenRefId ("\u0073\u0077");if _gdda !=nil {_cf .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdda );return _gdda ;};_fgadg ._fead =_gfab ;};if _ffeg :=_e .Track (_fgadg ._fead ,_fdbf ,_bffad );
_ffeg !=nil {_cf .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffeg );return _ffeg ;};_cace :=_ag .NewWriter (w );defer _cace .Close ();_fbfa :=_f .DocTypeSpreadsheet ;if _dbfb :=_dg .MarshalXML (_cace ,_f .BaseRelsFilename ,_fgadg .Rels .X ());
_dbfb !=nil {return _dbfb ;};if _gdgbgg :=_dg .MarshalXMLByType (_cace ,_fbfa ,_f .ExtendedPropertiesType ,_fgadg .AppProperties .X ());_gdgbgg !=nil {return _gdgbgg ;};if _bcdc :=_dg .MarshalXMLByType (_cace ,_fbfa ,_f .CorePropertiesType ,_fgadg .CoreProperties .X ());
_bcdc !=nil {return _bcdc ;};_fdfg :=_f .AbsoluteFilename (_fbfa ,_f .OfficeDocumentType ,0);if _ddca :=_dg .MarshalXML (_cace ,_fdfg ,_fgadg ._fefd );_ddca !=nil {return _ddca ;};if _bdgc :=_dg .MarshalXML (_cace ,_dg .RelationsPathFor (_fdfg ),_fgadg ._cbag .X ());
_bdgc !=nil {return _bdgc ;};if _ddfec :=_dg .MarshalXMLByType (_cace ,_fbfa ,_f .StylesType ,_fgadg .StyleSheet .X ());_ddfec !=nil {return _ddfec ;};for _ffeb ,_fege :=range _fgadg ._edgb {if _fdcc :=_dg .MarshalXMLByTypeIndex (_cace ,_fbfa ,_f .ThemeType ,_ffeb +1,_fege );
_fdcc !=nil {return _fdcc ;};};for _dabdf ,_dafd :=range _fgadg ._egabd {_dafd .Dimension .RefAttr =Sheet {_fgadg ,nil ,_dafd }.Extents ();_gcbb :=_f .AbsoluteFilename (_fbfa ,_f .WorksheetType ,_dabdf +1);_dg .MarshalXML (_cace ,_gcbb ,_dafd );_dg .MarshalXML (_cace ,_dg .RelationsPathFor (_gcbb ),_fgadg ._bbea [_dabdf ].X ());
};if _dacc :=_dg .MarshalXMLByType (_cace ,_fbfa ,_f .SharedStringsType ,_fgadg .SharedStrings .X ());_dacc !=nil {return _dacc ;};if _fgadg .CustomProperties .X ()!=nil {if _ebab :=_dg .MarshalXMLByType (_cace ,_fbfa ,_f .CustomPropertiesType ,_fgadg .CustomProperties .X ());
_ebab !=nil {return _ebab ;};};if _fgadg .Thumbnail !=nil {_cbfd :=_f .AbsoluteFilename (_fbfa ,_f .ThumbnailType ,0);_afdef ,_bfafe :=_cace .Create (_cbfd );if _bfafe !=nil {return _bfafe ;};if _bcab :=_ab .Encode (_afdef ,_fgadg .Thumbnail ,nil );_bcab !=nil {return _bcab ;
};};for _ffgf ,_afg :=range _fgadg ._cdbc {_dfeee :=_f .AbsoluteFilename (_fbfa ,_f .ChartType ,_ffgf +1);_dg .MarshalXML (_cace ,_dfeee ,_afg );};for _edgd ,_fedb :=range _fgadg ._eafaa {_aba :=_f .AbsoluteFilename (_fbfa ,_f .TableType ,_edgd +1);_dg .MarshalXML (_cace ,_aba ,_fedb );
};for _acfc ,_adefc :=range _fgadg ._beed {_fafeb :=_f .AbsoluteFilename (_fbfa ,_f .DrawingType ,_acfc +1);_dg .MarshalXML (_cace ,_fafeb ,_adefc );if !_fgadg ._gfgab [_acfc ].IsEmpty (){_dg .MarshalXML (_cace ,_dg .RelationsPathFor (_fafeb ),_fgadg ._gfgab [_acfc ].X ());
};};for _bgbgb ,_abef :=range _fgadg ._deea {_dg .MarshalXML (_cace ,_f .AbsoluteFilename (_fbfa ,_f .VMLDrawingType ,_bgbgb +1),_abef );};for _gfeeb ,_gdcgf :=range _fgadg .Images {if _egecd :=_fa .AddImageToZip (_cace ,_gdcgf ,_gfeeb +1,_f .DocTypeSpreadsheet );
_egecd !=nil {return _egecd ;};};if _aaeb :=_dg .MarshalXML (_cace ,_f .ContentTypesFilename ,_fgadg .ContentTypes .X ());_aaeb !=nil {return _aaeb ;};for _dfac ,_efab :=range _fgadg ._aacf {if _efab ==nil {continue ;};_dg .MarshalXML (_cace ,_f .AbsoluteFilename (_fbfa ,_f .CommentsType ,_dfac +1),_efab );
};if _egac :=_fgadg .WriteExtraFiles (_cace );_egac !=nil {return _egac ;};return _cace .Close ();};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_cdb Cell )SetCachedFormulaResult (s string ){_cdb ._dced .V =&s };func (_bdfa DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_bdfa .clear ();_bdfa ._ebga .TypeAttr =_fge .ST_DataValidationType (t );_bdfa ._ebga .OperatorAttr =_fge .ST_DataValidationOperator (op );
return DataValidationCompare {_bdfa ._ebga };};type WorkbookProtection struct{_edcb *_fge .CT_WorkbookProtection };

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_ebfd Row )AddNamedCell (col string )Cell {_dfad :=_fge .NewCT_Cell ();_dfad .RAttr =_f .Stringf ("\u0025\u0073\u0025\u0064",col ,_ebfd .RowNumber ());_gec :=-1;_afa :=_gb .ColumnToIndex (col );for _dada ,_bfg :=range _ebfd ._feg .C {_bbga ,_dgfd :=_gb .ParseCellReference (*_bfg .RAttr );
if _dgfd !=nil {return Cell {};};if _afa < _bbga .ColumnIdx {_gec =_dada ;break ;};};if _gec ==-1{_ebfd ._feg .C =append (_ebfd ._feg .C ,_dfad );}else {_ebfd ._feg .C =append (_ebfd ._feg .C [:_gec ],append ([]*_fge .CT_Cell {_dfad },_ebfd ._feg .C [_gec :]...)...);
};return Cell {_ebfd ._dbe ,_ebfd ._gfac ,_ebfd ._feg ,_dfad };};type evalContext struct{_dgf *Sheet ;_gca ,_cdd uint32 ;_gdgf map[string ]struct{};};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_dga Cell )SetBool (v bool ){_dga .clearValue ();_dga ._dced .V =_f .String (_fg .Itoa (_gee (v )));_dga ._dced .TAttr =_fge .ST_CellTypeB ;};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_bgba *_fge .CT_Col };

// ClearNumberFormat removes any number formatting from the style.
func (_bdc CellStyle )ClearNumberFormat (){_bdc ._dece .NumFmtIdAttr =nil ;_bdc ._dece .ApplyNumberFormatAttr =nil ;};

// ClearProtection removes any protections applied to teh sheet.
func (_egcf *Sheet )ClearProtection (){_egcf ._defb .SheetProtection =nil };

// SetFill applies a fill to a cell style avoiding redundancy. The function checks if the given fill
// already exists in the saved fills. If found, the existing fill is reused; otherwise,
// the new fill is added to the saved fills collection. The fill is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gdbc CellStyle )SetFill (f Fill ){_bfa :=f ._eeg .Fill ;for _ ,_fgc :=range _bfa {if _bb .DeepEqual (_fgc ,f ._afcd ){f ._afcd =_fgc ;_gdbc ._dece .FillIdAttr =_f .Uint32 (f .Index ());_gdbc ._dece .ApplyFillAttr =_f .Bool (true );return ;};};f ._eeg .Fill =append (f ._eeg .Fill ,f ._afcd );
f ._eeg .CountAttr =_f .Uint32 (uint32 (len (f ._eeg .Fill )));_gdbc ._dece .FillIdAttr =_f .Uint32 (f .Index ());_gdbc ._dece .ApplyFillAttr =_f .Bool (true );};

// Row is a row within a spreadsheet.
type Row struct{_dbe *Workbook ;_gfac *Sheet ;_feg *_fge .CT_Row ;};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_fa .DocBase ;_fefd *_fge .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_aacf []*_fge .Comments ;_egabd []*_fge .Worksheet ;_bbea []_fa .Relationships ;_cbag _fa .Relationships ;_edgb []*_cg .Theme ;_beed []*_fgf .WsDr ;
_gfgab []_fa .Relationships ;_deea []*_ea .Container ;_cdbc []*_dc .ChartSpace ;_eafaa []*_fge .Table ;_deff string ;_caafe map[string ]string ;_gcae map[string ]*_dc .ChartSpace ;_fead string ;};func (_bec Font )SetItalic (b bool ){_dddca :=false ;for _gdff ,_fgad :=range _bec ._caed .FontChoice {if _fgad .I !=nil {if b {_bec ._caed .FontChoice [_gdff ].I =&_fge .CT_BooleanProperty {};
}else {_bec ._caed .FontChoice [_gdff ].I =nil ;};_dddca =true ;};};if !_dddca {_bec ._caed .FontChoice =append (_bec ._caed .FontChoice ,&_fge .CT_FontChoice {I :&_fge .CT_BooleanProperty {}});};};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_cgbgd *Sheet )ClearSheetViews (){_cgbgd ._defb .SheetViews =nil };func (_gadc *Sheet )slideCellsLeft (_eca []*_fge .CT_Cell )[]*_fge .CT_Cell {for _ ,_becdc :=range _eca {_cagc ,_fgadf :=_gb .ParseCellReference (*_becdc .RAttr );if _fgadf !=nil {return _eca ;
};_fggg :=_cagc .ColumnIdx -1;_gbdaf :=_gb .IndexToColumn (_fggg )+_c .Sprintf ("\u0025\u0064",_cagc .RowIdx );_becdc .RAttr =&_gbdaf ;};return _eca ;};type DifferentialStyle struct{_ceag *_fge .CT_Dxf ;_adgec *Workbook ;_eefe *_fge .CT_Dxfs ;};

// Name returns the name of the defined name.
func (_dcca DefinedName )Name ()string {return _dcca ._cgaa .NameAttr };

// DefinedNames returns a slice of all defined names in the workbook.
func (_fgcb *Workbook )DefinedNames ()[]DefinedName {if _fgcb ._fefd .DefinedNames ==nil {return nil ;};_gefeb :=[]DefinedName {};for _ ,_ggdd :=range _fgcb ._fefd .DefinedNames .DefinedName {_gefeb =append (_gefeb ,DefinedName {_ggdd });};return _gefeb ;
};

// Cell is a single cell within a sheet.
type Cell struct{_ef *Workbook ;_eg *Sheet ;_ega *_fge .CT_Row ;_dced *_fge .CT_Cell ;};

// StyleSheet is a document style sheet.
type StyleSheet struct{_eafa *Workbook ;_ccde *_fge .StyleSheet ;};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_fbe Cell )SetDate (d _gd .Time ){_fbe .clearValue ();d =_gdg (d );_ddg :=_fbe ._ef .Epoch ();if d .Before (_ddg ){_cf .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_faa :=d .Sub (_ddg );_gg :=new (_ba .Float );_gaef :=new (_ba .Float );_gaef .SetPrec (128);_gaef .SetUint64 (uint64 (_faa ));_gag :=new (_ba .Float );_gag .SetUint64 (24*60*60*1e9);_gg .Quo (_gaef ,_gag );_bcfa ,_ :=_gg .Uint64 ();_fbe ._dced .V =_f .Stringf ("\u0025\u0064",_bcfa );
};func (_ee Border )SetTop (style _fge .ST_BorderStyle ,c _cea .Color ){if _ee ._ed .Top ==nil {_ee ._ed .Top =_fge .NewCT_BorderPr ();};_ee ._ed .Top .Color =_fge .NewCT_Color ();_ee ._ed .Top .Color .RgbAttr =c .AsRGBAString ();_ee ._ed .Top .StyleAttr =style ;
};

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_dfbc *Workbook ;_caeb *_fgf .WsDr ;};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_acag IconScale )AddFormatValue (t _fge .ST_CfvoType ,val string ){_aeca :=_fge .NewCT_Cfvo ();_aeca .TypeAttr =t ;_aeca .ValAttr =_f .String (val );_acag ._gbffb .Cfvo =append (_acag ._gbffb .Cfvo ,_aeca );};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// TopLeft returns the top-left corner of the anchored object.
func (_deaa OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_deaa ._gfgaf .From }};

// CellStyles returns the list of defined cell styles
func (_egbd StyleSheet )CellStyles ()[]CellStyle {_aedbf :=[]CellStyle {};for _ ,_dcfg :=range _egbd ._ccde .CellXfs .Xf {_aedbf =append (_aedbf ,CellStyle {_egbd ._eafa ,_dcfg ,_egbd ._ccde .CellXfs });};return _aedbf ;};func (_ebb Row )renumberAs (_gfcc uint32 ){_ebb ._feg .RAttr =_f .Uint32 (_gfcc );
for _ ,_bgbg :=range _ebb .Cells (){_cadc ,_gbb :=_gb .ParseCellReference (_bgbg .Reference ());if _gbb ==nil {_feb :=_c .Sprintf ("\u0025\u0073\u0025\u0064",_cadc .Column ,_gfcc );_bgbg ._dced .RAttr =_f .String (_feb );};};};func (_fef DataValidation )clear (){_fef ._ebga .Formula1 =_f .String ("\u0030");
_fef ._ebga .Formula2 =_f .String ("\u0030");};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_aeea *Sheet )SheetViews ()[]SheetView {if _aeea ._defb .SheetViews ==nil {return nil ;};_dege :=[]SheetView {};for _ ,_bbeeg :=range _aeea ._defb .SheetViews .SheetView {_dege =append (_dege ,SheetView {_bbeeg });};return _dege ;};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_adefd *Workbook )GetChartByTargetId (targetAttr string )*_dc .ChartSpace {return _adefd ._gcae [targetAttr ];};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_ggda SheetView )SetState (st _fge .ST_PaneState ){_ggda .ensurePane ();_ggda ._gfdfg .Pane .StateAttr =st ;};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_daa CellStyle )HasNumberFormat ()bool {return _daa ._dece .NumFmtIdAttr !=nil &&_daa ._dece .ApplyNumberFormatAttr !=nil &&*_daa ._dece .ApplyNumberFormatAttr ;};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_cc AbsoluteAnchor )SetColOffset (m _ae .Distance ){_cc ._fcc .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ae .EMU ));};

// SetHidden marks the defined name as hidden.
func (_fgee DefinedName )SetLocalSheetID (id uint32 ){_fgee ._cgaa .LocalSheetIdAttr =_f .Uint32 (id )};

// SetLocked sets cell locked or not.
func (_ecf *evalContext )SetLocked (cellRef string ,locked bool ){_ecf ._dgf .Cell (cellRef ).setLocked (locked );};func (_aee Border )SetLeft (style _fge .ST_BorderStyle ,c _cea .Color ){if _aee ._ed .Left ==nil {_aee ._ed .Left =_fge .NewCT_BorderPr ();
};_aee ._ed .Left .Color =_fge .NewCT_Color ();_aee ._ed .Left .Color .RgbAttr =c .AsRGBAString ();_aee ._ed .Left .StyleAttr =style ;};

// Author returns the author of the comment
func (_gge Comment )Author ()string {if _gge ._gade .AuthorIdAttr < uint32 (len (_gge ._bad .Authors .Author )){return _gge ._bad .Authors .Author [_gge ._gade .AuthorIdAttr ];};return "";};

// MaxColumnIdx returns the max used column of the sheet.
func (_bced Sheet )MaxColumnIdx ()uint32 {_aedb :=uint32 (0);for _ ,_fbab :=range _bced .Rows (){_bdee :=_fbab ._feg .C ;if len (_bdee )> 0{_ebcf :=_bdee [len (_bdee )-1];_fcec ,_ :=_gb .ParseCellReference (*_ebcf .RAttr );if _aedb < _fcec .ColumnIdx {_aedb =_fcec .ColumnIdx ;
};};};return _aedb ;};func (_ceacd Font )SetName (name string ){_cgdg :=false ;for _ead ,_cgec :=range _ceacd ._caed .FontChoice {if _cgec .Name !=nil {_ceacd ._caed .FontChoice [_ead ].Name =&_fge .CT_FontName {ValAttr :name };_cgdg =true ;};};if !_cgdg {_ceacd ._caed .FontChoice =append (_ceacd ._caed .FontChoice ,&_fge .CT_FontChoice {Name :&_fge .CT_FontName {ValAttr :name }});
};};var ErrorNotFound =_fb .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// GetString retrieves a string from the shared strings table by index.
func (_fgec SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_c .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );
};if id > len (_fgec ._ebge .Si )-1{return "",_c .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_fgec ._ebge .Si ));
};_cde :=_fgec ._ebge .Si [id ];if _cde .T !=nil {return *_cde .T ,nil ;};_gfde :="";for _ ,_befe :=range _cde .R {if _befe .T !=""{_gfde +=_befe .T ;};};return _gfde ,nil ;};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};func (_fccbd Sheet )validateSheetNames ()error {_degc :=len ([]rune (_fccbd .Name ()));if _degc > 31{return _c .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_fccbd .Name (),_degc );
};return nil ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_baf OneCellAnchor )SetColOffset (m _ae .Distance ){_baf .TopLeft ().SetColOffset (m )};func (_edfc Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _eacc ,_effe ,_efca ,_adcd uint32 =1,1,0,0;for _ ,_debg :=range _edfc .Rows (){if _debg .RowNumber ()< _eacc {_eacc =_debg .RowNumber ();
}else if _debg .RowNumber ()> _effe {_effe =_debg .RowNumber ();};for _ ,_decgc :=range _debg .Cells (){_dgba ,_ffaf :=_gb .ParseCellReference (_decgc .Reference ());if _ffaf ==nil {if _dgba .ColumnIdx < _efca {_efca =_dgba .ColumnIdx ;}else if _dgba .ColumnIdx > _adcd {_adcd =_dgba .ColumnIdx ;
};};};};return _gb .IndexToColumn (_efca ),_eacc ,_gb .IndexToColumn (_adcd ),_effe ;};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_cef Cell )SetTime (d _gd .Time ){_cef .clearValue ();d =_gdg (d );_agd :=_cef ._ef .Epoch ();if d .Before (_agd ){_cf .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_bab :=d .Sub (_agd );_efc :=new (_ba .Float );_aggb :=new (_ba .Float );_aggb .SetPrec (128);_aggb .SetUint64 (uint64 (_bab ));_aadb :=new (_ba .Float );_aadb .SetUint64 (24*60*60*1e9);_efc .Quo (_aggb ,_aadb );_cef ._dced .V =_f .String (_efc .Text ('g',20));
};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_bffbc TwoCellAnchor )SetWidthCells (w int32 ){_bcbb :=_bffbc .TopLeft ();_eaga :=_bffbc .BottomRight ();_eaga .SetCol (_bcbb .Col ()+w );};

// Sheet is a single sheet within a workbook.
type Sheet struct{_fgca *Workbook ;_bgfdd *_fge .CT_Sheet ;_defb *_fge .Worksheet ;};

// Borders returns the list of borders defined in the stylesheet.
func (_baff StyleSheet )Borders ()[]Border {_ccdb :=[]Border {};for _ ,_aefb :=range _baff ._ccde .Borders .Border {_ccdb =append (_ccdb ,Border {_ed :_aefb });};return _ccdb ;};

// RowOffset returns the offset from the row cell.
func (_bgfd CellMarker )RowOffset ()_ae .Distance {if _bgfd ._fdd .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ae .Distance (float64 (*_bgfd ._fdd .RowOff .ST_CoordinateUnqualified )*_ae .EMU );};

// Column returns the cell column
func (_dca Cell )Column ()(string ,error ){_cfa ,_aff :=_gb .ParseCellReference (_dca .Reference ());if _aff !=nil {return "",_aff ;};return _cfa .Column ,nil ;};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_ddfa Sheet )Extents ()string {_bdbca ,_cddad ,_cgaga ,_fddeb :=_ddfa .ExtentsIndex ();return _c .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_bdbca ,_cddad ,_cgaga ,_fddeb );};

// AddRule adds and returns a new rule that can be configured.
func (_dfb ConditionalFormatting )AddRule ()ConditionalFormattingRule {_cdba :=_fge .NewCT_CfRule ();_dfb ._addb .CfRule =append (_dfb ._addb .CfRule ,_cdba );_ecg :=ConditionalFormattingRule {_cdba };_ecg .InitializeDefaults ();_ecg .SetPriority (int32 (len (_dfb ._addb .CfRule )+1));
return _ecg ;};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_dgaa DataValidationList )SetRange (cellRange string ){_dgaa ._cddg .Formula1 =_f .String (cellRange );_dgaa ._cddg .Formula2 =_f .String ("\u0030");};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_geg Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _gaee ,_afc Cell ;for _ ,_aae :=range lhs .Cells (){_abg ,_ :=_gb .ParseCellReference (_aae .Reference ());if _abg .Column ==column {_gaee =_aae ;break ;};};for _ ,_eeca :=range rhs .Cells (){_dedf ,_ :=_gb .ParseCellReference (_eeca .Reference ());
if _dedf .Column ==column {_afc =_eeca ;break ;};};return _geg .LessCells (_gaee ,_afc );};

// SetWidthCells is a no-op.
func (_dbgce OneCellAnchor )SetWidthCells (int32 ){};

// SetYSplit sets the row split point
func (_bbagf SheetView )SetYSplit (v float64 ){_bbagf .ensurePane ();_bbagf ._gfdfg .Pane .YSplitAttr =_f .Float64 (v );};

// LockObject controls the locking of the sheet objects.
func (_ddbf SheetProtection )LockObject (b bool ){if !b {_ddbf ._bbaf .ObjectsAttr =nil ;}else {_ddbf ._bbaf .ObjectsAttr =_f .Bool (true );};};

// X returns the inner XML entity for a stylesheet.
func (_cccf StyleSheet )X ()*_fge .StyleSheet {return _cccf ._ccde };

// SetStyle sets the cell style for an entire column.
func (_gbcg Column )SetStyle (cs CellStyle ){_gbcg ._bgba .StyleAttr =_f .Uint32 (cs .Index ())};

// Clear clears the cell's value and type.
func (_geb Cell )Clear (){_geb .clearValue ();_geb ._dced .TAttr =_fge .ST_CellTypeUnset };

// SetPattern sets the pattern of the fill.
func (_abdd PatternFill )SetPattern (p _fge .ST_PatternType ){_abdd ._acgb .PatternTypeAttr =p };

// AddHyperlink creates and sets a hyperlink on a cell.
func (_cb Cell )AddHyperlink (url string ){for _dfaa ,_bcfc :=range _cb ._ef ._egabd {if _bcfc ==_cb ._eg ._defb {_cb .SetHyperlink (_cb ._ef ._bbea [_dfaa ].AddHyperlink (url ));return ;};};};

// X returns the inner wrapped XML type.
func (_aaca ColorScale )X ()*_fge .CT_ColorScale {return _aaca ._ceea };func _edd (_dec _gd .Time )_gd .Time {_dec =_dec .UTC ();return _gd .Date (_dec .Year (),_dec .Month (),_dec .Day (),_dec .Hour (),_dec .Minute (),_dec .Second (),_dec .Nanosecond (),_gd .Local );
};

// SetHyperlink sets a hyperlink on a cell.
func (_baba Cell )SetHyperlink (hl _fa .Hyperlink ){_fffa :=_baba ._eg ._defb ;if _fffa .Hyperlinks ==nil {_fffa .Hyperlinks =_fge .NewCT_Hyperlinks ();};_ggb :=_fa .Relationship (hl );_ecd :=_fge .NewCT_Hyperlink ();_ecd .RefAttr =_baba .Reference ();
_ecd .IdAttr =_f .String (_ggb .ID ());_fffa .Hyperlinks .Hyperlink =append (_fffa .Hyperlinks .Hyperlink ,_ecd );};

// SetSize sets the text size for a rich text run.
func (_geda RichTextRun )SetSize (m _ae .Distance ){_geda .ensureRpr ();_dae :=float64 (m /_ae .Point );for _ ,_ffcb :=range _geda ._gbe .RPr .RPrEltChoice {if _ffcb .Sz !=nil {_ffcb .Sz .ValAttr =_dae ;return ;};};_geda ._gbe .RPr .RPrEltChoice =append (_geda ._gbe .RPr .RPrEltChoice ,&_fge .CT_RPrEltChoice {Sz :&_fge .CT_FontSize {ValAttr :_dae }});
};

// GetFormat sets the number format code.
func (_gebg NumberFormat )GetFormat ()string {return _gebg ._gage .FormatCodeAttr };func (_edaa *Sheet )setArray (_aegb string ,_bdad _bac .Result )error {_daeb ,_fbccc :=_gb .ParseCellReference (_aegb );if _fbccc !=nil {return _fbccc ;};for _affef ,_eaed :=range _bdad .ValueArray {_befd :=_edaa .Row (_daeb .RowIdx +uint32 (_affef ));
for _caadf ,_aade :=range _eaed {_ggg :=_befd .Cell (_gb .IndexToColumn (_daeb .ColumnIdx +uint32 (_caadf )));if _aade .Type !=_bac .ResultTypeEmpty {if _aade .IsBoolean {_ggg .SetBool (_aade .ValueNumber !=0);}else {_ggg .SetCachedFormulaResult (_aade .String ());
};};};};return nil ;};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_adcf DataValidation )SetRange (cellRange string ){_adcf ._ebga .SqrefAttr =_fge .ST_Sqref {cellRange };};

// SetHeight sets the row height in points.
func (_fgabb Row )SetHeight (d _ae .Distance ){_fgabb ._feg .HtAttr =_f .Float64 (float64 (d ));_fgabb ._feg .CustomHeightAttr =_f .Bool (true );};func (_daff *Sheet )setList (_eccd string ,_fbfgg _bac .Result )error {_aged ,_acagf :=_gb .ParseCellReference (_eccd );
if _acagf !=nil {return _acagf ;};_cgce :=_daff .Row (_aged .RowIdx );for _afdb ,_fdag :=range _fbfgg .ValueList {_cdfg :=_cgce .Cell (_gb .IndexToColumn (_aged .ColumnIdx +uint32 (_afdb )));if _fdag .Type !=_bac .ResultTypeEmpty {if _fdag .IsBoolean {_cdfg .SetBool (_fdag .ValueNumber !=0);
}else {_cdfg .SetCachedFormulaResult (_fdag .String ());};};};return nil ;};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_gfdfg *_fge .CT_SheetView };func (_aabc SortOrder )String ()string {if _aabc >=SortOrder (len (_fedd )-1){return _c .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_aabc );};return _gageb [_fedd [_aabc ]:_fedd [_aabc +1]];
};

// SetWidth is a no-op.
func (_egfg TwoCellAnchor )SetWidth (w _ae .Distance ){};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_fag *Workbook )Close ()error {if _fag .TmpPath !=""{return _ce .RemoveAll (_fag .TmpPath );};return nil ;};

// X returns the inner wrapped XML type.
func (_afef *Workbook )X ()*_fge .Workbook {return _afef ._fefd };

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_cfce Row )Cells ()[]Cell {_dfaae :=[]Cell {};_cfgd :=-1;_ced :=append ([]*_fge .CT_Cell {},_cfce ._feg .C ...);for _ ,_cfab :=range _ced {if _cfab .RAttr ==nil {_cf .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_fbfga ,_aecg :=_gb .ParseCellReference (*_cfab .RAttr );if _aecg !=nil {_cf .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_cfab .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_adfa :=int (_fbfga .ColumnIdx );if _adfa -_cfgd > 1{for _gaab :=_cfgd +1;_gaab < _adfa ;_gaab ++{_dfaae =append (_dfaae ,_cfce .Cell (_gb .IndexToColumn (uint32 (_gaab ))));};};_cfgd =_adfa ;_dfaae =append (_dfaae ,Cell {_cfce ._dbe ,_cfce ._gfac ,_cfce ._feg ,_cfab });
};return _dfaae ;};

// SetStyle sets the style to be used for conditional rules
func (_gbff ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_gbff ._gcgc .DxfIdAttr =_f .Uint32 (d .Index ());};

// X returns the inner wrapped XML type.
func (_cegf Drawing )X ()*_fgf .WsDr {return _cegf ._caeb };

// Workbook returns sheet's parent workbook.
func (_edbe *Sheet )Workbook ()*Workbook {return _edbe ._fgca };

// SetMaxLength sets the maximum bar length in percent.
func (_cbf DataBarScale )SetMaxLength (l uint32 ){_cbf ._dcec .MaxLengthAttr =_f .Uint32 (l )};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_defbc *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_cec :=_defbc ._defb .SheetData .Row ;_eebe :=_defbc .Rows ();for _deac ,_ddbc :=range _eebe {if _ddbc .RowNumber ()==firstRow {_cec =_defbc ._defb .SheetData .Row [_deac :];break ;
};};_agfc :=Comparer {Order :order };_aa .Slice (_cec ,func (_ebbe ,_dgdg int )bool {return _agfc .LessRows (column ,Row {_defbc ._fgca ,_defbc ,_cec [_ebbe ]},Row {_defbc ._fgca ,_defbc ,_cec [_dgdg ]});});for _eeeg ,_dcd :=range _defbc .Rows (){_gfdb :=uint32 (_eeeg +1);
if _dcd .RowNumber ()!=_gfdb {_dcd .renumberAs (_gfdb );};};};

// SetRotation configures the cell to be rotated.
func (_abf CellStyle )SetRotation (deg uint8 ){if _abf ._dece .Alignment ==nil {_abf ._dece .Alignment =_fge .NewCT_CellAlignment ();};_abf ._dece .ApplyAlignmentAttr =_f .Bool (true );_abf ._dece .Alignment .TextRotationAttr =_f .Uint8 (deg );};

// GetBorder gets a Border from a cell style.
func (_gfd CellStyle )GetBorder ()*_fge .CT_Border {if _edb :=_gfd ._dece .BorderIdAttr ;_edb !=nil {_fad :=_gfd ._decg .StyleSheet .Borders ();if int (*_edb )< len (_fad ){return _fad [int (*_edb )].X ();};};return nil ;};func (_fgea RichTextRun )ensureRpr (){if _fgea ._gbe .RPr ==nil {_fgea ._gbe .RPr =_fge .NewCT_RPrElt ();
};if _fgea ._gbe .RPr .RPrEltChoice ==nil {_fgea ._gbe .RPr .RPrEltChoice =[]*_fge .CT_RPrEltChoice {};};};func (_ggbf Sheet )validateMergedCells ()error {_addg :=map[uint64 ]struct{}{};for _ ,_gcdb :=range _ggbf .MergedCells (){_bedd ,_edae ,_caee :=_gb .ParseRangeReference (_gcdb .Reference ());
if _caee !=nil {return _c .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_ggbf .Name (),_gcdb .Reference ());
};for _gageg :=_bedd .RowIdx ;_gageg <=_edae .RowIdx ;_gageg ++{for _fdbd :=_bedd .ColumnIdx ;_fdbd <=_edae .ColumnIdx ;_fdbd ++{_ggbb :=uint64 (_gageg )<<32|uint64 (_fdbd );if _ ,_afaf :=_addg [_ggbb ];_afaf {return _c .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_ggbf .Name ());
};_addg [_ggbb ]=struct{}{};};};};return nil ;};

// SetName sets the sheet name.
func (_fafcb *Sheet )SetName (name string ){_fafcb ._bgfdd .NameAttr =name };var _fedd =[...]uint8 {0,18,37};

// Wrapped returns true if the cell will wrap text.
func (_aadc CellStyle )Wrapped ()bool {if _aadc ._dece .Alignment ==nil {return false ;};if _aadc ._dece .Alignment .WrapTextAttr ==nil {return false ;};return *_aadc ._dece .Alignment .WrapTextAttr ;};

// ClearBorder clears any border configuration from the cell style.
func (_dcac CellStyle )ClearBorder (){_dcac ._dece .BorderIdAttr =nil ;_dcac ._dece .ApplyBorderAttr =nil ;};

// Border is a cell border configuraton.
type Border struct{_ed *_fge .CT_Border ;_cfb *_fge .CT_Borders ;};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_ddf *Sheet )AddNumberedRow (rowNum uint32 )Row {_gbeb :=_fge .NewCT_Row ();_gbeb .RAttr =_f .Uint32 (rowNum );_ddf ._defb .SheetData .Row =append (_ddf ._defb .SheetData .Row ,_gbeb );_aa .Slice (_ddf ._defb .SheetData .Row ,func (_bdbc ,_eccg int )bool {_gefe :=_ddf ._defb .SheetData .Row [_bdbc ].RAttr ;
_ceeg :=_ddf ._defb .SheetData .Row [_eccg ].RAttr ;if _gefe ==nil {return true ;};if _ceeg ==nil {return true ;};return *_gefe < *_ceeg ;});return Row {_ddf ._fgca ,_ddf ,_gbeb };};func (_gadg Comments )getOrCreateAuthor (_bbdf string )uint32 {for _baa ,_dbaac :=range _gadg ._dfef .Authors .Author {if _dbaac ==_bbdf {return uint32 (_baa );
};};_eea :=uint32 (len (_gadg ._dfef .Authors .Author ));_gadg ._dfef .Authors .Author =append (_gadg ._dfef .Authors .Author ,_bbdf );return _eea ;};

// LockSheet controls the locking of the sheet.
func (_aace SheetProtection )LockSheet (b bool ){if !b {_aace ._bbaf .SheetAttr =nil ;}else {_aace ._bbaf .SheetAttr =_f .Bool (true );};};func (_ffce StyleSheet )appendBorder ()Border {_bdgedd :=_fge .NewCT_Border ();_ffce ._ccde .Borders .Border =append (_ffce ._ccde .Borders .Border ,_bdgedd );
_ffce ._ccde .Borders .CountAttr =_f .Uint32 (uint32 (len (_ffce ._ccde .Borders .Border )));return Border {_bdgedd ,_ffce ._ccde .Borders };};

// Comments returns the comments for a sheet.
func (_gdgbg *Sheet )Comments ()Comments {for _bbdfd ,_bfaf :=range _gdgbg ._fgca ._egabd {if _bfaf ==_gdgbg ._defb {if _gdgbg ._fgca ._aacf [_bbdfd ]==nil {_gdgbg ._fgca ._aacf [_bbdfd ]=_fge .NewComments ();_gdgbg ._fgca ._bbea [_bbdfd ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_bbdfd +1,_f .CommentsType );
_gdgbg ._fgca .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .CommentsType ,_bbdfd +1),_f .CommentsContentType );};if len (_gdgbg ._fgca ._deea )==0{_gdgbg ._fgca ._deea =append (_gdgbg ._fgca ._deea ,_ea .NewCommentDrawing ());
_bggf :=_gdgbg ._fgca ._bbea [_bbdfd ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,1,_f .VMLDrawingType );if _gdgbg ._defb .LegacyDrawing ==nil {_gdgbg ._defb .LegacyDrawing =_fge .NewCT_LegacyDrawing ();};_gdgbg ._defb .LegacyDrawing .IdAttr =_bggf .ID ();
};return Comments {_gdgbg ._fgca ,_gdgbg ._fgca ._aacf [_bbdfd ]};};};_cf .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");
return Comments {};};

// IsWindowLocked returns whether the workbook windows are locked.
func (_fbec WorkbookProtection )IsWindowLocked ()bool {return _fbec ._edcb .LockWindowsAttr !=nil &&*_fbec ._edcb .LockWindowsAttr ;};

// Protection allows control over the workbook protections.
func (_adfc *Workbook )Protection ()WorkbookProtection {if _adfc ._fefd .WorkbookProtection ==nil {_adfc ._fefd .WorkbookProtection =_fge .NewCT_WorkbookProtection ();};return WorkbookProtection {_adfc ._fefd .WorkbookProtection };};

// Index returns the index of the border for use with a cell style.
func (_bbe Border )Index ()uint32 {for _bga ,_eaf :=range _bbe ._cfb .Border {if _eaf ==_bbe ._ed {return uint32 (_bga );};};return 0;};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_decg *Workbook ;_dece *_fge .CT_Xf ;_add *_fge .CT_CellXfs ;};

// SetHeightCells is a no-op.
func (_bdce OneCellAnchor )SetHeightCells (int32 ){};

// X returns the inner wrapped XML type.
func (_cgb DefinedName )X ()*_fge .CT_DefinedName {return _cgb ._cgaa };var _gggb =_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0);

// IsError returns true if the cell is an error type cell.
func (_ccc Cell )IsError ()bool {return _ccc ._dced .TAttr ==_fge .ST_CellTypeE };

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_ccb *_fge .CT_DataValidation };

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_af AbsoluteAnchor )SetRowOffset (m _ae .Distance ){_af ._fcc .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ae .EMU ));};

// MoveTo moves the top-left of the anchored object.
func (_begb OneCellAnchor )MoveTo (col ,row int32 ){_begb .TopLeft ().SetCol (col );_begb .TopLeft ().SetRow (row );};

// SetItalic causes the text to be displayed in italic.
func (_afea RichTextRun )SetItalic (b bool ){_afea .ensureRpr ();for _ ,_gbca :=range _afea ._gbe .RPr .RPrEltChoice {if _gbca .I !=nil {_gbca .I .ValAttr =_f .Bool (b );return ;};};_afea ._gbe .RPr .RPrEltChoice =append (_afea ._gbe .RPr .RPrEltChoice ,&_fge .CT_RPrEltChoice {I :&_fge .CT_BooleanProperty {ValAttr :_f .Bool (b )}});
};func (_da Border )SetDiagonal (style _fge .ST_BorderStyle ,c _cea .Color ,up ,down bool ){if _da ._ed .Diagonal ==nil {_da ._ed .Diagonal =_fge .NewCT_BorderPr ();};_da ._ed .Diagonal .Color =_fge .NewCT_Color ();_da ._ed .Diagonal .Color .RgbAttr =c .AsRGBAString ();
_da ._ed .Diagonal .StyleAttr =style ;if up {_da ._ed .DiagonalUpAttr =_f .Bool (true );};if down {_da ._ed .DiagonalDownAttr =_f .Bool (true );};};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_eec Cell )SetStyleIndex (idx uint32 ){_eec ._dced .SAttr =_f .Uint32 (idx )};

// Comments is the container for comments for a single sheet.
type Comments struct{_faff *Workbook ;_dfef *_fge .Comments ;};

// TopLeft is a no-op.
func (_dfa AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};func (_dfec PatternFill )ClearFgColor (){_dfec ._acgb .FgColor =nil };

// GetFormula returns the formula for a cell.
func (_bdgf Cell )GetFormula ()string {if _bdgf ._dced .F !=nil {return _bdgf ._dced .F .Content ;};return "";};

// IsEmpty checks if the cell style contains nothing.
func (_bea CellStyle )IsEmpty ()bool {return _bea ._decg ==nil ||_bea ._dece ==nil ||_bea ._add ==nil ||_bea ._add .Xf ==nil ;};

// X returns the inner wrapped XML type.
func (_debd Row )X ()*_fge .CT_Row {return _debd ._feg };

// Type returns the type of anchor
func (_agf AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_cebc :=_fge .NewStyleSheet ();_cebc .CellStyleXfs =_fge .NewCT_CellStyleXfs ();_cebc .CellXfs =_fge .NewCT_CellXfs ();_cebc .CellStyles =_fge .NewCT_CellStyles ();_dfga :=_fge .NewCT_CellStyle ();_dfga .NameAttr =_f .String ("\u004e\u006f\u0072\u006d\u0061\u006c");
_dfga .XfIdAttr =0;_dfga .BuiltinIdAttr =_f .Uint32 (0);_cebc .CellStyles .CellStyle =append (_cebc .CellStyles .CellStyle ,_dfga );_cebc .CellStyles .CountAttr =_f .Uint32 (uint32 (len (_cebc .CellStyles .CellStyle )));_ddggb :=_fge .NewCT_Xf ();_ddggb .NumFmtIdAttr =_f .Uint32 (0);
_ddggb .FontIdAttr =_f .Uint32 (0);_ddggb .FillIdAttr =_f .Uint32 (0);_ddggb .BorderIdAttr =_f .Uint32 (0);_cebc .CellStyleXfs .Xf =append (_cebc .CellStyleXfs .Xf ,_ddggb );_cebc .CellStyleXfs .CountAttr =_f .Uint32 (uint32 (len (_cebc .CellStyleXfs .Xf )));
_ggfe :=NewFills ();_cebc .Fills =_ggfe .X ();_bgac :=_ggfe .appendFill ().SetPatternFill ();_bgac .SetPattern (_fge .ST_PatternTypeNone );_bgac =_ggfe .appendFill ().SetPatternFill ();_bgac .SetPattern (_fge .ST_PatternTypeGray125 );_cebc .Fonts =_fge .NewCT_Fonts ();
_cebc .Borders =_fge .NewCT_Borders ();_ebgfg :=StyleSheet {wb ,_cebc };_ebgfg .appendBorder ().InitializeDefaults ();_ebgg :=_ebgfg .appendFont ();_ebgg .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_ebgg .SetSize (11);_fbae :=_fge .NewCT_Xf ();*_fbae =*_ddggb ;
_fbae .XfIdAttr =_f .Uint32 (0);_cebc .CellXfs .Xf =append (_cebc .CellXfs .Xf ,_fbae );_cebc .CellXfs .CountAttr =_f .Uint32 (uint32 (len (_cebc .CellXfs .Xf )));return _ebgfg ;};

// SetRowOffset sets the row offset of the two cell anchor
func (_ebcc TwoCellAnchor )SetRowOffset (m _ae .Distance ){_gffc :=m -_ebcc .TopLeft ().RowOffset ();_ebcc .TopLeft ().SetRowOffset (m );_ebcc .BottomRight ().SetRowOffset (_ebcc .BottomRight ().RowOffset ()+_gffc );};type PatternFill struct{_acgb *_fge .CT_PatternFill ;
_gffe *_fge .CT_Fill ;};

// X returns the inner wrapped XML type.
func (_gfaa Table )X ()*_fge .Table {return _gfaa ._ecgbf };

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_bdg Cell )SetStringByID (id int ){_bdg ._ef .ensureSharedStringsRelationships ();_bdg .clearValue ();_bdg ._dced .V =_f .String (_fg .Itoa (id ));_bdg ._dced .TAttr =_fge .ST_CellTypeS ;};

// X returns the inner wrapped XML type.
func (_gbaf Sheet )X ()*_fge .Worksheet {return _gbaf ._defb };func (_ggabe *Sheet )removeColumnFromMergedCells (_eabd uint32 )error {if _ggabe ._defb .MergeCells ==nil ||_ggabe ._defb .MergeCells .MergeCell ==nil {return nil ;};_gedcd :=[]*_fge .CT_MergeCell {};
for _ ,_dfbb :=range _ggabe .MergedCells (){_debfd :=_gbcd (_dfbb .Reference (),_eabd ,true );if _debfd !=""{_dfbb .SetReference (_debfd );_gedcd =append (_gedcd ,_dfbb .X ());};};_ggabe ._defb .MergeCells .MergeCell =_gedcd ;return nil ;};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_fddg CellStyle )SetNumberFormatStandard (s StandardFormat ){_fddg ._dece .NumFmtIdAttr =_f .Uint32 (uint32 (s ));_fddg ._dece .ApplyNumberFormatAttr =_f .Bool (true );};

// PasswordHash returns the hash of the workbook password.
func (_aabe SheetProtection )PasswordHash ()string {if _aabe ._bbaf .PasswordAttr ==nil {return "";};return *_aabe ._bbaf .PasswordAttr ;};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_cce Cell )GetFormattedValue ()string {_bcc :=_cce .getFormat ();switch _cce ._dced .TAttr {case _fge .ST_CellTypeB :_gdb ,_ :=_cce .GetValueAsBool ();if _gdb {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _fge .ST_CellTypeN :_gaa ,_ :=_cce .GetValueAsNumber ();
return _fff .Number (_gaa ,_bcc );case _fge .ST_CellTypeE :if _cce ._dced .V !=nil {return *_cce ._dced .V ;};return "";case _fge .ST_CellTypeS ,_fge .ST_CellTypeInlineStr :return _fff .String (_cce .GetString (),_bcc );case _fge .ST_CellTypeStr :_bcb :=_cce .GetString ();
if _fff .IsNumber (_bcb ){_dea ,_ :=_fg .ParseFloat (_bcb ,64);return _fff .Number (_dea ,_bcc );};return _fff .String (_bcb ,_bcc );case _fge .ST_CellTypeUnset :fallthrough;default:_aag ,_ :=_cce .GetRawValue ();if len (_aag )==0{return "";};_fdb ,_dac :=_cce .GetValueAsNumber ();
if _dac ==nil {return _fff .Number (_fdb ,_bcc );};return _fff .String (_aag ,_bcc );};};

// StandardFormat is a standard ECMA 376 number format.
//
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_deef TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_deef ._efed .From }};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_fcef *Sheet )FormulaContext ()_bac .Context {return _bbfe (_fcef )};

// GetFormat returns a cell data format.
func (_dddc *evalContext )GetFormat (cellRef string )string {return _dddc ._dgf .Cell (cellRef ).getFormat ();};

// X returns the inner wrapped XML type.
func (_eaa Column )X ()*_fge .CT_Col {return _eaa ._bgba };

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// SetHeight is a nop-op.
func (_eadb TwoCellAnchor )SetHeight (h _ae .Distance ){};

// GetFill gets a Fill from a cell style.
func (_age CellStyle )GetFill ()*_fge .CT_Fill {if _eeddb :=_age ._dece .FillIdAttr ;_eeddb !=nil {_gad :=_age ._decg .StyleSheet .Fills ().X ().Fill ;if int (*_eeddb )< len (_gad ){return _gad [int (*_eeddb )];};};return nil ;};

// SetHidden controls the visibility of a column.
func (_dfde Column )SetHidden (b bool ){if !b {_dfde ._bgba .HiddenAttr =nil ;}else {_dfde ._bgba .HiddenAttr =_f .Bool (true );};};

// X returns the inner wrapped XML type.
func (_ggfd IconScale )X ()*_fge .CT_IconSet {return _ggfd ._gbffb };

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// IsStructureLocked returns whether the workbook structure is locked.
func (_ceff WorkbookProtection )IsStructureLocked ()bool {return _ceff ._edcb .LockStructureAttr !=nil &&*_ceff ._edcb .LockStructureAttr ;};

// IconScale maps values to icons.
type IconScale struct{_gbffb *_fge .CT_IconSet };type Fills struct{_dbgaf *_fge .CT_Fills };

// X returns the inner wrapped XML type.
func (_fdgee SharedStrings )X ()*_fge .Sst {return _fdgee ._ebge };

// Name returns the sheet name
func (_gdgd Sheet )Name ()string {return _gdgd ._bgfdd .NameAttr };var _fbad *_df .Regexp =_df .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// AddDataValidation adds a data validation rule to a sheet.
func (_dee *Sheet )AddDataValidation ()DataValidation {if _dee ._defb .DataValidations ==nil {_dee ._defb .DataValidations =_fge .NewCT_DataValidations ();};_fdfd :=_fge .NewCT_DataValidation ();_fdfd .ShowErrorMessageAttr =_f .Bool (true );_dee ._defb .DataValidations .DataValidation =append (_dee ._defb .DataValidations .DataValidation ,_fdfd );
_dee ._defb .DataValidations .CountAttr =_f .Uint32 (uint32 (len (_dee ._defb .DataValidations .DataValidation )));return DataValidation {_fdfd };};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_fcgc *Workbook )RemoveCalcChain (){var _fefdb string ;for _ ,_cafg :=range _fcgc ._cbag .Relationships (){if _cafg .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_fefdb ="\u0078\u006c\u002f"+_cafg .Target ();
_fcgc ._cbag .Remove (_cafg );break ;};};if _fefdb ==""{return ;};_fcgc .ContentTypes .RemoveOverride (_fefdb );for _ggafd ,_abfg :=range _fcgc .ExtraFiles {if _abfg .ZipPath ==_fefdb {_fcgc .ExtraFiles [_ggafd ]=_fcgc .ExtraFiles [len (_fcgc .ExtraFiles )-1];
_fcgc .ExtraFiles =_fcgc .ExtraFiles [:len (_fcgc .ExtraFiles )-1];return ;};};};

// SetHeightCells is a no-op.
func (_dgg AbsoluteAnchor )SetHeightCells (int32 ){};

// SetUnderline controls if the run is underlined.
func (_gaeea RichTextRun )SetUnderline (u _fge .ST_UnderlineValues ){_gaeea .ensureRpr ();for _ ,_fdef :=range _gaeea ._gbe .RPr .RPrEltChoice {if _fdef .U !=nil {_fdef .U .ValAttr =u ;return ;};};_gaeea ._gbe .RPr .RPrEltChoice =append (_gaeea ._gbe .RPr .RPrEltChoice ,&_fge .CT_RPrEltChoice {U :&_fge .CT_UnderlineProperty {ValAttr :u }});
};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_cddg *_fge .CT_DataValidation };

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_cede Sheet )Validate ()error {_gedg :=[]func ()error {_cede .validateRowCellNumbers ,_cede .validateMergedCells ,_cede .validateSheetNames };for _ ,_ebee :=range _gedg {if _aefe :=_ebee ();_aefe !=nil {return _aefe ;};};if _dggc :=_cede ._defb .Validate ();
_dggc !=nil {return _dggc ;};return _cede ._defb .Validate ();};func (_aeggc StyleSheet )appendFont ()Font {_bdab :=_fge .NewCT_Font ();_aeggc ._ccde .Fonts .Font =append (_aeggc ._ccde .Fonts .Font ,_bdab );_aeggc ._ccde .Fonts .CountAttr =_f .Uint32 (uint32 (len (_aeggc ._ccde .Fonts .Font )));
return Font {_bdab ,_aeggc ._ccde };};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_ffad *Sheet )RemoveColumn (column string )error {_dbfga ,_edbb :=_ffad .getAllCellsInFormulaArraysForColumn ();if _edbb !=nil {return _edbb ;};_eeba :=_gb .ColumnToIndex (column );for _ ,_caeg :=range _ffad .Rows (){_fbcdf :=_c .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_caeg .X ().RAttr );
if _ ,_cade :=_dbfga [_fbcdf ];_cade {return nil ;};};for _ ,_cedd :=range _ffad .Rows (){_cgcf :=_cedd ._feg .C ;for _adgeb ,_gfbeb :=range _cgcf {_bfag ,_cgedg :=_gb .ParseCellReference (*_gfbeb .RAttr );if _cgedg !=nil {return _cgedg ;};if _bfag .ColumnIdx ==_eeba {_cedd ._feg .C =append (_cgcf [:_adgeb ],_ffad .slideCellsLeft (_cgcf [_adgeb +1:])...);
break ;}else if _bfag .ColumnIdx > _eeba {_cedd ._feg .C =append (_cgcf [:_adgeb ],_ffad .slideCellsLeft (_cgcf [_adgeb :])...);break ;};};};_edbb =_ffad .updateAfterRemove (_eeba ,_be .UpdateActionRemoveColumn );if _edbb !=nil {return _edbb ;};_edbb =_ffad .removeColumnFromNamedRanges (_eeba );
if _edbb !=nil {return _edbb ;};_edbb =_ffad .removeColumnFromMergedCells (_eeba );if _edbb !=nil {return _edbb ;};for _ ,_gbba :=range _ffad ._fgca .Sheets (){_gbba .RecalculateFormulas ();};return nil ;};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_fgadc *Workbook )AddImage (i _fa .Image )(_fa .ImageRef ,error ){_deadf :=_fa .MakeImageRef (i ,&_fgadc .DocBase ,_fgadc ._cbag );if i .Data ==nil &&i .Path ==""{return _deadf ,_fb .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");
};if i .Format ==""{return _deadf ,_fb .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _deadf ,_fb .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");
};if i .Path !=""{_eaea :=_ce .Add (i .Path );if _eaea !=nil {return _deadf ,_eaea ;};};_fgadc .Images =append (_fgadc .Images ,_deadf );return _deadf ,nil ;};

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_dfe Cell )Reference ()string {if _dfe ._dced .RAttr !=nil {return *_dfe ._dced .RAttr ;};return "";};func (_ged Font )SetSize (size float64 ){_bffa :=false ;for _fffd ,_bgaf :=range _ged ._caed .FontChoice {if _bgaf .Sz !=nil {_ged ._caed .FontChoice [_fffd ].Sz =&_fge .CT_FontSize {ValAttr :size };
_bffa =true ;};};if !_bffa {_ged ._caed .FontChoice =append (_ged ._caed .FontChoice ,&_fge .CT_FontChoice {Sz :&_fge .CT_FontSize {ValAttr :size }});};};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_dd Cell )SetString (s string )int {_dd ._ef .ensureSharedStringsRelationships ();_dd .clearValue ();_dab :=_dd ._ef .SharedStrings .AddString (s );_dd ._dced .V =_f .String (_fg .Itoa (_dab ));_dd ._dced .TAttr =_fge .ST_CellTypeS ;return _dab ;
};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_afcc *Workbook )Epoch ()_gd .Time {if _afcc .Uses1904Dates (){_gd .Date (1904,1,1,0,0,0,0,_gd .UTC );};return _gd .Date (1899,12,30,0,0,0,0,_gd .UTC );};

// SetOperator sets the operator for the rule.
func (_fgac ConditionalFormattingRule )SetOperator (t _fge .ST_ConditionalFormattingOperator ){_fgac ._gcgc .OperatorAttr =t ;};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_bbab PatternFill )SetFgColor (c _cea .Color ){_bbab ._acgb .FgColor =_fge .NewCT_Color ();_bbab ._acgb .FgColor .RgbAttr =c .AsRGBAString ();};

// Type returns the type of anchor
func (_eecba TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// SetFont sets the font name for a rich text run.
func (_bfaa RichTextRun )SetFont (s string ){_bfaa .ensureRpr ();for _ ,_dbb :=range _bfaa ._gbe .RPr .RPrEltChoice {if _dbb .RFont !=nil {_dbb .RFont .ValAttr =s ;return ;};};_bfaa ._gbe .RPr .RPrEltChoice =append (_bfaa ._gbe .RPr .RPrEltChoice ,&_fge .CT_RPrEltChoice {RFont :&_fge .CT_FontName {ValAttr :s }});
};

// X returns the inner wrapped XML type.
func (_fcgd DataValidation )X ()*_fge .CT_DataValidation {return _fcgd ._ebga };

// Comments returns the list of comments for this sheet
func (_bacf Comments )Comments ()[]Comment {_aca :=[]Comment {};for _ ,_eeda :=range _bacf ._dfef .CommentList .Comment {_aca =append (_aca ,Comment {_bacf ._faff ,_eeda ,_bacf ._dfef });};return _aca ;};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_fbfg Comment )CellReference ()string {return _fbfg ._gade .RefAttr };

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_fge .Comments )Comments {return Comments {w ,x }};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_dgee *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_d .Replace (rangeRef ,"\u0024","",-1);_dgee ._defb .AutoFilter =_fge .NewCT_AutoFilter ();_dgee ._defb .AutoFilter .RefAttr =_f .String (rangeRef );_gedc :="\u0027"+_dgee .Name ()+"\u0027\u0021";
var _gaeeg DefinedName ;for _ ,_dbec :=range _dgee ._fgca .DefinedNames (){if _dbec .Name ()==_ecff {if _d .HasPrefix (_dbec .Content (),_gedc ){_gaeeg =_dbec ;_gaeeg .SetContent (_dgee .RangeReference (rangeRef ));break ;};};};if _gaeeg .X ()==nil {_gaeeg =_dgee ._fgca .AddDefinedName (_ecff ,_dgee .RangeReference (rangeRef ));
};for _dgd ,_aab :=range _dgee ._fgca ._egabd {if _aab ==_dgee ._defb {_gaeeg .SetLocalSheetID (uint32 (_dgd ));};};};

// SetText sets the text to be displayed.
func (_fbga RichTextRun )SetText (s string ){_fbga ._gbe .T =s };func _dffg (_fde string )bool {_fde =_d .Replace (_fde ,"\u0024","",-1);if _adcc :=_fbad .FindStringSubmatch (_d .ToLower (_fde ));len (_adcc )> 2{_gfec :=_adcc [1];_babg ,_fce :=_fg .Atoi (_adcc [2]);
if _fce !=nil {return false ;};return _babg <=1048576&&_gfec <="\u007a\u007a";};return false ;};const (DVCompareTypeWholeNumber =DVCompareType (_fge .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_fge .ST_DataValidationTypeDecimal );
DVCompareTypeDate =DVCompareType (_fge .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_fge .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_fge .ST_DataValidationTypeTextLength ););

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_aecae TwoCellAnchor )SetHeightCells (h int32 ){_aecae .SetHeight (0);_gdcc :=_aecae .TopLeft ();_dcee :=_aecae .BottomRight ();_dcee .SetRow (_gdcc .Row ()+h );};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_ece Sheet )ValidateWithPath (path string )error {return _ece ._defb .ValidateWithPath (path )};func (_gfff DataValidationCompare )SetValue2 (v string ){_gfff ._ccb .Formula2 =&v };

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_egf *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_gfgg :=_fge .NewCT_ConditionalFormatting ();_egf ._defb .ConditionalFormatting =append (_egf ._defb .ConditionalFormatting ,_gfgg );_dfbgg :=make (_fge .ST_Sqref ,0,0);
_gfgg .SqrefAttr =&_dfbgg ;for _ ,_ccdfd :=range cellRanges {*_gfgg .SqrefAttr =append (*_gfgg .SqrefAttr ,_ccdfd );};return ConditionalFormatting {_gfgg };};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_fcc *_fgf .CT_AbsoluteAnchor };

// Name returns the name of the table
func (_dcdd Table )Name ()string {if _dcdd ._ecgbf .NameAttr !=nil {return *_dcdd ._ecgbf .NameAttr ;};return "";};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_efef ,_gdcg :=_abd .Open (filename );if _gdcg !=nil {return nil ,_c .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gdcg );};defer _efef .Close ();
_bdeg ,_gdcg :=_abd .Stat (filename );if _gdcg !=nil {return nil ,_c .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gdcg );};_bbcd ,_gdcg :=Read (_efef ,_bdeg .Size ());if _gdcg !=nil {return nil ,_gdcg ;
};_beae ,_ :=_g .Abs (_g .Dir (filename ));_bbcd ._deff =_g .Join (_beae ,filename );return _bbcd ,nil ;};

// HasFormula returns true if the cell has an asoociated formula.
func (_aed Cell )HasFormula ()bool {return _aed ._dced .F !=nil };func (_gegce *Workbook )ensureSharedStringsRelationships (){_fcdg :=false ;for _ ,_cfba :=range _gegce .ContentTypes .X ().TypesChoice {if _cfba .Override !=nil &&_cfba .Override .ContentTypeAttr ==_f .SharedStringsContentType {_fcdg =true ;
break ;};};if !_fcdg {_gegce .ContentTypes .AddOverride (_ebdc ,_f .SharedStringsContentType );};_dbffd :=false ;for _ ,_cbce :=range _gegce ._cbag .Relationships (){if _cbce .X ().TargetAttr ==_gggb {_dbffd =true ;break ;};};if !_dbffd {_gegce ._cbag .AddRelationship (_gggb ,_f .SharedStringsType );
};};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_cgaa *_fge .CT_DefinedName };const (DVOpGreater =_fge .ST_DataValidationOperatorGreaterThanOrEqual ;);func _def ()*_fgf .CT_TwoCellAnchor {_bfcb :=_fgf .NewCT_TwoCellAnchor ();_bfcb .EditAsAttr =_fgf .ST_EditAsOneCell ;_bfcb .From .Col =5;
_bfcb .From .Row =0;_bfcb .From .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);_bfcb .From .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);_bfcb .To .Col =10;_bfcb .To .Row =20;_bfcb .To .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);_bfcb .To .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);
return _bfcb ;};

// RemoveDefinedName removes an existing defined name.
func (_fgdd *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _fb .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");
};for _ddcc ,_gcaf :=range _fgdd ._fefd .DefinedNames .DefinedName {if _gcaf ==dn .X (){copy (_fgdd ._fefd .DefinedNames .DefinedName [_ddcc :],_fgdd ._fefd .DefinedNames .DefinedName [_ddcc +1:]);_fgdd ._fefd .DefinedNames .DefinedName [len (_fgdd ._fefd .DefinedNames .DefinedName )-1]=nil ;
_fgdd ._fefd .DefinedNames .DefinedName =_fgdd ._fefd .DefinedNames .DefinedName [:len (_fgdd ._fefd .DefinedNames .DefinedName )-1];return nil ;};};return _fb .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_bdged *Sheet )GetDrawing ()(*_fgf .WsDr ,_fa .Relationships ){if _fcba :=_bdged ._defb .Drawing ;_fcba !=nil {_fcfg :=0;for _ ,_dgb :=range _bdged ._fgca ._egabd {if _eadg :=_dgb .Drawing ;_eadg !=nil {if _dgb ==_bdged ._defb {return _bdged ._fgca ._beed [_fcfg ],_bdged ._fgca ._gfgab [_fcfg ];
};_fcfg ++;};};};return nil ,_fa .Relationships {};};

// Text returns text from the workbook as one string separated with line breaks.
func (_fcce *WorkbookText )Text ()string {_gdfa :=_fc .NewBuffer ([]byte {});for _ ,_bgg :=range _fcce .Sheets {_gdfa .WriteString (_bgg .Text ());};return _gdfa .String ();};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_ebcb :=uint16 (0);if len (s )> 0{for _egd :=len (s )-1;_egd >=0;_egd --{_edg :=s [_egd ];_ebcb =((_ebcb >>14)&0x01)|((_ebcb <<1)&0x7fff);_ebcb ^=uint16 (_edg );};_ebcb =((_ebcb >>14)&0x01)|((_ebcb <<1)&0x7fff);_ebcb ^=uint16 (len (s ));
_ebcb ^=(0x8000|('N'<<8)|'K');};return _c .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_ebcb ));};func NewPatternFill (fills *_fge .CT_Fills )PatternFill {_fdde :=_fge .NewCT_Fill ();_fdde .FillChoice =_fge .NewCT_FillChoice ();_fdde .FillChoice .PatternFill =_fge .NewCT_PatternFill ();
return PatternFill {_fdde .FillChoice .PatternFill ,_fdde };};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_addb *_fge .CT_ConditionalFormatting ;};var (_dade =[...]uint8 {0,21,46,61,76,91};_adef =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_cbgd =[...]uint8 {0,16,32,48,64};_dcdg =[...]uint8 {0,16,32,48,64,80};
);

// X returns the inner wrapped XML type.
func (_gfa MergedCell )X ()*_fge .CT_MergeCell {return _gfa ._dbac };func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_gdcb :=NumberFormat {_gage :_fge .NewCT_NumFmt ()};_gdcb ._gage .NumFmtIdAttr =uint32 (id );_gdcb ._gage .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";
switch id {case StandardFormat0 :_gdcb ._gage .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_gdcb ._gage .FormatCodeAttr ="\u0030";case StandardFormat2 :_gdcb ._gage .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_gdcb ._gage .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";
case StandardFormat4 :_gdcb ._gage .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_gdcb ._gage .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_gdcb ._gage .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_gdcb ._gage .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";
case StandardFormat12 :_gdcb ._gage .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_gdcb ._gage .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_gdcb ._gage .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";
case StandardFormat15 :_gdcb ._gage .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_gdcb ._gage .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_gdcb ._gage .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";
case StandardFormat18 :_gdcb ._gage .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_gdcb ._gage .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_gdcb ._gage .FormatCodeAttr ="\u0068\u003a\u006d\u006d";
case StandardFormat21 :_gdcb ._gage .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_gdcb ._gage .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_gdcb ._gage .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";
case StandardFormat38 :_gdcb ._gage .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_gdcb ._gage .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";
case StandardFormat40 :_gdcb ._gage .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_gdcb ._gage .FormatCodeAttr ="\u006d\u006d\u003as\u0073";
case StandardFormat46 :_gdcb ._gage .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_gdcb ._gage .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_gdcb ._gage .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";
case StandardFormat49 :_gdcb ._gage .FormatCodeAttr ="\u0040";};return _gdcb ;};func (_ga Border )SetRight (style _fge .ST_BorderStyle ,c _cea .Color ){if _ga ._ed .Right ==nil {_ga ._ed .Right =_fge .NewCT_BorderPr ();};_ga ._ed .Right .Color =_fge .NewCT_Color ();
_ga ._ed .Right .Color .RgbAttr =c .AsRGBAString ();_ga ._ed .Right .StyleAttr =style ;};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_ceb *Sheet )Row (rowNum uint32 )Row {for _ ,_egb :=range _ceb ._defb .SheetData .Row {if _egb .RAttr !=nil &&*_egb .RAttr ==rowNum {return Row {_ceb ._fgca ,_ceb ,_egb };};};return _ceb .AddNumberedRow (rowNum );};func (_cffdg *Sheet )updateAfterRemove (_aedd uint32 ,_afdc _be .UpdateAction )error {_adeg :=_cffdg .Name ();
_bead :=&_be .UpdateQuery {UpdateType :_afdc ,ColumnIdx :_aedd ,SheetToUpdate :_adeg };for _ ,_egadf :=range _cffdg ._fgca .Sheets (){_bead .UpdateCurrentSheet =_adeg ==_egadf .Name ();for _ ,_bbff :=range _egadf .Rows (){for _ ,_cebb :=range _bbff .Cells (){if _cebb .X ().F !=nil {_bffe :=_cebb .X ().F .Content ;
_acdg :=_bac .ParseString (_bffe );if _acdg ==nil {_cebb .SetError ("\u0023\u0052\u0045F\u0021");}else {_bcbaf :=_acdg .Update (_bead );_cebb .X ().F .Content =_c .Sprintf ("\u003d\u0025\u0073",_bcbaf .String ());};};};};};return nil ;};type ConditionalFormattingRule struct{_gcgc *_fge .CT_CfRule };


// Validate attempts to validate the structure of a workbook.
func (_eabdf *Workbook )Validate ()error {if _eabdf ==nil ||_eabdf ._fefd ==nil {return _fb .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");
};_caef :=uint32 (0);for _ ,_fca :=range _eabdf ._fefd .Sheets .Sheet {if _fca .SheetIdAttr > _caef {_caef =_fca .SheetIdAttr ;};};if _caef !=uint32 (len (_eabdf ._egabd )){return _c .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_caef ,len (_eabdf ._egabd ));
};_cceb :=map[string ]struct{}{};for _baeec ,_ggceg :=range _eabdf ._fefd .Sheets .Sheet {_dagef :=Sheet {_eabdf ,_ggceg ,_eabdf ._egabd [_baeec ]};if _ ,_dgdc :=_cceb [_dagef .Name ()];_dgdc {return _c .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_baeec ,_dagef .Name ());
};_cceb [_dagef .Name ()]=struct{}{};if _abb :=_dagef .ValidateWithPath (_c .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_baeec ));_abb !=nil {return _abb ;};if _gfacf :=_dagef .Validate ();_gfacf !=nil {return _gfacf ;
};};return nil ;};

// AddRun adds a new run of text to the cell.
func (_cfcd RichText )AddRun ()RichTextRun {_deag :=_fge .NewCT_RElt ();_cfcd ._faae .R =append (_cfcd ._faae .R ,_deag );return RichTextRun {_deag };};

// AddMergedCells merges cells within a sheet.
func (_afb *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _afb ._defb .MergeCells ==nil {_afb ._defb .MergeCells =_fge .NewCT_MergeCells ();};_fbeb :=_fge .NewCT_MergeCell ();_fbeb .RefAttr =_c .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );
_afb ._defb .MergeCells .MergeCell =append (_afb ._defb .MergeCells .MergeCell ,_fbeb );_afb ._defb .MergeCells .CountAttr =_f .Uint32 (uint32 (len (_afb ._defb .MergeCells .MergeCell )));return MergedCell {_afb ._fgca ,_afb ,_fbeb };};

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_decb *Sheet )Column (idx uint32 )Column {for _ ,_edga :=range _decb ._defb .Cols {for _ ,_fgbf :=range _edga .Col {if idx >=_fgbf .MinAttr &&idx <=_fgbf .MaxAttr {return Column {_fgbf };};};};var _bffg *_fge .CT_Cols ;if len (_decb ._defb .Cols )==0{_bffg =_fge .NewCT_Cols ();
_decb ._defb .Cols =append (_decb ._defb .Cols ,_bffg );}else {_bffg =_decb ._defb .Cols [0];};_ccf :=_fge .NewCT_Col ();_ccf .MinAttr =idx ;_ccf .MaxAttr =idx ;_bffg .Col =append (_bffg .Col ,_ccf );return Column {_ccf };};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_bbgb StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _bbgb ._ccde .Dxfs ==nil {_bbgb ._ccde .Dxfs =_fge .NewCT_Dxfs ();};_bcgb :=_fge .NewCT_Dxf ();_bbgb ._ccde .Dxfs .Dxf =append (_bbgb ._ccde .Dxfs .Dxf ,_bcgb );_bbgb ._ccde .Dxfs .CountAttr =_f .Uint32 (uint32 (len (_bbgb ._ccde .Dxfs .Dxf )));
return DifferentialStyle {_bcgb ,_bbgb ._eafa ,_bbgb ._ccde .Dxfs };};func (_fddgb *Workbook )onNewRelationship (_ddde *_dg .DecodeMap ,_ebdb ,_caebb string ,_aaea []*_ag .File ,_eefc *_ge .Relationship ,_dcaf _dg .Target )error {_dcdf :=_f .DocTypeSpreadsheet ;
switch _caebb {case _f .OfficeDocumentType :_fddgb ._fefd =_fge .NewWorkbook ();_ddde .AddTarget (_ebdb ,_fddgb ._fefd ,_caebb ,0);_fddgb ._cbag =_fa .NewRelationships ();_ddde .AddTarget (_dg .RelationsPathFor (_ebdb ),_fddgb ._cbag .X (),_caebb ,0);_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,0);
case _f .CorePropertiesType :_ddde .AddTarget (_ebdb ,_fddgb .CoreProperties .X (),_caebb ,0);_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,0);case _f .CustomPropertiesType :_ddde .AddTarget (_ebdb ,_fddgb .CustomProperties .X (),_caebb ,0);
_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,0);case _f .ExtendedPropertiesType :_ddde .AddTarget (_ebdb ,_fddgb .AppProperties .X (),_caebb ,0);_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,0);case _f .WorksheetType :_bccb :=_fge .NewWorksheet ();
_ecgc ,_daed :=_db .StringToNumbers (_ebdb );if !_daed {_ecgc =len (_fddgb ._egabd );};_ddde .AddTarget (_ebdb ,_bccb ,_caebb ,uint32 (_ecgc ));_fgge :=_fa .NewRelationships ();_ddde .AddTarget (_dg .RelationsPathFor (_ebdb ),_fgge .X (),_caebb ,0);_fddgb ._bbea =append (_fddgb ._bbea ,_fgge );
_fddgb ._aacf =append (_fddgb ._aacf ,nil );_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,_ecgc );if _fddgb ._fefd .Sheets !=nil {if len (_fddgb ._egabd )< 1{_fddgb ._egabd =make ([]*_fge .Worksheet ,len (_fddgb ._fefd .Sheets .Sheet ));
};for _bgfbd ,_ccfg :=range _fddgb ._fefd .Sheets .Sheet {if _ccfg .IdAttr ==_eefc .IdAttr {_fddgb ._egabd [_bgfbd ]=_bccb ;};};}else {_fddgb ._egabd =append (_fddgb ._egabd ,_bccb );};case _f .StylesType :_fddgb .StyleSheet =NewStyleSheet (_fddgb );_ddde .AddTarget (_ebdb ,_fddgb .StyleSheet .X (),_caebb ,0);
_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,0);case _f .ThemeType :_gebgd :=_cg .NewTheme ();_fddgb ._edgb =append (_fddgb ._edgb ,_gebgd );_ddde .AddTarget (_ebdb ,_gebgd ,_caebb ,0);_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,len (_fddgb ._edgb ));
case _f .SharedStringsType :_fddgb .SharedStrings =NewSharedStrings ();_ddde .AddTarget (_ebdb ,_fddgb .SharedStrings .X (),_caebb ,0);_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,0);case _f .ThumbnailType :for _aded ,_bgaa :=range _aaea {if _bgaa ==nil {continue ;
};if _bgaa .Name ==_ebdb {_agbf ,_bacag :=_bgaa .Open ();if _bacag !=nil {return _c .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_bacag );};_fddgb .Thumbnail ,_ ,_bacag =_b .Decode (_agbf );
_agbf .Close ();if _bacag !=nil {return _c .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_bacag );};_aaea [_aded ]=nil ;};};case _f .ImageType :for _ecaf ,_dfag :=range _fddgb ._caafe {_fcca :=_ff .Clean (_ebdb );
if _fcca ==_ecaf {_eefc .TargetAttr =_dfag ;return nil ;};};_cggb :=_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,len (_fddgb .Images )+1);for _cbdg ,_deeag :=range _aaea {if _deeag ==nil {continue ;};if _deeag .Name ==_ff .Clean (_ebdb ){_fcfd ,_gcecf :=_dg .ExtractToDiskTmp (_deeag ,_fddgb .TmpPath );
if _gcecf !=nil {return _gcecf ;};_cgac ,_gcecf :=_fa .ImageFromStorage (_fcfd );if _gcecf !=nil {return _gcecf ;};_bedb :=_fa .MakeImageRef (_cgac ,&_fddgb .DocBase ,_fddgb ._cbag );_bedb .SetTarget (_cggb );_fddgb ._caafe [_deeag .Name ]=_cggb ;_fddgb .Images =append (_fddgb .Images ,_bedb );
_aaea [_cbdg ]=nil ;};};_eefc .TargetAttr =_cggb ;case _f .DrawingType :_bebdd :=_fgf .NewWsDr ();_aaee :=uint32 (len (_fddgb ._beed ));_ddde .AddTarget (_ebdb ,_bebdd ,_caebb ,_aaee );_fddgb ._beed =append (_fddgb ._beed ,_bebdd );_cadb :=_fa .NewRelationships ();
_ddde .AddTarget (_dg .RelationsPathFor (_ebdb ),_cadb .X (),_caebb ,_aaee );_fddgb ._gfgab =append (_fddgb ._gfgab ,_cadb );_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,len (_fddgb ._beed ));case _f .VMLDrawingType :_gecd :=_ea .NewContainer ();
_aedbb :=uint32 (len (_fddgb ._deea ));_ddde .AddTarget (_ebdb ,_gecd ,_caebb ,_aedbb );_fddgb ._deea =append (_fddgb ._deea ,_gecd );case _f .CommentsType :_fddgb ._aacf [_dcaf .Index ]=_fge .NewComments ();_ddde .AddTarget (_ebdb ,_fddgb ._aacf [_dcaf .Index ],_caebb ,_dcaf .Index );
_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,len (_fddgb ._aacf ));case _f .ChartType :_aggbb :=_dc .NewChartSpace ();_gdea :=uint32 (len (_fddgb ._cdbc ));_ddde .AddTarget (_ebdb ,_aggbb ,_caebb ,_gdea );_fddgb ._cdbc =append (_fddgb ._cdbc ,_aggbb );
_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,len (_fddgb ._cdbc ));if _fddgb ._gcae ==nil {_fddgb ._gcae =make (map[string ]*_dc .ChartSpace );};_fddgb ._gcae [_eefc .TargetAttr ]=_aggbb ;case _f .TableType :_gdfgc :=_fge .NewTable ();
_geff :=uint32 (len (_fddgb ._eafaa ));_ddde .AddTarget (_ebdb ,_gdfgc ,_caebb ,_geff );_fddgb ._eafaa =append (_fddgb ._eafaa ,_gdfgc );_eefc .TargetAttr =_f .RelativeFilename (_dcdf ,_dcaf .Typ ,_caebb ,len (_fddgb ._eafaa ));default:_cf .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_ebdb ,_caebb );
};return nil ;};

// AddFont creates a new empty Font style.
func (_ebgba StyleSheet )AddFont ()Font {_baad :=_fge .NewCT_Font ();return Font {_baad ,_ebgba ._ccde }};

// Priority returns the rule priority
func (_fdc ConditionalFormattingRule )Priority ()int32 {return _fdc ._gcgc .PriorityAttr };

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_faae *_fge .CT_Rst };

// SetBold causes the text to be displayed in bold.
func (_eeb RichTextRun )SetBold (b bool ){_eeb .ensureRpr ();for _ ,_bbef :=range _eeb ._gbe .RPr .RPrEltChoice {if _bbef .B !=nil {_bbef .B .ValAttr =_f .Bool (b );return ;};};_eeb ._gbe .RPr .RPrEltChoice =append (_eeb ._gbe .RPr .RPrEltChoice ,&_fge .CT_RPrEltChoice {B :&_fge .CT_BooleanProperty {ValAttr :_f .Bool (b )}});
};

// IsBool returns true if the cell boolean value.
func (_dge *evalContext )IsBool (cellRef string )bool {return _dge ._dgf .Cell (cellRef ).IsBool ()};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_gedaa Sheet )RangeReference (n string )string {_fgdg :=_d .Split (n ,"\u003a");_cefg ,_ :=_gb .ParseCellReference (_fgdg [0]);_aagb :=_c .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_cefg .Column ,_cefg .RowIdx );if len (_fgdg )==1{return _c .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_gedaa .Name (),_aagb );
};_gfgf ,_ :=_gb .ParseCellReference (_fgdg [1]);_dffce :=_c .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_gfgf .Column ,_gfgf .RowIdx );return _c .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_gedaa .Name (),_aagb ,_dffce );
};

// MoveTo repositions the anchor without changing the objects size.
func (_daagg TwoCellAnchor )MoveTo (col ,row int32 ){_ebbg :=_daagg .TopLeft ();_decc :=_daagg .BottomRight ();_ebd :=_decc .Col ()-_ebbg .Col ();_egbdf :=_decc .Row ()-_ebbg .Row ();_ebbg .SetCol (col );_ebbg .SetRow (row );_decc .SetCol (col +_ebd );
_decc .SetRow (row +_egbdf );};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_afcg Row )Cell (col string )Cell {_acge :=_c .Sprintf ("\u0025\u0073\u0025\u0064",col ,_afcg .RowNumber ());for _ ,_ddc :=range _afcg ._feg .C {if _ddc .RAttr !=nil &&*_ddc .RAttr ==_acge {return Cell {_afcg ._dbe ,_afcg ._gfac ,_afcg ._feg ,_ddc };
};};return _afcg .AddNamedCell (col );};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_fgd Comment )SetAuthor (author string ){_fgd ._gade .AuthorIdAttr =Comments {_fgd ._bcbf ,_fgd ._bad }.getOrCreateAuthor (author );};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_dcec *_fge .CT_DataBar };

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_fdaf Comment )SetCellReference (cellRef string ){_fdaf ._gade .RefAttr =cellRef };func (_gcaag *Sheet )setShared (_fbcc string ,_bbca ,_beag _gb .CellReference ,_gagc string ){_dfc :=_gcaag .FormulaContext ();_fdcf :=_bac .NewEvaluator ();for _abegg :=_bbca .RowIdx ;
_abegg <=_beag .RowIdx ;_abegg ++{for _gedf :=_bbca .ColumnIdx ;_gedf <=_beag .ColumnIdx ;_gedf ++{_fgeb :=_abegg -_bbca .RowIdx ;_cbad :=_gedf -_bbca .ColumnIdx ;_dfc .SetOffset (_cbad ,_fgeb );_dagd :=_fdcf .Eval (_dfc ,_gagc );_egga :=_c .Sprintf ("\u0025\u0073\u0025\u0064",_gb .IndexToColumn (_gedf ),_abegg );
_bccf :=_gcaag .Cell (_egga );if _dagd .Type ==_bac .ResultTypeNumber {_bccf .X ().TAttr =_fge .ST_CellTypeN ;}else {_bccf .X ().TAttr =_fge .ST_CellTypeInlineStr ;};_bccf .X ().V =_f .String (_dagd .Value ());};};_ =_fdcf ;_ =_dfc ;};

// SetMinLength sets the minimum bar length in percent.
func (_fbb DataBarScale )SetMinLength (l uint32 ){_fbb ._dcec .MinLengthAttr =_f .Uint32 (l )};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_gafg StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_cgcbf :=range _gafg .CellStyles (){if _cgcbf .HasNumberFormat ()&&_cgcbf .NumberFormat ()==uint32 (f ){return _cgcbf ;};};_fccf :=_gafg .AddCellStyle ();_fccf .SetNumberFormatStandard (f );
return _fccf ;};func (_gdfg Font )SetBold (b bool ){_adda :=false ;for _bfda ,_eac :=range _gdfg ._caed .FontChoice {if _eac .B !=nil {if b {_gdfg ._caed .FontChoice [_bfda ].B =&_fge .CT_BooleanProperty {};}else {_gdfg ._caed .FontChoice [_bfda ]=nil ;
};_adda =true ;};};if !_adda {_gdfg ._caed .FontChoice =append (_gdfg ._caed .FontChoice ,&_fge .CT_FontChoice {B :&_fge .CT_BooleanProperty {}});};};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_ccd ConditionalFormattingRule )SetColorScale ()ColorScale {_ccd .clear ();_ccd .SetType (_fge .ST_CfTypeColorScale );_ccd ._gcgc .ColorScale =_fge .NewCT_ColorScale ();return ColorScale {_ccd ._gcgc .ColorScale };};

// BottomRight is a no-op.
func (_ffe OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Cell returns the actual cell behind the merged region
func (_dfee MergedCell )Cell ()Cell {_afff :=_dfee .Reference ();if _daag :=_d .Index (_dfee .Reference (),"\u003a");_daag !=-1{_afff =_afff [0:_daag ];return _dfee ._edfd .Cell (_afff );};return Cell {};};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_ffff *Workbook )AddDrawing ()Drawing {_caff :=_fgf .NewWsDr ();_ffff ._beed =append (_ffff ._beed ,_caff );_fgadb :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,len (_ffff ._beed ));_ffff .ContentTypes .AddOverride (_fgadb ,_f .DrawingContentType );
_ffff ._gfgab =append (_ffff ._gfgab ,_fa .NewRelationships ());return Drawing {_ffff ,_caff };};

// AddCellStyle creates a new empty cell style.
func (_bdcb StyleSheet )AddCellStyle ()CellStyle {_bdabe :=_fge .NewCT_Xf ();return CellStyle {_bdcb ._eafa ,_bdabe ,_bdcb ._ccde .CellXfs };};

// ClearAutoFilter removes the autofilters from the sheet.
func (_gecc *Sheet )ClearAutoFilter (){_gecc ._defb .AutoFilter =nil ;_efb :="\u0027"+_gecc .Name ()+"\u0027\u0021";for _ ,_cdeg :=range _gecc ._fgca .DefinedNames (){if _cdeg .Name ()==_ecff {if _d .HasPrefix (_cdeg .Content (),_efb ){_gecc ._fgca .RemoveDefinedName (_cdeg );
break ;};};};};

// IsSheetLocked returns whether the sheet objects are locked.
func (_gcaaa SheetProtection )IsObjectLocked ()bool {return _gcaaa ._bbaf .ObjectsAttr !=nil &&*_gcaaa ._bbaf .ObjectsAttr ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_dffd *evalContext )GetLabelPrefix (cellRef string )string {return _dffd ._dgf .Cell (cellRef ).getLabelPrefix ();};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_cgde *Sheet )SetBorder (cellRange string ,border Border )error {_gfdf ,_decea ,_bgbe :=_gb .ParseRangeReference (cellRange );if _bgbe !=nil {return _bgbe ;};_bdef :=_cgde ._fgca .StyleSheet .AddCellStyle ();_gdfb :=_cgde ._fgca .StyleSheet .AddBorder ();
_bdef .SetBorder (_gdfb );_gdfb ._ed .Top =border ._ed .Top ;_gdfb ._ed .Left =border ._ed .Left ;_deaf :=_cgde ._fgca .StyleSheet .AddCellStyle ();_ddgb :=_cgde ._fgca .StyleSheet .AddBorder ();_deaf .SetBorder (_ddgb );_ddgb ._ed .Top =border ._ed .Top ;
_ddgb ._ed .Right =border ._ed .Right ;_aacac :=_cgde ._fgca .StyleSheet .AddCellStyle ();_fae :=_cgde ._fgca .StyleSheet .AddBorder ();_aacac .SetBorder (_fae );_fae ._ed .Top =border ._ed .Top ;_gded :=_cgde ._fgca .StyleSheet .AddCellStyle ();_fdf :=_cgde ._fgca .StyleSheet .AddBorder ();
_gded .SetBorder (_fdf );_fdf ._ed .Left =border ._ed .Left ;_dcga :=_cgde ._fgca .StyleSheet .AddCellStyle ();_cafc :=_cgde ._fgca .StyleSheet .AddBorder ();_dcga .SetBorder (_cafc );_cafc ._ed .Right =border ._ed .Right ;_faef :=_cgde ._fgca .StyleSheet .AddCellStyle ();
_dddcab :=_cgde ._fgca .StyleSheet .AddBorder ();_faef .SetBorder (_dddcab );_dddcab ._ed .Bottom =border ._ed .Bottom ;_efeb :=_cgde ._fgca .StyleSheet .AddCellStyle ();_efebe :=_cgde ._fgca .StyleSheet .AddBorder ();_efeb .SetBorder (_efebe );_efebe ._ed .Bottom =border ._ed .Bottom ;
_efebe ._ed .Left =border ._ed .Left ;_egde :=_cgde ._fgca .StyleSheet .AddCellStyle ();_ada :=_cgde ._fgca .StyleSheet .AddBorder ();_egde .SetBorder (_ada );_ada ._ed .Bottom =border ._ed .Bottom ;_ada ._ed .Right =border ._ed .Right ;_aggf :=_gfdf .RowIdx ;
_eage :=_gfdf .ColumnIdx ;_ebed :=_decea .RowIdx ;_cbec :=_decea .ColumnIdx ;for _ddgbf :=_aggf ;_ddgbf <=_ebed ;_ddgbf ++{for _bcbfa :=_eage ;_bcbfa <=_cbec ;_bcbfa ++{_deagb :=_c .Sprintf ("\u0025\u0073\u0025\u0064",_gb .IndexToColumn (_bcbfa ),_ddgbf );
switch {case _ddgbf ==_aggf &&_bcbfa ==_eage :_cgde .Cell (_deagb ).SetStyle (_bdef );case _ddgbf ==_aggf &&_bcbfa ==_cbec :_cgde .Cell (_deagb ).SetStyle (_deaf );case _ddgbf ==_ebed &&_bcbfa ==_eage :_cgde .Cell (_deagb ).SetStyle (_efeb );case _ddgbf ==_ebed &&_bcbfa ==_cbec :_cgde .Cell (_deagb ).SetStyle (_egde );
case _ddgbf ==_aggf :_cgde .Cell (_deagb ).SetStyle (_aacac );case _ddgbf ==_ebed :_cgde .Cell (_deagb ).SetStyle (_faef );case _bcbfa ==_eage :_cgde .Cell (_deagb ).SetStyle (_gded );case _bcbfa ==_cbec :_cgde .Cell (_deagb ).SetStyle (_dcga );};};};return nil ;
};

// ClearProtection clears all workbook protections.
func (_cbba *Workbook )ClearProtection (){_cbba ._fefd .WorkbookProtection =nil };

// New constructs a new workbook.
func New ()*Workbook {_fbgf :=&Workbook {};_fbgf ._fefd =_fge .NewWorkbook ();_fbgf .AppProperties =_fa .NewAppProperties ();_fbgf .CoreProperties =_fa .NewCoreProperties ();_fbgf .StyleSheet =NewStyleSheet (_fbgf );_fbgf .Rels =_fa .NewRelationships ();
_fbgf ._cbag =_fa .NewRelationships ();_fbgf .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .ExtendedPropertiesType ,0),_f .ExtendedPropertiesType );_fbgf .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .CorePropertiesType ,0),_f .CorePropertiesType );
_fbgf .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .OfficeDocumentType ,0),_f .OfficeDocumentType );_fbgf ._cbag .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .StylesType ,0),_f .StylesType );
_fbgf .ContentTypes =_fa .NewContentTypes ();_fbgf .ContentTypes .AddDefault ("\u0076\u006d\u006c",_f .VMLDrawingContentType );_fbgf .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");
_fbgf .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .StylesType ,0),_f .SMLStyleSheetContentType );_fbgf .SharedStrings =NewSharedStrings ();_fbgf .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0),_f .SharedStringsContentType );
_fbgf ._cbag .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0),_f .SharedStringsType );_fbgf ._caafe =map[string ]string {};return _fbgf ;};

// Rows returns all of the rows in a sheet.
func (_ddad *Sheet )Rows ()[]Row {_cfge :=[]Row {};for _ ,_beeg :=range _ddad ._defb .SheetData .Row {_cfge =append (_cfge ,Row {_ddad ._fgca ,_ddad ,_beeg });};return _cfge ;};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_dffdf StyleSheet )AddNumberFormat ()NumberFormat {if _dffdf ._ccde .NumFmts ==nil {_dffdf ._ccde .NumFmts =_fge .NewCT_NumFmts ();};_ffbf :=_fge .NewCT_NumFmt ();_ffbf .NumFmtIdAttr =uint32 (200+len (_dffdf ._ccde .NumFmts .NumFmt ));_dffdf ._ccde .NumFmts .NumFmt =append (_dffdf ._ccde .NumFmts .NumFmt ,_ffbf );
_dffdf ._ccde .NumFmts .CountAttr =_f .Uint32 (uint32 (len (_dffdf ._ccde .NumFmts .NumFmt )));return NumberFormat {_dffdf ._eafa ,_ffbf };};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_gbag Cell )SetFormulaRaw (s string ){_cd :=_bac .ParseString (s );if _cd ==nil {return ;};_gbag .clearValue ();_gbag ._dced .TAttr =_fge .ST_CellTypeStr ;_gbag ._dced .F =_fge .NewCT_CellFormula ();_gbag ._dced .F .Content =s ;};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_efed *_fgf .CT_TwoCellAnchor };

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _ad .ReaderAt ,size int64 )(*Workbook ,error ){const _abgg ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_e .GetLicenseKey ().IsLicensed ()&&!_cfbf {_c .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_c .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return nil ,_fb .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_abc :="\u0075n\u006b\u006e\u006f\u0077\u006e";if _efeg ,_fedg :=r .(*_abd .File );
_fedg {_abc =_efeg .Name ();};_eafb :=New ();_bfacg ,_gddf :=_e .GenRefId ("\u0073\u0072");if _gddf !=nil {_cf .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gddf );return nil ,_gddf ;};_eafb ._fead =_bfacg ;if _aeaf :=_e .Track (_eafb ._fead ,_abgg ,_abc );
_aeaf !=nil {_cf .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_aeaf );return nil ,_aeaf ;};_eegc ,_gddf :=_ce .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _gddf !=nil {return nil ,_gddf ;
};_eafb .TmpPath =_eegc ;_faaf ,_gddf :=_ag .NewReader (r ,size );if _gddf !=nil {return nil ,_c .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_gddf );};_bdcd :=[]*_ag .File {};_bdcd =append (_bdcd ,_faaf .File ...);
_cgdd :=false ;for _ ,_gfbb :=range _bdcd {if _gfbb .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_cgdd =true ;break ;};};if _cgdd {_eafb .CreateCustomProperties ();};_fgde :=_dg .DecodeMap {};
_fgde .SetOnNewRelationshipFunc (_eafb .onNewRelationship );_fgde .AddTarget (_f .ContentTypesFilename ,_eafb .ContentTypes .X (),"",0);_fgde .AddTarget (_f .BaseRelsFilename ,_eafb .Rels .X (),"",0);if _fbcd :=_fgde .Decode (_bdcd );_fbcd !=nil {return nil ,_fbcd ;
};for _ ,_fced :=range _bdcd {if _fced ==nil {continue ;};if _eee :=_eafb .AddExtraFileFromZip (_fced );_eee !=nil {return nil ,_eee ;};};if _cgdd {_ede :=false ;for _ ,_abeg :=range _eafb .Rels .X ().Relationship {if _abeg .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_ede =true ;
break ;};};if !_ede {_eafb .AddCustomRelationships ();};};return _eafb ,nil ;};

// SortOrder is a column sort order.
//
//go:generate stringer -type=SortOrder
type SortOrder byte ;func (_cff CellStyle )SetShrinkToFit (b bool ){if _cff ._dece .Alignment ==nil {_cff ._dece .Alignment =_fge .NewCT_CellAlignment ();};_cff ._dece .ApplyAlignmentAttr =_f .Bool (true );if !b {_cff ._dece .Alignment .ShrinkToFitAttr =nil ;
}else {_cff ._dece .Alignment .ShrinkToFitAttr =_f .Bool (b );};};func (_edbf Sheet )IsValid ()bool {return _edbf ._defb !=nil };

// AddFill creates a new empty Fill style.
func (_fed Fills )AddFill ()Fill {_cfd :=_fge .NewCT_Fill ();return Fill {_cfd ,_fed ._dbgaf }};

// SetType sets the type of the rule.
func (_cag ConditionalFormattingRule )SetType (t _fge .ST_CfType ){_cag ._gcgc .TypeAttr =t };

// Col returns the column of the cell marker.
func (_ded CellMarker )Col ()int32 {return _ded ._fdd .Col };

// SetCol set the column of the cell marker.
func (_bgc CellMarker )SetCol (col int32 ){_bgc ._fdd .Col =col };

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_bcgef *Workbook ;_gage *_fge .CT_NumFmt ;};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_bggg StyleSheet )RemoveFont (f Font )error {for _gacb ,_cagf :=range _bggg ._ccde .Fonts .Font {if _cagf ==f .X (){_bggg ._ccde .Fonts .Font =append (_bggg ._ccde .Fonts .Font [:_gacb ],_bggg ._ccde .Fonts .Font [_gacb +1:]...);return nil ;};};return _fb .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");
};

// SetShowRuler controls the visibility of the ruler
func (_fadda SheetView )SetShowRuler (b bool ){if !b {_fadda ._gfdfg .ShowRulerAttr =_f .Bool (false );}else {_fadda ._gfdfg .ShowRulerAttr =nil ;};};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_fbdca *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_bbeed :=range _fbdca .Sheets (){if _bbeed .Name ()==name {return _bbeed ,nil ;};};return Sheet {},ErrorNotFound ;};

// SetNumberFormat applies a number format to a cell style avoiding redundancy. The function checks if the given string
// already exists in the saved number formats. If found, the existing number format is reused; otherwise,
// the new number format is added to the saved number formats collection. The number format is then applied to the cell style,
// affecting all styles that reference it by index.
func (_fgab CellStyle )SetNumberFormat (s string ){var _fgg NumberFormat ;if _fgab ._decg .StyleSheet ._ccde .NumFmts ==nil {_fgab ._decg .StyleSheet ._ccde .NumFmts =_fge .NewCT_NumFmts ();};_dgc :=_fgab ._decg .StyleSheet ._ccde .NumFmts .NumFmt ;for _ ,_bca :=range _dgc {if _bb .DeepEqual (_bca .FormatCodeAttr ,s ){_fgg =NumberFormat {_fgab ._decg ,_bca };
_fgab ._dece .ApplyNumberFormatAttr =_f .Bool (true );_fgab ._dece .NumFmtIdAttr =_f .Uint32 (_fgg .ID ());return ;};};_cab :=_fge .NewCT_NumFmt ();_cab .NumFmtIdAttr =uint32 (200+len (_fgab ._decg .StyleSheet ._ccde .NumFmts .NumFmt ));_fgab ._decg .StyleSheet ._ccde .NumFmts .NumFmt =append (_fgab ._decg .StyleSheet ._ccde .NumFmts .NumFmt ,_cab );
_fgab ._decg .StyleSheet ._ccde .NumFmts .CountAttr =_f .Uint32 (uint32 (len (_fgab ._decg .StyleSheet ._ccde .NumFmts .NumFmt )));_fgg =NumberFormat {_fgab ._decg ,_cab };_fgg ._gage .FormatCodeAttr =s ;_fgab ._dece .ApplyNumberFormatAttr =_f .Bool (true );
_fgab ._dece .NumFmtIdAttr =_f .Uint32 (_fgg .ID ());};func (_gebe Fill )SetPatternFill ()PatternFill {if _gebe ._afcd .FillChoice ==nil {_gebe ._afcd .FillChoice =_fge .NewCT_FillChoice ();};_gebe ._afcd .FillChoice .GradientFill =nil ;_gebe ._afcd .FillChoice .PatternFill =_fge .NewCT_PatternFill ();
_gebe ._afcd .FillChoice .PatternFill .PatternTypeAttr =_fge .ST_PatternTypeSolid ;return PatternFill {_gebe ._afcd .FillChoice .PatternFill ,_gebe ._afcd };};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_fdcg *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _fdcg .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _fgacf _fa .Relationship ;for _ ,_ccdeg :=range _fdcg ._cbag .Relationships (){if _ccdeg .ID ()==_fdcg ._fefd .Sheets .Sheet [ind ].IdAttr {var _cafa bool ;
if _fgacf ,_cafa =_fdcg ._cbag .CopyRelationship (_ccdeg .ID ());!_cafa {return Sheet {},ErrorNotFound ;};break ;};};_fdcg .ContentTypes .CopyOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1),_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,len (_fdcg .ContentTypes .X ().TypesChoice )));
_daea :=*_fdcg ._egabd [ind ];_fdcg ._egabd =append (_fdcg ._egabd ,&_daea );var _efdf uint32 =0;for _ ,_abcb :=range _fdcg ._fefd .Sheets .Sheet {if _abcb .SheetIdAttr > _efdf {_efdf =_abcb .SheetIdAttr ;};};_efdf ++;_egeg :=*_fdcg ._fefd .Sheets .Sheet [ind ];
_egeg .IdAttr =_fgacf .ID ();_egeg .NameAttr =copiedSheetName ;_egeg .SheetIdAttr =_efdf ;_fdcg ._fefd .Sheets .Sheet =append (_fdcg ._fefd .Sheets .Sheet ,&_egeg );_dfaf :=_fa .NewRelationshipsCopy (_fdcg ._bbea [ind ]);_fdcg ._bbea =append (_fdcg ._bbea ,_dfaf );
_gfce :=_fdcg ._aacf [ind ];if _gfce ==nil {_fdcg ._aacf =append (_fdcg ._aacf ,nil );}else {_afegb :=*_gfce ;_fdcg ._aacf =append (_fdcg ._aacf ,&_afegb );};_ddgf :=Sheet {_fdcg ,&_egeg ,&_daea };return _ddgf ,nil ;};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_cdfce *Sheet )SetDrawing (d Drawing ){var _affb _fa .Relationships ;for _dfg ,_ecef :=range _cdfce ._fgca ._egabd {if _ecef ==_cdfce ._defb {_affb =_cdfce ._fgca ._bbea [_dfg ];break ;};};var _egcb string ;for _dccc ,_gbg :=range d ._dfbc ._beed {if _gbg ==d ._caeb {_fddec :=_affb .AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_dccc +1,_f .DrawingType );
_egcb =_fddec .ID ();break ;};};_cdfce ._defb .Drawing =_fge .NewCT_Drawing ();_cdfce ._defb .Drawing .IdAttr =_egcb ;};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_cda Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_bgfb :=[]Cell {};for _gbee :=uint32 (0);_gbee <=lastColIdx ;_gbee ++{_bffb :=_cda .Cell (_gb .IndexToColumn (_gbee ));_bgfb =append (_bgfb ,_bffb );};return _bgfb ;};const (DVCompareOpEqual =DVCompareOp (_fge .ST_DataValidationOperatorEqual );
DVCompareOpBetween =DVCompareOp (_fge .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_fge .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_fge .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_fge .ST_DataValidationOperatorGreaterThan );
DVCompareOpGreaterEqual =DVCompareOp (_fge .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_fge .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_fge .ST_DataValidationOperatorLessThanOrEqual ););

// AddFormatValue adds a format value (databars require two).
func (_ebgb DataBarScale )AddFormatValue (t _fge .ST_CfvoType ,val string ){_ddb :=_fge .NewCT_Cfvo ();_ddb .TypeAttr =t ;_ddb .ValAttr =_f .String (val );_ebgb ._dcec .Cfvo =append (_ebgb ._dcec .Cfvo ,_ddb );};func (_agg Cell )getLocked ()bool {if _agg ._dced .SAttr ==nil {return false ;
};_affg :=*_agg ._dced .SAttr ;_eef :=_agg ._ef .StyleSheet .GetCellStyle (_affg );return *_eef ._dece .Protection .LockedAttr ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_eefg Row )RowNumber ()uint32 {if _eefg ._feg .RAttr !=nil {return *_eefg ._feg .RAttr ;};return 0;};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_ebge :_fge .NewSst (),_cbdf :make (map[string ]int )};};

// Operator returns the operator for the rule
func (_cae ConditionalFormattingRule )Operator ()_fge .ST_ConditionalFormattingOperator {return _cae ._gcgc .OperatorAttr ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_gcca *Sheet )ClearCachedFormulaResults (){for _ ,_ddag :=range _gcca .Rows (){for _ ,_bge :=range _ddag .Cells (){if _bge .X ().F !=nil {_bge .X ().V =nil ;};};};};

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_bed Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_ac :=_bac .ParseString (formulaStr );if _ac ==nil {return _fb .New (_c .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));
};_bed .clearValue ();_bed ._dced .TAttr =_fge .ST_CellTypeStr ;_bed ._dced .F =_fge .NewCT_CellFormula ();_bed ._dced .F .TAttr =_fge .ST_CellFormulaTypeShared ;_bed ._dced .F .Content =formulaStr ;_dfd ,_abe :=_gb .ParseCellReference (_bed .Reference ());
if _abe !=nil {return _abe ;};_gf :=uint32 (0);for _ ,_cdg :=range _bed ._eg .Rows (){for _ ,_eda :=range _cdg ._feg .C {if _eda .F !=nil &&_eda .F .SiAttr !=nil &&*_eda .F .SiAttr >=_gf {_gf =*_eda .F .SiAttr ;};};};_gf ++;_ebg :=_c .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_dfd .Column ,_dfd .RowIdx ,_gb .IndexToColumn (_dfd .ColumnIdx +cols ),_dfd .RowIdx +rows );
_bed ._dced .F .RefAttr =_f .String (_ebg );_bed ._dced .F .SiAttr =_f .Uint32 (_gf );_bgf :=Sheet {_bed ._ef ,_bed ._eg ._bgfdd ,_bed ._eg ._defb };for _gc :=_dfd .RowIdx ;_gc <=_dfd .RowIdx +rows ;_gc ++{for _bbc :=_dfd .ColumnIdx ;_bbc <=_dfd .ColumnIdx +cols ;
_bbc ++{if _gc ==_dfd .RowIdx &&_bbc ==_dfd .ColumnIdx {continue ;};_ceg :=_c .Sprintf ("\u0025\u0073\u0025\u0064",_gb .IndexToColumn (_bbc ),_gc );_bgf .Cell (_ceg ).Clear ();_bgf .Cell (_ceg ).X ().F =_fge .NewCT_CellFormula ();_bgf .Cell (_ceg ).X ().F .TAttr =_fge .ST_CellFormulaTypeShared ;
_bgf .Cell (_ceg ).X ().F .SiAttr =_f .Uint32 (_gf );};};return nil ;};

// Row returns the row of the cell marker.
func (_bbf CellMarker )Row ()int32 {return _bbf ._fdd .Row };

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_ceac *evalContext )LastRow (col string )int {_aaf :=_ceac ._dgf ;_adge :=int (_gb .ColumnToIndex (col ));_bce :=1;for _ ,_cdcd :=range _aaf ._defb .SheetData .Row {if _cdcd .RAttr !=nil {_fafe :=Row {_aaf ._fgca ,_aaf ,_cdcd };_ege :=len (_fafe .Cells ());
if _ege > _adge {_bce =int (_fafe .RowNumber ());};};};return _bce ;};func (_ecgb *evalContext )SetOffset (col ,row uint32 ){_ecgb ._gca =col ;_ecgb ._cdd =row };func (_aea DifferentialStyle )Fill ()Fill {if _aea ._ceag .Fill ==nil {_aea ._ceag .Fill =_fge .NewCT_Fill ();
};return Fill {_aea ._ceag .Fill ,nil };};

// SetTopLeft sets the top left visible cell after the split.
func (_ceaf SheetView )SetTopLeft (cellRef string ){_ceaf .ensurePane ();_ceaf ._gfdfg .Pane .TopLeftCellAttr =&cellRef ;};

// Sheets returns the sheets from the workbook.
func (_dgdb *Workbook )Sheets ()[]Sheet {_eegbe :=[]Sheet {};for _gbcde ,_cceeb :=range _dgdb ._egabd {_beegb :=_dgdb ._fefd .Sheets .Sheet [_gbcde ];if _beegb .StateAttr ==_fge .ST_SheetStateHidden ||_beegb .StateAttr ==_fge .ST_SheetStateVeryHidden {continue ;
};_dgfc :=Sheet {_dgdb ,_beegb ,_cceeb };_eegbe =append (_eegbe ,_dgfc );};return _eegbe ;};const _gageb ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";


// LockWindow controls the locking of the workbook windows.
func (_agdad WorkbookProtection )LockWindow (b bool ){if !b {_agdad ._edcb .LockWindowsAttr =nil ;}else {_agdad ._edcb .LockWindowsAttr =_f .Bool (true );};};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_agb *Sheet )InsertRow (rowNum int )Row {_cfbd :=uint32 (rowNum );for _ ,_cbc :=range _agb .Rows (){if _cbc ._feg .RAttr !=nil &&*_cbc ._feg .RAttr >=_cfbd {*_cbc ._feg .RAttr ++;for _ ,_fbac :=range _cbc .Cells (){_agc ,_aegc :=_gb .ParseCellReference (_fbac .Reference ());
if _aegc !=nil {continue ;};_agc .RowIdx ++;_fbac ._dced .RAttr =_f .String (_agc .String ());};};};for _ ,_fafec :=range _agb .MergedCells (){_egce ,_bdd ,_aeab :=_gb .ParseRangeReference (_fafec .Reference ());if _aeab !=nil {continue ;};if int (_egce .RowIdx )>=rowNum {_egce .RowIdx ++;
};if int (_bdd .RowIdx )>=rowNum {_bdd .RowIdx ++;};_eddg :=_c .Sprintf ("\u0025\u0073\u003a%\u0073",_egce ,_bdd );_fafec .SetReference (_eddg );};return _agb .AddNumberedRow (_cfbd );};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_agee *Sheet )RemoveMergedCell (mc MergedCell ){for _bebd ,_ecdfa :=range _agee ._defb .MergeCells .MergeCell {if _ecdfa ==mc .X (){copy (_agee ._defb .MergeCells .MergeCell [_bebd :],_agee ._defb .MergeCells .MergeCell [_bebd +1:]);_agee ._defb .MergeCells .MergeCell [len (_agee ._defb .MergeCells .MergeCell )-1]=nil ;
_agee ._defb .MergeCells .MergeCell =_agee ._defb .MergeCells .MergeCell [:len (_agee ._defb .MergeCells .MergeCell )-1];};};};func (_ccaf Fills )appendFill ()Fill {_abce :=_fge .NewCT_Fill ();_ccaf ._dbgaf .Fill =append (_ccaf ._dbgaf .Fill ,_abce );_ccaf ._dbgaf .CountAttr =_f .Uint32 (uint32 (len (_ccaf ._dbgaf .Fill )));
return Fill {_abce ,_ccaf ._dbgaf };};

// AddCell adds a cell to a spreadsheet.
func (_gfcf Row )AddCell ()Cell {_fadg :=uint32 (len (_gfcf ._feg .C ));var _gef *string ;if _fadg > 0{_feae :=_f .Stringf ("\u0025\u0073\u0025\u0064",_gb .IndexToColumn (_fadg -1),_gfcf .RowNumber ());if _gfcf ._feg .C [_fadg -1].RAttr !=nil &&*_gfcf ._feg .C [_fadg -1].RAttr ==*_feae {_gef =_f .Stringf ("\u0025\u0073\u0025\u0064",_gb .IndexToColumn (_fadg ),_gfcf .RowNumber ());
};};_gaffd :=_fge .NewCT_Cell ();_gfcf ._feg .C =append (_gfcf ._feg .C ,_gaffd );if _gef ==nil {_egab :=uint32 (0);for _ ,_efee :=range _gfcf ._feg .C {if _efee .RAttr !=nil {_fbddf ,_ :=_gb .ParseCellReference (*_efee .RAttr );if _fbddf .ColumnIdx >=_egab {_egab =_fbddf .ColumnIdx +1;
};};};_gef =_f .Stringf ("\u0025\u0073\u0025\u0064",_gb .IndexToColumn (_egab ),_gfcf .RowNumber ());};_gaffd .RAttr =_gef ;return Cell {_gfcf ._dbe ,_gfcf ._gfac ,_gfcf ._feg ,_gaffd };};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_fded *Sheet )InitialView ()SheetView {if _fded ._defb .SheetViews ==nil ||len (_fded ._defb .SheetViews .SheetView )==0{return _fded .AddView ();};return SheetView {_fded ._defb .SheetViews .SheetView [0]};};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_ccce CellStyle )SetHorizontalAlignment (a _fge .ST_HorizontalAlignment ){if _ccce ._dece .Alignment ==nil {_ccce ._dece .Alignment =_fge .NewCT_CellAlignment ();};_ccce ._dece .Alignment .HorizontalAttr =a ;_ccce ._dece .ApplyAlignmentAttr =_f .Bool (true );
};

// LockStructure controls the locking of the workbook structure.
func (_gggc WorkbookProtection )LockStructure (b bool ){if !b {_gggc ._edcb .LockStructureAttr =nil ;}else {_gggc ._edcb .LockStructureAttr =_f .Bool (true );};};

// GetFont gets a Font from a cell style.
func (_cdfc CellStyle )GetFont ()*_fge .CT_Font {if _fbfe :=_cdfc ._dece .FontIdAttr ;_fbfe !=nil {_fdg :=_cdfc ._decg .StyleSheet .Fonts ();if int (*_fbfe )< len (_fdg ){return _fdg [int (*_fbfe )].X ();};};return nil ;};var _ebdc =_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0);


// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_ecdfe ConditionalFormattingRule )SetDataBar ()DataBarScale {_ecdfe .clear ();_ecdfe .SetType (_fge .ST_CfTypeDataBar );_ecdfe ._gcgc .DataBar =_fge .NewCT_DataBar ();_ecce :=DataBarScale {_ecdfe ._gcgc .DataBar };_ecce .SetShowValue (true );_ecce .SetMinLength (10);
_ecce .SetMaxLength (90);return _ecce ;};

// X returns the inner wrapped XML type.
func (_bdge ConditionalFormatting )X ()*_fge .CT_ConditionalFormatting {return _bdge ._addb };

// Type returns the type of anchor
func (_gaafc OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// X returns the inner wrapped XML type.
func (_affe DataBarScale )X ()*_fge .CT_DataBar {return _affe ._dcec };

// SetBorder applies a border to a cell style avoiding redundancy. The function checks if the given border
// already exists in the saved borders. If found, the existing border is reused; otherwise,
// the new border is added to the saved borders collection. The border is then applied to the cell style,
// affecting all styles that reference it by index.
func (_dbc CellStyle )SetBorder (b Border ){_cee :=b ._cfb .Border ;for _ ,_bef :=range _cee {if _bb .DeepEqual (_bef ,b ._ed ){b ._ed =_bef ;_dbc ._dece .BorderIdAttr =_f .Uint32 (b .Index ());_dbc ._dece .ApplyBorderAttr =_f .Bool (true );return ;};};
b ._cfb .Border =append (b ._cfb .Border ,b ._ed );b ._cfb .CountAttr =_f .Uint32 (uint32 (len (b ._cfb .Border )));_dbc ._dece .BorderIdAttr =_f .Uint32 (b .Index ());_dbc ._dece .ApplyBorderAttr =_f .Bool (true );};

// GetFilename returns the filename of the context's workbook.
func (_gff *evalContext )GetFilename ()string {return _gff ._dgf ._fgca .GetFilename ()};

// ExtractText returns text from the sheet as a SheetText object.
func (_beaa *Sheet )ExtractText ()*SheetText {_fcbe :=[]CellText {};for _ ,_cba :=range _beaa .Rows (){for _ ,_efa :=range _cba .Cells (){if !_efa .IsEmpty (){if _bdfd :=_efa .GetFormattedValue ();_bdfd !=""{_fcbe =append (_fcbe ,CellText {Text :_bdfd ,Cell :_efa });
};};};};return &SheetText {Cells :_fcbe };};var _cfbf =false ;const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// AddSheet adds a new sheet to a workbook.
func (_edfdc *Workbook )AddSheet ()Sheet {_acc :=_fge .NewCT_Sheet ();_acc .SheetIdAttr =1;for _ ,_gbge :=range _edfdc ._fefd .Sheets .Sheet {if _acc .SheetIdAttr <=_gbge .SheetIdAttr {_acc .SheetIdAttr =_gbge .SheetIdAttr +1;};};_edfdc ._fefd .Sheets .Sheet =append (_edfdc ._fefd .Sheets .Sheet ,_acc );
_acc .NameAttr =_c .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_acc .SheetIdAttr );_dafa :=_fge .NewWorksheet ();_dafa .Dimension =_fge .NewCT_SheetDimension ();_dafa .Dimension .RefAttr ="\u0041\u0031";_edfdc ._egabd =append (_edfdc ._egabd ,_dafa );
_caace :=_fa .NewRelationships ();_edfdc ._bbea =append (_edfdc ._bbea ,_caace );_dafa .SheetData =_fge .NewCT_SheetData ();_edfdc ._aacf =append (_edfdc ._aacf ,nil );_dggb :=_f .DocTypeSpreadsheet ;_gbaa :=_edfdc ._cbag .AddAutoRelationship (_dggb ,_f .OfficeDocumentType ,len (_edfdc ._fefd .Sheets .Sheet ),_f .WorksheetType );
_acc .IdAttr =_gbaa .ID ();_edfdc .ContentTypes .AddOverride (_f .AbsoluteFilename (_dggb ,_f .WorksheetContentType ,len (_edfdc ._fefd .Sheets .Sheet )),_f .WorksheetContentType );return Sheet {_edfdc ,_acc ,_dafa };};

// MoveTo is a no-op.
func (_fgfb AbsoluteAnchor )MoveTo (x ,y int32 ){};

// SetWidth sets the width of the anchored object.
func (_fbc OneCellAnchor )SetWidth (w _ae .Distance ){_fbc ._gfgaf .Ext .CxAttr =int64 (w /_ae .EMU )};

// X returns the inner wrapped XML type.
func (_gfbe Comment )X ()*_fge .CT_Comment {return _gfbe ._gade };

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_gfee *Workbook )Uses1904Dates ()bool {if _gfee ._fefd .WorkbookPr ==nil ||_gfee ._fefd .WorkbookPr .Date1904Attr ==nil {return false ;};return *_gfee ._fefd .WorkbookPr .Date1904Attr ;};func (_bbbf *Sheet )addNumberedRowFast (_cca uint32 )Row {_bfb :=_fge .NewCT_Row ();
_bfb .RAttr =_f .Uint32 (_cca );_bbbf ._defb .SheetData .Row =append (_bbbf ._defb .SheetData .Row ,_bfb );return Row {_bbbf ._fgca ,_bbbf ,_bfb };};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_cgff Drawing )AddImage (img _fa .ImageRef ,at AnchorType )Anchor {_face :=0;for _cdda ,_bdb :=range _cgff ._dfbc .Images {if _bdb ==img {_face =_cdda +1;break ;};};var _adgb string ;for _gfbc ,_aead :=range _cgff ._dfbc ._beed {if _aead ==_cgff ._caeb {_fea :=_c .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_face ,img .Format ());
_baed :=_cgff ._dfbc ._gfgab [_gfbc ].AddRelationship (_fea ,_f .ImageType );_adgb =_baed .ID ();break ;};};var _fdabf Anchor ;var _ccbg *_fgf .CT_Picture ;switch at {case AnchorTypeAbsolute :_efe :=_egeb ();_cgff ._caeb .EG_Anchor =append (_cgff ._caeb .EG_Anchor ,&_fgf .EG_Anchor {AnchorChoice :&_fgf .EG_AnchorChoice {AbsoluteAnchor :_efe }});
_efe .ObjectChoicesChoice =&_fgf .EG_ObjectChoicesChoice {};_efe .ObjectChoicesChoice .Pic =_fgf .NewCT_Picture ();_efe .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);_efe .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_ccbg =_efe .ObjectChoicesChoice .Pic ;
_fdabf =AbsoluteAnchor {_efe };case AnchorTypeOneCell :_fcb :=_gdd ();_cgff ._caeb .EG_Anchor =append (_cgff ._caeb .EG_Anchor ,&_fgf .EG_Anchor {AnchorChoice :&_fgf .EG_AnchorChoice {OneCellAnchor :_fcb }});_fcb .ObjectChoicesChoice =&_fgf .EG_ObjectChoicesChoice {};
_fcb .ObjectChoicesChoice .Pic =_fgf .NewCT_Picture ();_ccbg =_fcb .ObjectChoicesChoice .Pic ;_fdabf =OneCellAnchor {_fcb };case AnchorTypeTwoCell :_dbga :=_def ();_cgff ._caeb .EG_Anchor =append (_cgff ._caeb .EG_Anchor ,&_fgf .EG_Anchor {AnchorChoice :&_fgf .EG_AnchorChoice {TwoCellAnchor :_dbga }});
_dbga .ObjectChoicesChoice =&_fgf .EG_ObjectChoicesChoice {};_dbga .ObjectChoicesChoice .Pic =_fgf .NewCT_Picture ();_ccbg =_dbga .ObjectChoicesChoice .Pic ;_fdabf =TwoCellAnchor {_dbga };};_ccbg .NvPicPr .CNvPr .IdAttr =uint32 (len (_cgff ._caeb .EG_Anchor ));
_ccbg .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_ccbg .BlipFill .Blip =_cg .NewCT_Blip ();_ccbg .BlipFill .Blip .EmbedAttr =_f .String (_adgb );_ccbg .BlipFill .FillModePropertiesChoice .Stretch =_cg .NewCT_StretchInfoProperties ();_ccbg .SpPr =_cg .NewCT_ShapeProperties ();
_ccbg .SpPr .Xfrm =_cg .NewCT_Transform2D ();_ccbg .SpPr .Xfrm .Off =_cg .NewCT_Point2D ();_ccbg .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);_ccbg .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_ccbg .SpPr .Xfrm .Ext =_cg .NewCT_PositiveSize2D ();
_ccbg .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_ae .Pixel72 )/_ae .EMU );_ccbg .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_ae .Pixel72 )/_ae .EMU );_ccbg .SpPr .GeometryChoice .PrstGeom =_cg .NewCT_PresetGeometry2D ();_ccbg .SpPr .GeometryChoice .PrstGeom .PrstAttr =_cg .ST_ShapeTypeRect ;
_ccbg .SpPr .Ln =_cg .NewCT_LineProperties ();_ccbg .SpPr .Ln .LineFillPropertiesChoice .NoFill =_cg .NewCT_NoFillProperties ();return _fdabf ;};

// SetHeight sets the height of the anchored object.
func (_eag AbsoluteAnchor )SetHeight (h _ae .Distance ){_eag ._fcc .Ext .CyAttr =int64 (h /_ae .EMU )};

// HasFormula returns true if the cell contains formula.
func (_edad *evalContext )HasFormula (cellRef string )bool {return _edad ._dgf .Cell (cellRef ).HasFormula ();};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_gebgc *Workbook )AddDefinedName (name ,ref string )DefinedName {if _gebgc ._fefd .DefinedNames ==nil {_gebgc ._fefd .DefinedNames =_fge .NewCT_DefinedNames ();};_ebbac :=_fge .NewCT_DefinedName ();_ebbac .Content =ref ;_ebbac .NameAttr =name ;_gebgc ._fefd .DefinedNames .DefinedName =append (_gebgc ._fefd .DefinedNames .DefinedName ,_ebbac );
return DefinedName {_ebbac };};

// SetPriority sets the rule priority
func (_fbd ConditionalFormattingRule )SetPriority (p int32 ){_fbd ._gcgc .PriorityAttr =p };

// SetFont applies a font to a cell style avoiding redundancy. The function checks if the given font
// already exists in the saved fonts. If found, the existing font is reused; otherwise,
// the new font is added to the saved fonts collection. The font is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gbc CellStyle )SetFont (f Font ){_gbd :=f ._cfg .Fonts .Font ;for _ ,_aaa :=range _gbd {if _bb .DeepEqual (_aaa ,f ._caed ){f ._caed =_aaa ;_gbc ._dece .FontIdAttr =_f .Uint32 (f .Index ());_gbc ._dece .ApplyFontAttr =_f .Bool (true );return ;};
};f ._cfg .Fonts .Font =append (f ._cfg .Fonts .Font ,f ._caed );f ._cfg .Fonts .CountAttr =_f .Uint32 (uint32 (len (f ._cfg .Fonts .Font )));_gbc ._dece .FontIdAttr =_f .Uint32 (f .Index ());_gbc ._dece .ApplyFontAttr =_f .Bool (true );};

// SetReference sets the regin of cells that the merged cell applies to.
func (_fccb MergedCell )SetReference (ref string ){_fccb ._dbac .RefAttr =ref };

// ClearFill clears any fill configuration from the cell style.
func (_bbb CellStyle )ClearFill (){_bbb ._dece .FillIdAttr =nil ;_bbb ._dece .ApplyFillAttr =nil };

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_ffgg TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_ffgg ._efed .To }};

// Type returns the type of the rule
func (_gce ConditionalFormattingRule )Type ()_fge .ST_CfType {return _gce ._gcgc .TypeAttr };

// AddView adds a sheet view.
func (_fbbb *Sheet )AddView ()SheetView {if _fbbb ._defb .SheetViews ==nil {_fbbb ._defb .SheetViews =_fge .NewCT_SheetViews ();};_dgbf :=_fge .NewCT_SheetView ();_fbbb ._defb .SheetViews .SheetView =append (_fbbb ._defb .SheetViews .SheetView ,_dgbf );
return SheetView {_dgbf };};

// X returns the inner wrapped XML type.
func (_bbg Cell )X ()*_fge .CT_Cell {return _bbg ._dced };

// X returns the inner wrapped XML type.
func (_ebf RichTextRun )X ()*_fge .CT_RElt {return _ebf ._gbe };

// SaveToFile writes the workbook out to a file.
func (_daec *Workbook )SaveToFile (path string )error {_agff ,_cgab :=_abd .Create (path );if _cgab !=nil {return _cgab ;};defer _agff .Close ();return _daec .Save (_agff );};

// X returns the inner wrapped XML type.
func (_abfa WorkbookProtection )X ()*_fge .CT_WorkbookProtection {return _abfa ._edcb };func _gdg (_eedd _gd .Time )_gd .Time {_eedd =_eedd .Local ();return _gd .Date (_eedd .Year (),_eedd .Month (),_eedd .Day (),_eedd .Hour (),_eedd .Minute (),_eedd .Second (),_eedd .Nanosecond (),_gd .UTC );
};

// X returns the inner wrapped XML type.
func (_deb RichText )X ()*_fge .CT_Rst {return _deb ._faae };func (_ccdfc PatternFill )X ()*_fge .CT_PatternFill {return _ccdfc ._acgb };func _bbfe (_fdge *Sheet )*evalContext {return &evalContext {_dgf :_fdge ,_gdgf :make (map[string ]struct{})};};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gagff *Sheet )RecalculateFormulas (){_gbda :=_bac .NewEvaluator ();_bfce :=_gagff .FormulaContext ();for _ ,_bebac :=range _gagff .Rows (){for _ ,_fcd :=range _bebac .Cells (){if _fcd .X ().F !=nil {_ddaa :=_fcd .X ().F .Content ;if _fcd .X ().F .TAttr ==_fge .ST_CellFormulaTypeShared &&len (_ddaa )==0{continue ;
};_aaeg :=_gbda .Eval (_bfce ,_ddaa ).AsString ();if _aaeg .Type ==_bac .ResultTypeError {_cf .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_ddaa ,_aaeg .ErrorMessage );
_fcd .X ().V =nil ;}else {if _aaeg .Type ==_bac .ResultTypeNumber {_fcd .X ().TAttr =_fge .ST_CellTypeN ;}else {_fcd .X ().TAttr =_fge .ST_CellTypeInlineStr ;};_fcd .X ().V =_f .String (_aaeg .Value ());if _fcd .X ().F .TAttr ==_fge .ST_CellFormulaTypeArray {if _aaeg .Type ==_bac .ResultTypeArray {_gagff .setArray (_fcd .Reference (),_aaeg );
}else if _aaeg .Type ==_bac .ResultTypeList {_gagff .setList (_fcd .Reference (),_aaeg );};}else if _fcd .X ().F .TAttr ==_fge .ST_CellFormulaTypeShared &&_fcd .X ().F .RefAttr !=nil {_debf ,_ddac ,_bccd :=_gb .ParseRangeReference (*_fcd .X ().F .RefAttr );
if _bccd !=nil {_cf .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_bccd );continue ;};
_gagff .setShared (_fcd .Reference (),_debf ,_ddac ,_ddaa );};};};};};};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_ddd Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_ddd .SetNumber (v );_ddd .SetStyle (_ddd ._ef .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// SetError sets the cell type to error and the value to the given error message.
func (_dead Cell )SetError (msg string ){_dead .clearValue ();_dead ._dced .V =_f .String (msg );_dead ._dced .TAttr =_fge .ST_CellTypeE ;};

// X returns the inner wrapped XML type.
func (_fgb Font )X ()*_fge .CT_Font {return _fgb ._caed };func (_cac *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _cac .getAllCellsInFormulaArrays (false );};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_cabfb *Sheet )AddRow ()Row {_bgad :=uint32 (0);_bbdg :=uint32 (len (_cabfb ._defb .SheetData .Row ));if _bbdg > 0&&_cabfb ._defb .SheetData .Row [_bbdg -1].RAttr !=nil &&*_cabfb ._defb .SheetData .Row [_bbdg -1].RAttr ==_bbdg {return _cabfb .addNumberedRowFast (_bbdg +1);
};for _ ,_eadd :=range _cabfb ._defb .SheetData .Row {if _eadd .RAttr !=nil &&*_eadd .RAttr > _bgad {_bgad =*_eadd .RAttr ;};};return _cabfb .AddNumberedRow (_bgad +1);};func (_beddd SheetView )ensurePane (){if _beddd ._gfdfg .Pane ==nil {_beddd ._gfdfg .Pane =_fge .NewCT_Pane ();
_beddd ._gfdfg .Pane .ActivePaneAttr =_fge .ST_PaneBottomLeft ;};};

// Themes returns the array of workbook dml.Theme.
func (_ebeg *Workbook )Themes ()[]*_cg .Theme {return _ebeg ._edgb };

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_ecfg SheetView )SetZoom (pct uint32 ){_ecfg ._gfdfg .ZoomScaleAttr =&pct };

// Fonts returns the list of fonts defined in the stylesheet.
func (_aecf StyleSheet )Fonts ()[]Font {_fcgg :=[]Font {};for _ ,_ddga :=range _aecf ._ccde .Fonts .Font {_fcgg =append (_fcgg ,Font {_ddga ,_aecf ._ccde });};return _fcgg ;};var _ecfb []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};
func (_gaaf *evalContext )NamedRange (ref string )_bac .Reference {for _ ,_gfef :=range _gaaf ._dgf ._fgca .DefinedNames (){if _gfef .Name ()==ref {return _bac .MakeRangeReference (_gfef .Content ());};};for _ ,_cfc :=range _gaaf ._dgf ._fgca .Tables (){if _cfc .Name ()==ref {return _bac .MakeRangeReference (_c .Sprintf ("\u0025\u0073\u0021%\u0073",_gaaf ._dgf .Name (),_cfc .Reference ()));
};};return _bac .ReferenceInvalid ;};type SheetProtection struct{_bbaf *_fge .CT_SheetProtection };

// CellMarker represents a cell position
type CellMarker struct{_fdd *_fgf .CT_Marker };func (_dda ConditionalFormattingRule )clear (){_dda ._gcgc .OperatorAttr =_fge .ST_ConditionalFormattingOperatorUnset ;_dda ._gcgc .ColorScale =nil ;_dda ._gcgc .IconSet =nil ;_dda ._gcgc .Formula =nil ;};


// SetWidthCells is a no-op.
func (_cga AbsoluteAnchor )SetWidthCells (int32 ){};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_ffa Border )InitializeDefaults (){_ffa ._ed .Left =_fge .NewCT_BorderPr ();_ffa ._ed .Bottom =_fge .NewCT_BorderPr ();_ffa ._ed .Right =_fge .NewCT_BorderPr ();_ffa ._ed .Top =_fge .NewCT_BorderPr ();_ffa ._ed .Diagonal =_fge .NewCT_BorderPr ();
};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_bcg DataValidationCompare )SetValue (v string ){_bcg ._ccb .Formula1 =&v };

// Index returns the index of the differential style.
func (_afde DifferentialStyle )Index ()uint32 {for _aec ,_ceagf :=range _afde ._eefe .Dxf {if _afde ._ceag ==_ceagf {return uint32 (_aec );};};return 0;};

// BottomRight is a no-op.
func (_de AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// SetRow set the row of the cell marker.
func (_gde CellMarker )SetRow (row int32 ){_gde ._fdd .Row =row };

// X returns the inner wrapped XML type.
func (_gfe ConditionalFormattingRule )X ()*_fge .CT_CfRule {return _gfe ._gcgc };func (_ggcb StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_edag :=range _ggcb ._ccde .NumFmts .NumFmt {if _edag .NumFmtIdAttr ==id {return NumberFormat {_ggcb ._eafa ,_edag };
};};return NumberFormat {};};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_cedef *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_beff :=-1;for _aeafd ,_eebc :=range _cedef .Sheets (){if name ==_eebc .Name (){_beff =_aeafd ;break ;};};if _beff ==-1{return Sheet {},ErrorNotFound ;};return _cedef .CopySheet (_beff ,copiedSheetName );
};

// SetWidth controls the width of a column.
func (_acd Column )SetWidth (w _ae .Distance ){_acd ._bgba .WidthAttr =_f .Float64 (float64 (w /_ae .Character ));};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_gbe *_fge .CT_RElt };

// Reference returns the region of cells that are merged.
func (_cabf MergedCell )Reference ()string {return _cabf ._dbac .RefAttr };

// AddBorder creates a new empty Border style.
func (_ddfe StyleSheet )AddBorder ()Border {_cagg :=_fge .NewCT_Border ();return Border {_cagg ,_ddfe ._ccde .Borders };};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_gfgaf *_fgf .CT_OneCellAnchor };

// ExtractText returns text from the workbook as a WorkbookText object.
func (_deca *Workbook )ExtractText ()*WorkbookText {_ecca :=[]*SheetText {};for _ ,_bfd :=range _deca .Sheets (){_ecca =append (_ecca ,&SheetText {Cells :_bfd .ExtractText ().Cells });};return &WorkbookText {Sheets :_ecca };};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_gbac Comments )AddComment (cellRef string ,author string )RichText {_cgdf :=_fge .NewCT_Comment ();_gbac ._dfef .CommentList .Comment =append (_gbac ._dfef .CommentList .Comment ,_cgdf );_cgdf .RefAttr =cellRef ;_cgdf .AuthorIdAttr =_gbac .getOrCreateAuthor (author );
_cgdf .Text =_fge .NewCT_Rst ();return RichText {_cgdf .Text };};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_ebbgc *Workbook )SetActiveSheetIndex (idx uint32 ){if _ebbgc ._fefd .BookViews ==nil {_ebbgc ._fefd .BookViews =_fge .NewCT_BookViews ();};if len (_ebbgc ._fefd .BookViews .WorkbookView )==0{_ebbgc ._fefd .BookViews .WorkbookView =append (_ebbgc ._fefd .BookViews .WorkbookView ,_fge .NewCT_BookView ());
};_ebbgc ._fefd .BookViews .WorkbookView [0].ActiveTabAttr =_f .Uint32 (idx );};func _egeb ()*_fgf .CT_AbsoluteAnchor {_fddgd :=_fgf .NewCT_AbsoluteAnchor ();return _fddgd };

// SetWrapped configures the cell to wrap text.
func (_bfc CellStyle )SetWrapped (b bool ){if _bfc ._dece .Alignment ==nil {_bfc ._dece .Alignment =_fge .NewCT_CellAlignment ();};if !b {_bfc ._dece .Alignment .WrapTextAttr =nil ;}else {_bfc ._dece .Alignment .WrapTextAttr =_f .Bool (true );_bfc ._dece .ApplyAlignmentAttr =_f .Bool (true );
};};func (_cad Cell )getRawSortValue ()(string ,bool ){if _cad .HasFormula (){_bde :=_cad .GetCachedFormulaResult ();return _bde ,_fff .IsNumber (_bde );};_caa ,_ :=_cad .GetRawValue ();return _caa ,_fff .IsNumber (_caa );};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// SetXSplit sets the column split point
func (_dcda SheetView )SetXSplit (v float64 ){_dcda .ensurePane ();_dcda ._gfdfg .Pane .XSplitAttr =_f .Float64 (v );};func (_bcbc PatternFill )ClearBgColor (){_bcbc ._acgb .BgColor =nil };

// AnchorType is the type of anchor.
type AnchorType byte ;const _ecff ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// SetNumber sets the cell type to number, and the value to the given number
func (_fga Cell )SetNumber (v float64 ){_fga .clearValue ();if _gdf .IsNaN (v )||_gdf .IsInf (v ,0){_fga ._dced .TAttr =_fge .ST_CellTypeE ;_fga ._dced .V =_f .String ("\u0023\u004e\u0055M\u0021");return ;};_fga ._dced .TAttr =_fge .ST_CellTypeN ;_fga ._dced .V =_f .String (_fg .FormatFloat (v ,'f',-1,64));
};

// GetEpoch returns a workbook's time epoch.
func (_fadde *evalContext )GetEpoch ()_gd .Time {return _fadde ._dgf ._fgca .Epoch ()};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_dcfc *Sheet )SetFrozen (firstRow ,firstCol bool ){_dcfc ._defb .SheetViews =nil ;_febc :=_dcfc .AddView ();_febc .SetState (_fge .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_febc .SetYSplit (1);_febc .SetXSplit (1);_febc .SetTopLeft ("\u0042\u0032");
case firstRow :_febc .SetYSplit (1);_febc .SetTopLeft ("\u0041\u0032");case firstCol :_febc .SetXSplit (1);_febc .SetTopLeft ("\u0042\u0031");};};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_gedd *Workbook )ClearCachedFormulaResults (){for _ ,_acde :=range _gedd .Sheets (){_acde .ClearCachedFormulaResults ();};};func (_gdc Border )SetBottom (style _fge .ST_BorderStyle ,c _cea .Color ){if _gdc ._ed .Bottom ==nil {_gdc ._ed .Bottom =_fge .NewCT_BorderPr ();
};_gdc ._ed .Bottom .Color =_fge .NewCT_Color ();_gdc ._ed .Bottom .Color .RgbAttr =c .AsRGBAString ();_gdc ._ed .Bottom .StyleAttr =style ;};func (_cgfg StandardFormat )String ()string {switch {case 0<=_cgfg &&_cgfg <=4:return _cdfa [_dade [_cgfg ]:_dade [_cgfg +1]];
case 9<=_cgfg &&_cgfg <=22:_cgfg -=9;return _ace [_adef [_cgfg ]:_adef [_cgfg +1]];case 37<=_cgfg &&_cgfg <=40:_cgfg -=37;return _fgaf [_cbgd [_cgfg ]:_cbgd [_cgfg +1]];case 45<=_cgfg &&_cgfg <=49:_cgfg -=45;return _cdcf [_dcdg [_cgfg ]:_dcdg [_cgfg +1]];
default:return _c .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_cgfg );};};

// IsHidden returns whether the row is hidden or not.
func (_beba Row )IsHidden ()bool {return _beba ._feg .HiddenAttr !=nil &&*_beba ._feg .HiddenAttr };func (_cbe Font )SetColor (c _cea .Color ){_gcaa :=_fge .NewCT_Color ();_acg :="\u0066\u0066"+*c .AsRGBString ();_gcaa .RgbAttr =&_acg ;_adf :=false ;for _cffd ,_agfb :=range _cbe ._caed .FontChoice {if _agfb .Color !=nil {_cbe ._caed .FontChoice [_cffd ].Color =_gcaa ;
_adf =true ;};};if !_adf {_cbe ._caed .FontChoice =append (_cbe ._caed .FontChoice ,&_fge .CT_FontChoice {Color :_gcaa });};};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_aeec CellStyle )NumberFormat ()uint32 {if _aeec ._dece .NumFmtIdAttr ==nil {return 0;};return *_aeec ._dece .NumFmtIdAttr ;};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_bba Cell )SetInlineString (s string ){_bba .clearValue ();_bba ._dced .Is =_fge .NewCT_Rst ();_bba ._dced .Is .T =_f .String (s );_bba ._dced .TAttr =_fge .ST_CellTypeInlineStr ;};

// SetPassword sets the password hash to a hash of the input password.
func (_fcebe SheetProtection )SetPassword (pw string ){_fcebe .SetPasswordHash (PasswordHash (pw ))};

// Reference returns the table reference (the cells within the table)
func (_gabe Table )Reference ()string {return _gabe ._ecgbf .RefAttr };

// X returns the inner wrapped XML type.
func (_bbdd DifferentialStyle )X ()*_fge .CT_Dxf {return _bbdd ._ceag };

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_ceea *_fge .CT_ColorScale };

// IsSheetLocked returns whether the sheet is locked.
func (_gfdd SheetProtection )IsSheetLocked ()bool {return _gfdd ._bbaf .SheetAttr !=nil &&*_gfdd ._bbaf .SheetAttr ;};func (_fbdd DataValidation )SetList ()DataValidationList {_fbdd .clear ();_fbdd ._ebga .TypeAttr =_fge .ST_DataValidationTypeList ;_fbdd ._ebga .OperatorAttr =_fge .ST_DataValidationOperatorEqual ;
return DataValidationList {_fbdd ._ebga };};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_bebaa *Sheet )Cell (cellRef string )Cell {_bcd ,_fdgd :=_gb .ParseCellReference (cellRef );if _fdgd !=nil {_cf .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_fdgd );
return _bebaa .AddRow ().AddCell ();};return _bebaa .Row (_bcd .RowIdx ).Cell (_bcd .Column );};

// SetPassword sets the password hash to a hash of the input password.
func (_ddce WorkbookProtection )SetPassword (pw string ){_ddce .SetPasswordHash (PasswordHash (pw ))};type MergedCell struct{_aefc *Workbook ;_edfd *Sheet ;_dbac *_fge .CT_MergeCell ;};const (_cdfa ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";
_ace ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";
_fgaf ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";
_cdcf ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";
);func _gdd ()*_fgf .CT_OneCellAnchor {_bcfcf :=_fgf .NewCT_OneCellAnchor ();return _bcfcf };

// Text returns text from the sheet as one string separated with line breaks.
func (_ade *SheetText )Text ()string {_dfda :=_fc .NewBuffer ([]byte {});for _ ,_cbg :=range _ade .Cells {if _cbg .Text !=""{_dfda .WriteString (_cbg .Text );_dfda .WriteString ("\u000a");};};return _dfda .String ();};

// SetFormat sets the number format code.
func (_aaed NumberFormat )SetFormat (f string ){_aaed ._gage .FormatCodeAttr =f };

// SetContent sets the defined name content.
func (_cabd DefinedName )SetContent (s string ){_cabd ._cgaa .Content =s };

// SetShowValue controls if the cell value is displayed.
func (_dbgc DataBarScale )SetShowValue (b bool ){_dbgc ._dcec .ShowValueAttr =_f .Bool (b )};

// SetColOffset sets the column offset of the two cell anchor.
func (_eacg TwoCellAnchor )SetColOffset (m _ae .Distance ){_afffb :=m -_eacg .TopLeft ().ColOffset ();_eacg .TopLeft ().SetColOffset (m );_eacg .BottomRight ().SetColOffset (_eacg .BottomRight ().ColOffset ()+_afffb );};

// SetColor sets the text color.
func (_edcg RichTextRun )SetColor (c _cea .Color ){_edcg .ensureRpr ();_cbaa :="\u0066\u0066"+*c .AsRGBString ();for _ ,_geeg :=range _edcg ._gbe .RPr .RPrEltChoice {if _geeg .Color !=nil {_geeg .Color .RgbAttr =&_cbaa ;return ;};};_edcg ._gbe .RPr .RPrEltChoice =append (_edcg ._gbe .RPr .RPrEltChoice ,&_fge .CT_RPrEltChoice {Color :&_fge .CT_Color {RgbAttr :&_cbaa }});
};

// SetPasswordHash sets the password hash to the input.
func (_ccfa WorkbookProtection )SetPasswordHash (pwHash string ){_ccfa ._edcb .WorkbookPasswordAttr =_f .String (pwHash );};func (_cgcb Font )Index ()uint32 {for _fbbg ,_dbfg :=range _cgcb ._cfg .Fonts .Font {if _cgcb ._caed ==_dbfg {return uint32 (_fbbg );
};};return 0;};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_ecdfee DataValidationList )SetValues (values []string ){_ecdfee ._cddg .Formula1 =_f .String ("\u0022"+_d .Join (values ,"\u002c")+"\u0022");_ecdfee ._cddg .Formula2 =_f .String ("\u0030");};

// AddString adds a string to the shared string cache.
func (_caad SharedStrings )AddString (v string )int {if _agfe ,_dgcb :=_caad ._cbdf [v ];_dgcb {return _agfe ;};_debe :=_fge .NewCT_Rst ();_debe .T =_f .String (v );_caad ._ebge .Si =append (_caad ._ebge .Si ,_debe );_gadga :=len (_caad ._ebge .Si )-1;
_caad ._cbdf [v ]=_gadga ;_caad ._ebge .CountAttr =_f .Uint32 (uint32 (len (_caad ._ebge .Si )));_caad ._ebge .UniqueCountAttr =_caad ._ebge .CountAttr ;return _gadga ;};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_caed *_fge .CT_Font ;_cfg *_fge .StyleSheet ;};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_dbfe *Workbook )RemoveSheet (ind int )error {if _dbfe .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_becf :=range _dbfe ._cbag .Relationships (){if _becf .ID ()==_dbfe ._fefd .Sheets .Sheet [ind ].IdAttr {_dbfe ._cbag .Remove (_becf );break ;
};};_dbfe .ContentTypes .RemoveOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1));copy (_dbfe ._egabd [ind :],_dbfe ._egabd [ind +1:]);_dbfe ._egabd =_dbfe ._egabd [:len (_dbfe ._egabd )-1];_deeaa :=_dbfe ._fefd .Sheets .Sheet [ind ];
copy (_dbfe ._fefd .Sheets .Sheet [ind :],_dbfe ._fefd .Sheets .Sheet [ind +1:]);_dbfe ._fefd .Sheets .Sheet =_dbfe ._fefd .Sheets .Sheet [:len (_dbfe ._fefd .Sheets .Sheet )-1];for _addab :=range _dbfe ._fefd .Sheets .Sheet {if _dbfe ._fefd .Sheets .Sheet [_addab ].SheetIdAttr > _deeaa .SheetIdAttr {_dbfe ._fefd .Sheets .Sheet [_addab ].SheetIdAttr --;
};};copy (_dbfe ._bbea [ind :],_dbfe ._bbea [ind +1:]);_dbfe ._bbea =_dbfe ._bbea [:len (_dbfe ._bbea )-1];copy (_dbfe ._aacf [ind :],_dbfe ._aacf [ind +1:]);_dbfe ._aacf =_dbfe ._aacf [:len (_dbfe ._aacf )-1];return nil ;};

// DataValidation controls cell validation
type DataValidation struct{_ebga *_fge .CT_DataValidation };func (_geba Cell )setLocked (_cdf bool ){_gebb :=_geba ._dced .SAttr ;if _gebb !=nil {_ecdc :=_geba ._ef .StyleSheet .GetCellStyle (*_gebb );if _ecdc ._dece .Protection ==nil {_ecdc ._dece .Protection =_fge .NewCT_CellProtection ();
};_ecdc ._dece .Protection .LockedAttr =&_cdf ;};};

// MergedCells returns the merged cell regions within the sheet.
func (_gcge *Sheet )MergedCells ()[]MergedCell {if _gcge ._defb .MergeCells ==nil {return nil ;};_cgedb :=[]MergedCell {};for _ ,_agggb :=range _gcge ._defb .MergeCells .MergeCell {_cgedb =append (_cgedb ,MergedCell {_gcge ._fgca ,_gcge ,_agggb });};return _cgedb ;
};func NewFills ()Fills {return Fills {_fge .NewCT_Fills ()}};

// IsBool returns true if the cell is a boolean type cell.
func (_bee Cell )IsBool ()bool {return _bee ._dced .TAttr ==_fge .ST_CellTypeB };func (_ffcg Fills )X ()*_fge .CT_Fills {return _ffcg ._dbgaf };

// SetHidden hides or unhides the row
func (_eddd Row )SetHidden (hidden bool ){if !hidden {_eddd ._feg .HiddenAttr =nil ;}else {_eddd ._feg .HiddenAttr =_f .Bool (true );};};

// SetIcons sets the icon set to use for display.
func (_dad IconScale )SetIcons (t _fge .ST_IconSetType ){_dad ._gbffb .IconSetAttr =t };

// SetDateWithStyle sets a date with the default date style applied.
func (_bcce Cell )SetDateWithStyle (d _gd .Time ){_bcce .SetDate (d );for _ ,_dff :=range _bcce ._ef .StyleSheet .CellStyles (){if _dff .HasNumberFormat ()&&_dff .NumberFormat ()==uint32 (StandardFormatDate ){_bcce .SetStyle (_dff );return ;};};_fcg :=_bcce ._ef .StyleSheet .AddCellStyle ();
_fcg .SetNumberFormatStandard (StandardFormatDate );_bcce .SetStyle (_fcg );};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_daf CellStyle )SetVerticalAlignment (a _fge .ST_VerticalAlignment ){if _daf ._dece .Alignment ==nil {_daf ._dece .Alignment =_fge .NewCT_CellAlignment ();};_daf ._dece .ApplyAlignmentAttr =_f .Bool (true );_daf ._dece .Alignment .VerticalAttr =a ;
};

// SetColOffset sets a column offset in absolute distance.
func (_dcb CellMarker )SetColOffset (m _ae .Distance ){_dcb ._fdd .ColOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ae .EMU ));};func (_gbf ConditionalFormattingRule )InitializeDefaults (){_gbf .SetType (_fge .ST_CfTypeCellIs );_gbf .SetOperator (_fge .ST_ConditionalFormattingOperatorGreaterThan );
_gbf .SetPriority (1);};