//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_bf "bytes";_b "fmt";_f "github.com/unidoc/unioffice";_d "io";_a "math";_bb "strconv";_eb "strings";_e "time";);func _caa (_bae float64 )string {_fgb :=_bb .FormatFloat (_bae ,'E',-1,64);_fcb :=_bb .FormatFloat (_bae ,'E',5,64);if len (_fgb )< len (_fcb ){return _bb .FormatFloat (_bae ,'E',2,64);};return _fcb ;};

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _ddf (_aec []byte )[]byte {for _dgd :=len (_aec )-1;_dgd > 0;_dgd --{if _aec [_dgd ]=='9'+1{_aec [_dgd ]='0';if _aec [_dgd -1]=='.'{_dgd --;};_aec [_dgd -1]++;};};if _aec [0]=='9'+1{_aec [0]='0';copy (_aec [1:],_aec [0:]);_aec [0]='1';};return _aec ;};const _be =1e-10;func _fag (_beg []byte )[]byte {_fae :=len (_beg );_adag :=false ;_bff :=false ;for _bga :=len (_beg )-1;_bga >=0;_bga --{if _beg [_bga ]=='0'&&!_bff &&!_adag {_fae =_bga ;}else if _beg [_bga ]=='.'{_adag =true ;}else {_bff =true ;};};if _adag &&_bff {if _beg [_fae -1]=='.'{_fae --;};return _beg [0:_fae ];};return _beg ;};var _bc =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};const _fdcb int =0;const _cca int =0;func _ced (_bec []byte )[]byte {for _faf :=0;_faf < len (_bec )/2;_faf ++{_gf :=len (_bec )-1-_faf ;_bec [_faf ],_bec [_gf ]=_bec [_gf ],_bec [_faf ];};return _bec ;};func _bcfg (_ebfd _e .Time )_e .Time {_ebfd =_ebfd .UTC ();return _e .Date (_ebfd .Year (),_ebfd .Month (),_ebfd .Day (),_ebfd .Hour (),_ebfd .Minute (),_ebfd .Second (),_ebfd .Nanosecond (),_e .Local );};func _bgc (_fagd _e .Time ,_cae float64 ,_cba string )[]byte {_aggf :=[]byte {};_bfg :=0;for _ceb :=0;_ceb < len (_cba );_ceb ++{var _bgg string ;if _cba [_ceb ]==':'{_bgg =string (_cba [_bfg :_ceb ]);_bfg =_ceb +1;}else if _ceb ==len (_cba )-1{_bgg =string (_cba [_bfg :_ceb +1]);}else {continue ;};switch _bgg {case "\u0064":_aggf =_fagd .AppendFormat (_aggf ,"\u0032");case "\u0068":_aggf =_fagd .AppendFormat (_aggf ,"\u0033");case "\u0068\u0068":_aggf =_fagd .AppendFormat (_aggf ,"\u0031\u0035");case "\u006d":_aggf =_fagd .AppendFormat (_aggf ,"\u0034");case "\u006d\u006d":_aggf =_fagd .AppendFormat (_aggf ,"\u0030\u0034");case "\u0073":_aggf =_fagd .Round (_e .Second ).AppendFormat (_aggf ,"\u0035");case "\u0073\u002e\u0030":_aggf =_fagd .Round (_e .Second /10).AppendFormat (_aggf ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_aggf =_fagd .Round (_e .Second /100).AppendFormat (_aggf ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_aggf =_fagd .Round (_e .Second /1000).AppendFormat (_aggf ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_aggf =_fagd .Round (_e .Second ).AppendFormat (_aggf ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_aggf =_fagd .Round (_e .Second /10).AppendFormat (_aggf ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_aggf =_fagd .Round (_e .Second /100).AppendFormat (_aggf ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_aggf =_fagd .Round (_e .Second /1000).AppendFormat (_aggf ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_aggf =_fagd .AppendFormat (_aggf ,"\u0050\u004d");case "\u005b\u0068\u005d":_aggf =_bb .AppendInt (_aggf ,int64 (_cae *24),10);case "\u005b\u006d\u005d":_aggf =_bb .AppendInt (_aggf ,int64 (_cae *24*60),10);case "\u005b\u0073\u005d":_aggf =_bb .AppendInt (_aggf ,int64 (_cae *24*60*60),10);case "":default:_f .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bgg );};if _cba [_ceb ]==':'{_aggf =append (_aggf ,':');};};return _aggf ;};const _cag int =0;func _cfe (_fdc int64 )int64 {if _fdc < 0{return -_fdc ;};return _fdc ;};const _bbg int =34;func _ecf (_ef _e .Time ,_aea string )[]byte {_acf :=[]byte {};_ggag :=0;for _beaa :=0;_beaa < len (_aea );_beaa ++{var _cfa string ;if _aea [_beaa ]=='/'{_cfa =string (_aea [_ggag :_beaa ]);_ggag =_beaa +1;}else if _beaa ==len (_aea )-1{_cfa =string (_aea [_ggag :_beaa +1]);}else {continue ;};switch _cfa {case "\u0079\u0079":_acf =_ef .AppendFormat (_acf ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_acf =_ef .AppendFormat (_acf ,"\u0032\u0030\u0030\u0036");case "\u006d":_acf =_ef .AppendFormat (_acf ,"\u0031");case "\u006d\u006d":_acf =_ef .AppendFormat (_acf ,"\u0030\u0031");case "\u006d\u006d\u006d":_acf =_ef .AppendFormat (_acf ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_acf =_ef .AppendFormat (_acf ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _ef .Month (){case _e .January ,_e .July ,_e .June :_acf =append (_acf ,'J');case _e .February :_acf =append (_acf ,'M');case _e .March ,_e .May :_acf =append (_acf ,'M');case _e .April ,_e .August :_acf =append (_acf ,'A');case _e .September :_acf =append (_acf ,'S');case _e .October :_acf =append (_acf ,'O');case _e .November :_acf =append (_acf ,'N');case _e .December :_acf =append (_acf ,'D');};case "\u0064":_acf =_ef .AppendFormat (_acf ,"\u0032");case "\u0064\u0064":_acf =_ef .AppendFormat (_acf ,"\u0030\u0032");case "\u0064\u0064\u0064":_acf =_ef .AppendFormat (_acf ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_acf =_ef .AppendFormat (_acf ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_f .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_cfa );};if _aea [_beaa ]=='/'{_acf =append (_acf ,'/');};};return _acf ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_gd :=Parse (f );if len (_gd )==1{return _ebg (v ,_gd [0],false );}else if len (_gd )> 1&&v < 0{return _ebg (v ,_gd [1],true );}else if len (_gd )> 2&&v ==0{return _ebg (v ,_gd [2],false );};return _ebg (v ,_gd [0],false );};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_ce ,_ :=_bb .ParseFloat (v ,64);return Number (_ce ,f );};return String (v ,f );};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _a .Abs (v )>=_fg ||_a .Abs (v )<=_be &&v !=0{return _caa (v );};_ebcb :=make ([]byte ,0,15);_ebcb =_bb .AppendFloat (_ebcb ,v ,'f',-1,64);if len (_ebcb )> 11{_gccc :=_ebcb [11]-'0';if _gccc >=5&&_gccc <=9{_ebcb [10]++;_ebcb =_ebcb [0:11];_ebcb =_ddf (_ebcb );};_ebcb =_ebcb [0:11];}else if len (_ebcb )==11{if _ebcb [len (_ebcb )-1]=='9'{_ebcb [len (_ebcb )-1]++;_ebcb =_ddf (_ebcb );};};_ebcb =_fag (_ebcb );return string (_ebcb );};func _geb (_ffgc int64 ,_gb Format )[]byte {if !_gb .IsExponential ||len (_gb .Exponent )==0{return nil ;};_edc :=_bb .AppendInt (nil ,_cfe (_ffgc ),10);_gcg :=make ([]byte ,0,len (_edc )+2);_gcg =append (_gcg ,'E');if _ffgc >=0{_gcg =append (_gcg ,'+');}else {_gcg =append (_gcg ,'-');_ffgc *=-1;};_gbd :=0;_bac :for _gff :=len (_gb .Exponent )-1;_gff >=0;_gff --{_dag :=len (_edc )-1-_gbd ;_ggd :=_gb .Exponent [_gff ];switch _ggd .Type {case FmtTypeDigit :if _dag >=0{_gcg =append (_gcg ,_edc [_dag ]);_gbd ++;}else {_gcg =append (_gcg ,'0');};case FmtTypeDigitOpt :if _dag >=0{_gcg =append (_gcg ,_edc [_dag ]);_gbd ++;}else {for _cff :=_gff ;_cff >=0;_cff --{_ga :=_gb .Exponent [_cff ];if _ga .Type ==FmtTypeLiteral {_gcg =append (_gcg ,_ga .Literal );};};break _bac ;};case FmtTypeLiteral :_gcg =append (_gcg ,_ggd .Literal );default:_f .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_ggd );};};if _gbd < len (_edc ){_gcg =append (_gcg ,_edc [len (_edc )-_gbd -1:_gbd -1]...);};_ced (_gcg [2:]);return _gcg ;};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_acd :=Parse (f );var _af Format ;if len (_acd )==1{_af =_acd [0];}else if len (_acd )==4{_af =_acd [3];};_fb :=false ;for _ ,_bcc :=range _af .Whole {if _bcc .Type ==FmtTypeText {_fb =true ;};};if !_fb {return v ;};_dde :=_bf .Buffer {};for _ ,_ebb :=range _af .Whole {switch _ebb .Type {case FmtTypeLiteral :_dde .WriteByte (_ebb .Literal );case FmtTypeText :_dde .WriteString (v );};};return _dde .String ();};const _edba int =34;func (_c FmtType )String ()string {if _c >=FmtType (len (_bc )-1){return _b .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_c );};return _dd [_bc [_c ]:_bc [_c +1]];};func _ebg (_gc float64 ,_ag Format ,_eef bool )string {if _ag ._fa {return NumberGeneric (_gc );};_edd :=make ([]byte ,0,20);_gg :=_a .Signbit (_gc );_bfa :=_a .Abs (_gc );_ea :=int64 (0);_agg :=int64 (0);if _ag .IsExponential {for _bfa >=10{_agg ++;_bfa /=10;};for _bfa < 1{_agg --;_bfa *=10;};}else if _ag ._ad {_bfa *=100;}else if _ag ._fc {if _ag ._ff ==0{_ffc :=_a .Pow (10,float64 (_ag ._ac ));_ceg ,_cc :=1.0,1.0;_ =_ceg ;for _eab :=1.0;_eab < _ffc ;_eab ++{_ ,_ecd :=_a .Modf (_bfa *float64 (_eab ));if _ecd < _cc {_cc =_ecd ;_ceg =_eab ;if _ecd ==0{break ;};};};_ag ._ff =int64 (_ceg );};_ea =int64 (_bfa *float64 (_ag ._ff )+0.5);if len (_ag .Whole )> 0&&_ea > _ag ._ff {_ea =int64 (_bfa *float64 (_ag ._ff ))%_ag ._ff ;_bfa -=float64 (_ea )/float64 (_ag ._ff );}else {_bfa -=float64 (_ea )/float64 (_ag ._ff );if _a .Abs (_bfa )< 1{_gce :=true ;for _ ,_dfe :=range _ag .Whole {if _dfe .Type ==FmtTypeDigitOpt {continue ;};if _dfe .Type ==FmtTypeLiteral &&_dfe .Literal ==' '{continue ;};_gce =false ;};if _gce {_ag .Whole =nil ;};};};};_gdf :=1;for _ ,_db :=range _ag .Fractional {if _db .Type ==FmtTypeDigit ||_db .Type ==FmtTypeDigitOpt {_gdf ++;};};_bfa +=5*_a .Pow10 (-_gdf );_gcc ,_ecb :=_a .Modf (_bfa );_edd =append (_edd ,_afb (_gcc ,_gc ,_ag )...);_edd =append (_edd ,_fe (_ecb ,_gc ,_ag )...);_edd =append (_edd ,_geb (_agg ,_ag )...);if _ag ._fc {_edd =_bb .AppendInt (_edd ,_ea ,10);_edd =append (_edd ,'/');_edd =_bb .AppendInt (_edd ,_ag ._ff ,10);};if !_eef &&_gg {return "\u002d"+string (_edd );};return string (_edd );};func Parse (s string )[]Format {_eee :=Lexer {};_eee .Lex (_eb .NewReader (s ));_eee ._aeg =append (_eee ._aeg ,_eee ._fee );return _eee ._aeg ;};type Lexer struct{_fee Format ;_aeg []Format ;};func (_dbf *Lexer )nextFmt (){_dbf ._aeg =append (_dbf ._aeg ,_dbf ._fee );_dbf ._fee =Format {}};const _cce int =-1;

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_fc bool ;_ad bool ;_fa bool ;_df bool ;_ed bool ;_fd bool ;_ff int64 ;_ac int ;};func _afb (_dg ,_bfae float64 ,_ab Format )[]byte {if len (_ab .Whole )==0{return nil ;};_cec :=_e .Date (1899,12,30,0,0,0,0,_e .UTC );_dge :=_cec .Add (_e .Duration (_bfae *float64 (24*_e .Hour )));_dge =_bcfg (_dge );_bea :=_bb .AppendFloat (nil ,_dg ,'f',-1,64);_ada :=make ([]byte ,0,len (_bea ));_fdb :=0;_cb :=1;_ede :for _eg :=len (_ab .Whole )-1;_eg >=0;_eg --{_edb :=len (_bea )-1-_fdb ;_ae :=_ab .Whole [_eg ];switch _ae .Type {case FmtTypeDigit :if _edb >=0{_ada =append (_ada ,_bea [_edb ]);_fdb ++;_cb =_eg ;}else {_ada =append (_ada ,'0');};case FmtTypeDigitOpt :if _edb >=0{_ada =append (_ada ,_bea [_edb ]);_fdb ++;_cb =_eg ;}else {for _bcg :=_eg ;_bcg >=0;_bcg --{_eeg :=_ab .Whole [_bcg ];if _eeg .Type ==FmtTypeLiteral {_ada =append (_ada ,_eeg .Literal );};};break _ede ;};case FmtTypeDollar :for _dab :=_fdb ;_dab < len (_bea );_dab ++{_ada =append (_ada ,_bea [len (_bea )-1-_dab ]);_fdb ++;};_ada =append (_ada ,'$');case FmtTypeComma :if !_ab ._df {_ada =append (_ada ,',');};case FmtTypeLiteral :_ada =append (_ada ,_ae .Literal );case FmtTypeDate :_ada =append (_ada ,_ced (_ecf (_dge ,_ae .DateTime ))...);case FmtTypeTime :_ada =append (_ada ,_ced (_bgc (_dge ,_bfae ,_ae .DateTime ))...);default:_f .Log ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_ae );};};_cda :=_ced (_ada );if _fdb < len (_bea )&&(_fdb !=0||_ab ._fd ){_bd :=len (_bea )-_fdb ;_bda :=make ([]byte ,len (_cda )+_bd );copy (_bda ,_cda [0:_cb ]);copy (_bda [_cb :],_bea [0:]);copy (_bda [_cb +_bd :],_cda [_cb :]);_cda =_bda ;};if _ab ._df {_aca :=_bf .Buffer {};_cea :=0;for _eba :=len (_cda )-1;_eba >=0;_eba --{if !(_cda [_eba ]>='0'&&_cda [_eba ]<='9'){_cea ++;}else {break ;};};for _acc :=0;_acc < len (_cda );_acc ++{_cde :=(len (_cda )-_acc -_cea );if _cde %3==0&&_cde !=0&&_acc !=0{_aca .WriteByte (',');};_aca .WriteByte (_cda [_acc ]);};_cda =_aca .Bytes ();};return _cda ;};const _bgf int =34;func _fe (_aa ,_dac float64 ,_abe Format )[]byte {if len (_abe .Fractional )==0{return nil ;};_daf :=_bb .AppendFloat (nil ,_aa ,'f',-1,64);if len (_daf )> 2{_daf =_daf [2:];}else {_daf =nil ;};_gga :=make ([]byte ,0,len (_daf ));_gga =append (_gga ,'.');_egd :=0;_dff :for _bg :=0;_bg < len (_abe .Fractional );_bg ++{_ba :=_bg ;_fdg :=_abe .Fractional [_bg ];switch _fdg .Type {case FmtTypeDigit :if _ba < len (_daf ){_gga =append (_gga ,_daf [_ba ]);_egd ++;}else {_gga =append (_gga ,'0');};case FmtTypeDigitOpt :if _ba >=0{_gga =append (_gga ,_daf [_ba ]);_egd ++;}else {break _dff ;};case FmtTypeLiteral :_gga =append (_gga ,_fdg .Literal );default:_f .Log ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_fdg );};};return _gga ;};const _fg =1e11;const _gcd int =-1;

// AddToken adds a format token to the format.
func (_ec *Format )AddToken (t FmtType ,l []byte ){if _ec ._ed {_ec ._ed =false ;return ;};switch t {case FmtTypeDecimal :_ec ._fd =true ;case FmtTypeUnderscore :_ec ._ed =true ;case FmtTypeText :_ec .Whole =append (_ec .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_ec .Whole =append (_ec .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_ec ._ad =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ge :=range l {if _ec .IsExponential {_ec .Exponent =append (_ec .Exponent ,Token {Type :t ,Literal :_ge });}else if !_ec ._fd {_ec .Whole =append (_ec .Whole ,Token {Type :t ,Literal :_ge });}else {_ec .Fractional =append (_ec .Fractional ,Token {Type :t ,Literal :_ge });};};case FmtTypeDigitOptThousands :_ec ._df =true ;case FmtTypeFraction :_cf :=_eb .Split (string (l ),"\u002f");if len (_cf )==2{_ec ._fc =true ;_ec ._ff ,_ =_bb .ParseInt (_cf [1],10,64);for _ ,_fgf :=range _cf [1]{if _fgf =='?'||_fgf =='0'{_ec ._ac ++;};};};default:_f .Log ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};const _dd ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";func (_bgfg *Lexer )Lex (r _d .Reader ){_dafc ,_bed ,_edef :=0,0,0;_add :=-1;_efg ,_fbf ,_becc :=0,0,0;_ =_fbf ;_ =_becc ;_gdbc :=1;_ =_gdbc ;_cef :=make ([]byte ,4096);_caf :=false ;for !_caf {_afcg :=0;if _efg > 0{_afcg =_bed -_efg ;};_bed =0;_gccb ,_ggc :=r .Read (_cef [_afcg :]);if _gccb ==0||_ggc !=nil {_caf =true ;};_edef =_gccb +_afcg ;if _edef < len (_cef ){_add =_edef ;};{_dafc =_edba ;_efg =0;_fbf =0;_becc =0;};{if _bed ==_edef {goto _bggc ;};switch _dafc {case 34:goto _eege ;case 35:goto _fea ;case 0:goto _gfe ;case 36:goto _geg ;case 37:goto _eac ;case 1:goto _beab ;case 2:goto _afdf ;case 38:goto _gcb ;case 3:goto _cdb ;case 4:goto _daa ;case 39:goto _dgff ;case 5:goto _dafg ;case 6:goto _bffa ;case 7:goto _aeb ;case 8:goto _ffgd ;case 40:goto _cad ;case 9:goto _ead ;case 41:goto _dae ;case 10:goto _gabg ;case 42:goto _ddg ;case 11:goto _gag ;case 43:goto _ccf ;case 44:goto _dccb ;case 45:goto _cbe ;case 12:goto _fed ;case 46:goto _gbf ;case 13:goto _ecdd ;case 14:goto _afdg ;case 15:goto _cgc ;case 16:goto _efa ;case 47:goto _aega ;case 17:goto _bbc ;case 48:goto _bef ;case 18:goto _fdgg ;case 19:goto _acg ;case 20:goto _edfa ;case 49:goto _eaed ;case 50:goto _dfb ;case 21:goto _bag ;case 22:goto _dgc ;case 23:goto _gec ;case 24:goto _bgb ;case 25:goto _egfe ;case 51:goto _efgc ;case 26:goto _bccd ;case 52:goto _fedg ;case 53:goto _beb ;case 54:goto _ebad ;case 55:goto _bbeeb ;case 56:goto _cdc ;case 57:goto _bad ;case 27:goto _fgg ;case 28:goto _eeed ;case 29:goto _dgeb ;case 30:goto _agfce ;case 31:goto _cgd ;case 58:goto _eea ;case 32:goto _gaf ;case 59:goto _cffg ;case 33:goto _bgbc ;case 60:goto _efc ;case 61:goto _cgf ;case 62:goto _dgec ;};goto _egb ;_ebca :switch _becc {case 2:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeDigit ,nil );};case 3:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_bed =(_fbf )-1;};case 8:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypePercent ,nil );};case 13:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeFraction ,_cef [_efg :_fbf ]);};case 14:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeDate ,_cef [_efg :_fbf ]);};case 15:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeTime ,_cef [_efg :_fbf ]);};case 16:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeTime ,_cef [_efg :_fbf ]);};case 18:{_bed =(_fbf )-1;};case 20:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeLiteral ,_cef [_efg :_fbf ]);};case 21:{_bed =(_fbf )-1;_bgfg ._fee .AddToken (FmtTypeLiteral ,_cef [_efg +1:_fbf -1]);};};goto _gfag ;_cabd :_bed =(_fbf )-1;{_bgfg ._fee .AddToken (FmtTypeFraction ,_cef [_efg :_fbf ]);};goto _gfag ;_baef :_bed =(_fbf )-1;{_bgfg ._fee .AddToken (FmtTypeDigitOpt ,nil );};goto _gfag ;_gdfd :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeDigitOptThousands ,nil );};goto _gfag ;_aba :_bed =(_fbf )-1;{_bgfg ._fee .AddToken (FmtTypePercent ,nil );};goto _gfag ;_bbe :_bed =(_fbf )-1;{_bgfg ._fee .AddToken (FmtTypeDate ,_cef [_efg :_fbf ]);};goto _gfag ;_fdf :_bed =(_fbf )-1;{_bgfg ._fee .AddToken (FmtTypeDigit ,nil );};goto _gfag ;_fec :_bed =(_fbf )-1;{_bgfg ._fee .AddToken (FmtTypeTime ,_cef [_efg :_fbf ]);};goto _gfag ;_gbbd :_bed =(_fbf )-1;{_bgfg ._fee .AddToken (FmtTypeLiteral ,_cef [_efg :_fbf ]);};goto _gfag ;_faa :_fbf =_bed +1;{_bgfg ._fee ._fa =true ;};goto _gfag ;_acade :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeLiteral ,_cef [_efg :_fbf ]);};goto _gfag ;_dcc :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeDollar ,nil );};goto _gfag ;_eda :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeComma ,nil );};goto _gfag ;_aege :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeDecimal ,nil );};goto _gfag ;_afa :_fbf =_bed +1;{_bgfg .nextFmt ();};goto _gfag ;_edf :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeText ,nil );};goto _gfag ;_gaa :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeUnderscore ,nil );};goto _gfag ;_gab :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypeLiteral ,_cef [_efg :_fbf ]);};goto _gfag ;_ccaf :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypeLiteral ,_cef [_efg +1:_fbf -1]);};goto _gfag ;_fbda :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypeDigitOpt ,nil );};goto _gfag ;_adb :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypeFraction ,_cef [_efg :_fbf ]);};goto _gfag ;_eed :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypePercent ,nil );};goto _gfag ;_agga :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypeDate ,_cef [_efg :_fbf ]);};goto _gfag ;_cg :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypeDigit ,nil );};goto _gfag ;_fga :_fbf =_bed ;_bed --;{_bgfg ._fee .AddToken (FmtTypeTime ,_cef [_efg :_fbf ]);};goto _gfag ;_ffge :_fbf =_bed ;_bed --;{};goto _gfag ;_bafa :_fbf =_bed +1;{_bgfg ._fee .IsExponential =true ;};goto _gfag ;_abd :_fbf =_bed +1;{_bgfg ._fee .AddToken (FmtTypeLiteral ,_cef [_efg +1:_fbf ]);};goto _gfag ;_gfag :_efg =0;if _bed ++;_bed ==_edef {goto _fba ;};_eege :_efg =_bed ;switch _cef [_bed ]{case 34:goto _ccc ;case 35:goto _ebae ;case 36:goto _dcc ;case 37:goto _aece ;case 44:goto _eda ;case 46:goto _aege ;case 47:goto _cecb ;case 48:goto _dgdf ;case 58:goto _dbb ;case 59:goto _afa ;case 63:goto _addd ;case 64:goto _edf ;case 65:goto _baa ;case 69:goto _gcdd ;case 71:goto _dgfc ;case 91:goto _fgff ;case 92:goto _afg ;case 95:goto _gaa ;case 100:goto _cecb ;case 104:goto _dbb ;case 109:goto _ccfa ;case 115:goto _bbeg ;case 121:goto _bcgd ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _cega ;};goto _acade ;_ccc :_fbf =_bed +1;_becc =20;goto _cgb ;_cgb :if _bed ++;_bed ==_edef {goto _deg ;};_fea :if _cef [_bed ]==34{goto _dbd ;};goto _dgb ;_dgb :if _bed ++;_bed ==_edef {goto _dbec ;};_gfe :if _cef [_bed ]==34{goto _dbd ;};goto _dgb ;_dbd :_fbf =_bed +1;_becc =21;goto _cbb ;_cbb :if _bed ++;_bed ==_edef {goto _bcd ;};_geg :if _cef [_bed ]==34{goto _dgb ;};goto _ccaf ;_ebae :_fbf =_bed +1;_becc =3;goto _eeee ;_eeee :if _bed ++;_bed ==_edef {goto _fggc ;};_eac :switch _cef [_bed ]{case 35:goto _fbe ;case 37:goto _fbe ;case 44:goto _cede ;case 47:goto _gfc ;case 48:goto _fbe ;case 63:goto _fbe ;};goto _fbda ;_fbe :if _bed ++;_bed ==_edef {goto _bffb ;};_beab :switch _cef [_bed ]{case 35:goto _fbe ;case 37:goto _fbe ;case 47:goto _gfc ;case 48:goto _fbe ;case 63:goto _fbe ;};goto _ebca ;_gfc :if _bed ++;_bed ==_edef {goto _gbg ;};_afdf :switch _cef [_bed ]{case 35:goto _fcf ;case 37:goto _baff ;case 48:goto _bcga ;case 63:goto _fcf ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dec ;};goto _ebca ;_fcf :_fbf =_bed +1;goto _ffb ;_ffb :if _bed ++;_bed ==_edef {goto _beda ;};_gcb :switch _cef [_bed ]{case 35:goto _fcf ;case 37:goto _fcf ;case 44:goto _fcf ;case 46:goto _fcf ;case 48:goto _fcf ;case 63:goto _fcf ;case 65:goto _cccc ;};goto _adb ;_cccc :if _bed ++;_bed ==_edef {goto _fdd ;};_cdb :switch _cef [_bed ]{case 47:goto _aaa ;case 77:goto _abcf ;};goto _cabd ;_aaa :if _bed ++;_bed ==_edef {goto _gdfe ;};_daa :if _cef [_bed ]==80{goto _ddfg ;};goto _cabd ;_ddfg :_fbf =_bed +1;goto _ccb ;_ccb :if _bed ++;_bed ==_edef {goto _gbe ;};_dgff :if _cef [_bed ]==65{goto _cccc ;};goto _adb ;_abcf :if _bed ++;_bed ==_edef {goto _cdg ;};_dafg :if _cef [_bed ]==47{goto _ffdc ;};goto _cabd ;_ffdc :if _bed ++;_bed ==_edef {goto _acgg ;};_bffa :if _cef [_bed ]==80{goto _adca ;};goto _cabd ;_adca :if _bed ++;_bed ==_edef {goto _cffc ;};_aeb :if _cef [_bed ]==77{goto _ddfg ;};goto _cabd ;_baff :if _bed ++;_bed ==_edef {goto _dba ;};_ffgd :switch _cef [_bed ]{case 35:goto _gfg ;case 37:goto _eae ;case 63:goto _gfg ;};if 48<=_cef [_bed ]&&_cef [_bed ]<=57{goto _ccbg ;};goto _ebca ;_gfg :_fbf =_bed +1;goto _gbc ;_gbc :if _bed ++;_bed ==_edef {goto _aad ;};_cad :switch _cef [_bed ]{case 35:goto _fcf ;case 37:goto _eeeb ;case 44:goto _fcf ;case 46:goto _fcf ;case 48:goto _fcf ;case 63:goto _fcf ;case 65:goto _cccc ;};goto _adb ;_eeeb :if _bed ++;_bed ==_edef {goto _cgfc ;};_ead :switch _cef [_bed ]{case 35:goto _egf ;case 44:goto _egf ;case 46:goto _egf ;case 48:goto _egf ;case 63:goto _egf ;};goto _cabd ;_egf :_fbf =_bed +1;goto _baeg ;_baeg :if _bed ++;_bed ==_edef {goto _aae ;};_dae :switch _cef [_bed ]{case 35:goto _egf ;case 44:goto _egf ;case 46:goto _egf ;case 48:goto _egf ;case 63:goto _egf ;case 65:goto _cccc ;};goto _adb ;_eae :if _bed ++;_bed ==_edef {goto _egef ;};_gabg :if _cef [_bed ]==37{goto _eae ;};if 48<=_cef [_bed ]&&_cef [_bed ]<=57{goto _ccbg ;};goto _ebca ;_ccbg :_fbf =_bed +1;_becc =13;goto _gdg ;_gdg :if _bed ++;_bed ==_edef {goto _bbad ;};_ddg :switch _cef [_bed ]{case 35:goto _fcf ;case 37:goto _fcbdf ;case 44:goto _fcf ;case 46:goto _fcf ;case 48:goto _eca ;case 63:goto _fcf ;case 65:goto _cccc ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _ccbg ;};goto _adb ;_fcbdf :if _bed ++;_bed ==_edef {goto _ggg ;};_gag :switch _cef [_bed ]{case 35:goto _egf ;case 37:goto _eae ;case 44:goto _egf ;case 46:goto _egf ;case 63:goto _egf ;};if 48<=_cef [_bed ]&&_cef [_bed ]<=57{goto _ccbg ;};goto _cabd ;_eca :_fbf =_bed +1;goto _dfa ;_dfa :if _bed ++;_bed ==_edef {goto _cgee ;};_ccf :switch _cef [_bed ]{case 35:goto _fcf ;case 37:goto _eca ;case 44:goto _fcf ;case 46:goto _fcf ;case 48:goto _eca ;case 63:goto _fcf ;case 65:goto _cccc ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _ccbg ;};goto _adb ;_bcga :_fbf =_bed +1;goto _fff ;_fff :if _bed ++;_bed ==_edef {goto _abb ;};_dccb :switch _cef [_bed ]{case 35:goto _fcf ;case 37:goto _eca ;case 44:goto _fcf ;case 46:goto _fcf ;case 48:goto _bcga ;case 63:goto _fcf ;case 65:goto _cccc ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dec ;};goto _adb ;_dec :_fbf =_bed +1;goto _cge ;_cge :if _bed ++;_bed ==_edef {goto _gabf ;};_cbe :switch _cef [_bed ]{case 35:goto _fcf ;case 37:goto _ccbg ;case 44:goto _fcf ;case 46:goto _fcf ;case 48:goto _bcga ;case 63:goto _fcf ;case 65:goto _cccc ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dec ;};goto _adb ;_cede :if _bed ++;_bed ==_edef {goto _eedf ;};_fed :if _cef [_bed ]==35{goto _gdfd ;};goto _baef ;_aece :_fbf =_bed +1;_becc =8;goto _faff ;_faff :if _bed ++;_bed ==_edef {goto _efae ;};_gbf :switch _cef [_bed ]{case 35:goto _ffcd ;case 37:goto _ggee ;case 48:goto _ffca ;case 63:goto _ffcd ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dafcg ;};goto _eed ;_ffcd :if _bed ++;_bed ==_edef {goto _aecb ;};_ecdd :switch _cef [_bed ]{case 35:goto _ffcd ;case 47:goto _gfc ;case 48:goto _ffcd ;case 63:goto _ffcd ;};goto _aba ;_ggee :if _bed ++;_bed ==_edef {goto _cgec ;};_afdg :if _cef [_bed ]==37{goto _ggee ;};if 48<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dafcg ;};goto _ebca ;_dafcg :if _bed ++;_bed ==_edef {goto _fbea ;};_cgc :switch _cef [_bed ]{case 37:goto _ggee ;case 47:goto _gfc ;};if 48<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dafcg ;};goto _ebca ;_ffca :if _bed ++;_bed ==_edef {goto _efe ;};_efa :switch _cef [_bed ]{case 35:goto _ffcd ;case 37:goto _ggee ;case 47:goto _gfc ;case 48:goto _ffca ;case 63:goto _ffcd ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dafcg ;};goto _aba ;_cecb :_fbf =_bed +1;goto _eefg ;_eefg :if _bed ++;_bed ==_edef {goto _afdgd ;};_aega :switch _cef [_bed ]{case 47:goto _cecb ;case 100:goto _cecb ;case 109:goto _cecb ;case 121:goto _agf ;};goto _agga ;_agf :if _bed ++;_bed ==_edef {goto _bffd ;};_bbc :if _cef [_bed ]==121{goto _cecb ;};goto _bbe ;_dgdf :_fbf =_bed +1;_becc =2;goto _gfcb ;_gfcb :if _bed ++;_bed ==_edef {goto _cedf ;};_bef :switch _cef [_bed ]{case 35:goto _fbe ;case 37:goto _adcc ;case 47:goto _gfc ;case 48:goto _bcb ;case 63:goto _fbe ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _fgc ;};goto _cg ;_adcc :if _bed ++;_bed ==_edef {goto _cgg ;};_fdgg :switch _cef [_bed ]{case 35:goto _fbe ;case 37:goto _adcc ;case 47:goto _gfc ;case 48:goto _adcc ;case 63:goto _fbe ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _dafcg ;};goto _fdf ;_bcb :if _bed ++;_bed ==_edef {goto _fce ;};_acg :switch _cef [_bed ]{case 35:goto _fbe ;case 37:goto _adcc ;case 47:goto _gfc ;case 48:goto _bcb ;case 63:goto _fbe ;};if 49<=_cef [_bed ]&&_cef [_bed ]<=57{goto _fgc ;};goto _fdf ;_fgc :if _bed ++;_bed ==_edef {goto _aaaf ;};_edfa :switch _cef [_bed ]{case 37:goto _dafcg ;case 47:goto _gfc ;};if 48<=_cef [_bed ]&&_cef [_bed ]<=57{goto _fgc ;};goto _ebca ;_cega :_fbf =_bed +1;_becc =20;goto _feb ;_feb :if _bed ++;_bed ==_edef {goto _fcec ;};_eaed :switch _cef [_bed ]{case 37:goto _dafcg ;case 47:goto _gfc ;};if 48<=_cef [_bed ]&&_cef [_bed ]<=57{goto _fgc ;};goto _gab ;_dbb :_fbf =_bed +1;_becc =15;goto _gae ;_gae :if _bed ++;_bed ==_edef {goto _eag ;};_dfb :switch _cef [_bed ]{case 58:goto _dbb ;case 65:goto _bacg ;case 104:goto _dbb ;case 109:goto _dbb ;case 115:goto _bbeg ;};goto _fga ;_bacg :if _bed ++;_bed ==_edef {goto _cgecg ;};_bag :switch _cef [_bed ]{case 47:goto _aag ;case 77:goto _edfc ;};goto _ebca ;_aag :if _bed ++;_bed ==_edef {goto _egc ;};_dgc :if _cef [_bed ]==80{goto _dbb ;};goto _ebca ;_edfc :if _bed ++;_bed ==_edef {goto _gfab ;};_gec :if _cef [_bed ]==47{goto _agfc ;};goto _ebca ;_agfc :if _bed ++;_bed ==_edef {goto _fbfg ;};_bgb :if _cef [_bed ]==80{goto _gbfb ;};goto _ebca ;_gbfb :if _bed ++;_bed ==_edef {goto _ccg ;};_egfe :if _cef [_bed ]==77{goto _dbb ;};goto _ebca ;_bbeg :_fbf =_bed +1;_becc =15;goto _baeb ;_baeb :if _bed ++;_bed ==_edef {goto _begd ;};_efgc :switch _cef [_bed ]{case 46:goto _ded ;case 58:goto _dbb ;case 65:goto _bacg ;case 104:goto _dbb ;case 109:goto _dbb ;case 115:goto _bbeg ;};goto _fga ;_ded :if _bed ++;_bed ==_edef {goto _cbbb ;};_bccd :if _cef [_bed ]==48{goto _bbee ;};goto _fec ;_bbee :_fbf =_bed +1;_becc =15;goto _gaad ;_gaad :if _bed ++;_bed ==_edef {goto _bddd ;};_fedg :switch _cef [_bed ]{case 48:goto _caff ;case 58:goto _dbb ;case 65:goto _bacg ;case 104:goto _dbb ;case 109:goto _dbb ;case 115:goto _bbeg ;};goto _fga ;_caff :_fbf =_bed +1;_becc =15;goto _bgbb ;_bgbb :if _bed ++;_bed ==_edef {goto _fgcd ;};_beb :switch _cef [_bed ]{case 48:goto _dbb ;case 58:goto _dbb ;case 65:goto _bacg ;case 104:goto _dbb ;case 109:goto _dbb ;case 115:goto _bbeg ;};goto _fga ;_addd :_fbf =_bed +1;_becc =5;goto _bba ;_bba :if _bed ++;_bed ==_edef {goto _dcb ;};_ebad :switch _cef [_bed ]{case 35:goto _fbe ;case 37:goto _fbe ;case 47:goto _gfc ;case 48:goto _fbe ;case 63:goto _fbe ;};goto _ffge ;_baa :_fbf =_bed +1;_becc =20;goto _bdd ;_bdd :if _bed ++;_bed ==_edef {goto _faag ;};_bbeeb :switch _cef [_bed ]{case 47:goto _aag ;case 77:goto _edfc ;};goto _gab ;_gcdd :if _bed ++;_bed ==_edef {goto _efd ;};_cdc :switch _cef [_bed ]{case 43:goto _bafa ;case 45:goto _bafa ;};goto _gab ;_dgfc :_fbf =_bed +1;goto _cdef ;_cdef :if _bed ++;_bed ==_edef {goto _daad ;};_bad :if _cef [_bed ]==101{goto _dged ;};goto _gab ;_dged :if _bed ++;_bed ==_edef {goto _cdd ;};_fgg :if _cef [_bed ]==110{goto _cffd ;};goto _gbbd ;_cffd :if _bed ++;_bed ==_edef {goto _cbf ;};_eeed :if _cef [_bed ]==101{goto _bdb ;};goto _gbbd ;_bdb :if _bed ++;_bed ==_edef {goto _efgcb ;};_dgeb :if _cef [_bed ]==114{goto _ebf ;};goto _gbbd ;_ebf :if _bed ++;_bed ==_edef {goto _eaf ;};_agfce :if _cef [_bed ]==97{goto _ffdb ;};goto _gbbd ;_ffdb :if _bed ++;_bed ==_edef {goto _dbee ;};_cgd :if _cef [_bed ]==108{goto _faa ;};goto _gbbd ;_fgff :_fbf =_bed +1;_becc =20;goto _abcfe ;_abcfe :if _bed ++;_bed ==_edef {goto _gba ;};_eea :switch _cef [_bed ]{case 104:goto _gde ;case 109:goto _gde ;case 115:goto _gde ;};goto _fcg ;_fcg :if _bed ++;_bed ==_edef {goto _eadb ;};_gaf :if _cef [_bed ]==93{goto _gceb ;};goto _fcg ;_gceb :_fbf =_bed +1;_becc =18;goto _feg ;_aebb :_fbf =_bed +1;_becc =16;goto _feg ;_feg :if _bed ++;_bed ==_edef {goto _becf ;};_cffg :if _cef [_bed ]==93{goto _gceb ;};goto _fcg ;_gde :if _bed ++;_bed ==_edef {goto _cdag ;};_bgbc :if _cef [_bed ]==93{goto _aebb ;};goto _fcg ;_afg :if _bed ++;_bed ==_edef {goto _acaa ;};_efc :goto _abd ;_ccfa :_fbf =_bed +1;_becc =14;goto _aaf ;_aaf :if _bed ++;_bed ==_edef {goto _fedb ;};_cgf :switch _cef [_bed ]{case 47:goto _cecb ;case 58:goto _dbb ;case 65:goto _bacg ;case 100:goto _cecb ;case 104:goto _dbb ;case 109:goto _ccfa ;case 115:goto _bbeg ;case 121:goto _agf ;};goto _agga ;_bcgd :if _bed ++;_bed ==_edef {goto _cdea ;};_dgec :if _cef [_bed ]==121{goto _cecb ;};goto _gab ;_egb :_fba :_dafc =34;goto _bggc ;_deg :_dafc =35;goto _bggc ;_dbec :_dafc =0;goto _bggc ;_bcd :_dafc =36;goto _bggc ;_fggc :_dafc =37;goto _bggc ;_bffb :_dafc =1;goto _bggc ;_gbg :_dafc =2;goto _bggc ;_beda :_dafc =38;goto _bggc ;_fdd :_dafc =3;goto _bggc ;_gdfe :_dafc =4;goto _bggc ;_gbe :_dafc =39;goto _bggc ;_cdg :_dafc =5;goto _bggc ;_acgg :_dafc =6;goto _bggc ;_cffc :_dafc =7;goto _bggc ;_dba :_dafc =8;goto _bggc ;_aad :_dafc =40;goto _bggc ;_cgfc :_dafc =9;goto _bggc ;_aae :_dafc =41;goto _bggc ;_egef :_dafc =10;goto _bggc ;_bbad :_dafc =42;goto _bggc ;_ggg :_dafc =11;goto _bggc ;_cgee :_dafc =43;goto _bggc ;_abb :_dafc =44;goto _bggc ;_gabf :_dafc =45;goto _bggc ;_eedf :_dafc =12;goto _bggc ;_efae :_dafc =46;goto _bggc ;_aecb :_dafc =13;goto _bggc ;_cgec :_dafc =14;goto _bggc ;_fbea :_dafc =15;goto _bggc ;_efe :_dafc =16;goto _bggc ;_afdgd :_dafc =47;goto _bggc ;_bffd :_dafc =17;goto _bggc ;_cedf :_dafc =48;goto _bggc ;_cgg :_dafc =18;goto _bggc ;_fce :_dafc =19;goto _bggc ;_aaaf :_dafc =20;goto _bggc ;_fcec :_dafc =49;goto _bggc ;_eag :_dafc =50;goto _bggc ;_cgecg :_dafc =21;goto _bggc ;_egc :_dafc =22;goto _bggc ;_gfab :_dafc =23;goto _bggc ;_fbfg :_dafc =24;goto _bggc ;_ccg :_dafc =25;goto _bggc ;_begd :_dafc =51;goto _bggc ;_cbbb :_dafc =26;goto _bggc ;_bddd :_dafc =52;goto _bggc ;_fgcd :_dafc =53;goto _bggc ;_dcb :_dafc =54;goto _bggc ;_faag :_dafc =55;goto _bggc ;_efd :_dafc =56;goto _bggc ;_daad :_dafc =57;goto _bggc ;_cdd :_dafc =27;goto _bggc ;_cbf :_dafc =28;goto _bggc ;_efgcb :_dafc =29;goto _bggc ;_eaf :_dafc =30;goto _bggc ;_dbee :_dafc =31;goto _bggc ;_gba :_dafc =58;goto _bggc ;_eadb :_dafc =32;goto _bggc ;_becf :_dafc =59;goto _bggc ;_cdag :_dafc =33;goto _bggc ;_acaa :_dafc =60;goto _bggc ;_fedb :_dafc =61;goto _bggc ;_cdea :_dafc =62;goto _bggc ;_bggc :{};if _bed ==_add {switch _dafc {case 35:goto _gab ;case 0:goto _ebca ;case 36:goto _ccaf ;case 37:goto _fbda ;case 1:goto _ebca ;case 2:goto _ebca ;case 38:goto _adb ;case 3:goto _cabd ;case 4:goto _cabd ;case 39:goto _adb ;case 5:goto _cabd ;case 6:goto _cabd ;case 7:goto _cabd ;case 8:goto _ebca ;case 40:goto _adb ;case 9:goto _cabd ;case 41:goto _adb ;case 10:goto _ebca ;case 42:goto _adb ;case 11:goto _cabd ;case 43:goto _adb ;case 44:goto _adb ;case 45:goto _adb ;case 12:goto _baef ;case 46:goto _eed ;case 13:goto _aba ;case 14:goto _ebca ;case 15:goto _ebca ;case 16:goto _aba ;case 47:goto _agga ;case 17:goto _bbe ;case 48:goto _cg ;case 18:goto _fdf ;case 19:goto _fdf ;case 20:goto _ebca ;case 49:goto _gab ;case 50:goto _fga ;case 21:goto _ebca ;case 22:goto _ebca ;case 23:goto _ebca ;case 24:goto _ebca ;case 25:goto _ebca ;case 51:goto _fga ;case 26:goto _fec ;case 52:goto _fga ;case 53:goto _fga ;case 54:goto _ffge ;case 55:goto _gab ;case 56:goto _gab ;case 57:goto _gab ;case 27:goto _gbbd ;case 28:goto _gbbd ;case 29:goto _gbbd ;case 30:goto _gbbd ;case 31:goto _gbbd ;case 58:goto _gab ;case 32:goto _ebca ;case 59:goto _ebca ;case 33:goto _gbbd ;case 60:goto _gab ;case 61:goto _agga ;case 62:goto _gab ;};};};if _efg > 0{copy (_cef [0:],_cef [_efg :]);};};_ =_add ;if _dafc ==_cce {_f .Log ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};func IsNumber (data string )(_agc bool ){_ebgg ,_egdg ,_cffa :=0,0,len (data );_gdc :=len (data );_de ,_bdae ,_fcbd :=0,0,0;_ =_bdae ;_ =_fcbd ;_ =_de ;{_ebgg =_cag ;_de =0;_bdae =0;_fcbd =0;};{if _egdg ==_cffa {goto _adcd ;};switch _ebgg {case 0:goto _gcgc ;case 1:goto _baf ;case 2:goto _bcf ;case 3:goto _cab ;case 4:goto _aef ;case 5:goto _ffcf ;case 6:goto _ggba ;case 7:goto _gge ;};goto _ccad ;_cagc :_bdae =_egdg ;_egdg --;{_agc =false ;};goto _gfa ;_dgf :_bdae =_egdg ;_egdg --;{_agc =_bdae ==len (data );};goto _gfa ;_ege :_bdae =_egdg ;_egdg --;{_agc =_bdae ==len (data );};goto _gfa ;_gcgg :switch _fcbd {case 2:{_egdg =(_bdae )-1;_agc =_bdae ==len (data );};case 3:{_egdg =(_bdae )-1;_agc =false ;};};goto _gfa ;_gfa :_de =0;if _egdg ++;_egdg ==_cffa {goto _adae ;};_gcgc :_de =_egdg ;switch data [_egdg ]{case 43:goto _afc ;case 45:goto _afc ;};if 48<=data [_egdg ]&&data [_egdg ]<=57{goto _dcf ;};goto _ggdd ;_ggdd :if _egdg ++;_egdg ==_cffa {goto _abc ;};_baf :goto _ggdd ;_afc :if _egdg ++;_egdg ==_cffa {goto _acad ;};_bcf :if 48<=data [_egdg ]&&data [_egdg ]<=57{goto _dcf ;};goto _ggdd ;_dcf :if _egdg ++;_egdg ==_cffa {goto _ffd ;};_cab :if data [_egdg ]==46{goto _ggb ;};if 48<=data [_egdg ]&&data [_egdg ]<=57{goto _dcf ;};goto _ggdd ;_ggb :if _egdg ++;_egdg ==_cffa {goto _efb ;};_aef :if 48<=data [_egdg ]&&data [_egdg ]<=57{goto _dgfg ;};goto _ggdd ;_dgfg :if _egdg ++;_egdg ==_cffa {goto _fbd ;};_ffcf :if data [_egdg ]==69{goto _egg ;};if 48<=data [_egdg ]&&data [_egdg ]<=57{goto _dgfg ;};goto _ggdd ;_egg :if _egdg ++;_egdg ==_cffa {goto _ged ;};_ggba :switch data [_egdg ]{case 43:goto _adc ;case 45:goto _adc ;};goto _ggdd ;_adc :_bdae =_egdg +1;_fcbd =3;goto _gbb ;_adf :_bdae =_egdg +1;_fcbd =2;goto _gbb ;_gbb :if _egdg ++;_egdg ==_cffa {goto _adfd ;};_gge :if 48<=data [_egdg ]&&data [_egdg ]<=57{goto _adf ;};goto _ggdd ;_ccad :_adae :_ebgg =0;goto _adcd ;_abc :_ebgg =1;goto _adcd ;_acad :_ebgg =2;goto _adcd ;_ffd :_ebgg =3;goto _adcd ;_efb :_ebgg =4;goto _adcd ;_fbd :_ebgg =5;goto _adcd ;_ged :_ebgg =6;goto _adcd ;_adfd :_ebgg =7;goto _adcd ;_adcd :{};if _egdg ==_gdc {switch _ebgg {case 1:goto _cagc ;case 2:goto _cagc ;case 3:goto _dgf ;case 4:goto _cagc ;case 5:goto _ege ;case 6:goto _cagc ;case 7:goto _gcgg ;};};};if _ebgg ==_cce {return false ;};return ;};