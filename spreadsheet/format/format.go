//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_af "bytes";_dg "fmt";_ab "github.com/unidoc/unioffice/v2/common/logger";_g "io";_a "math";_f "strconv";_c "strings";_e "time";);const _fdg int =-1;

// AddToken adds a format token to the format.
func (_bg *Format )AddToken (t FmtType ,l []byte ){if _bg ._b {_bg ._b =false ;return ;};switch t {case FmtTypeDecimal :_bg ._age =true ;case FmtTypeUnderscore :_bg ._b =true ;case FmtTypeText :_bg .Whole =append (_bg .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_bg .Whole =append (_bg .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_bg ._df =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_bd :=range l {if _bg .IsExponential {_bg .Exponent =append (_bg .Exponent ,Token {Type :t ,Literal :_bd });
}else if !_bg ._age {_bg .Whole =append (_bg .Whole ,Token {Type :t ,Literal :_bd });}else {_bg .Fractional =append (_bg .Fractional ,Token {Type :t ,Literal :_bd });};};case FmtTypeDigitOptThousands :_bg ._gc =true ;case FmtTypeFraction :_ddf :=_c .Split (string (l ),"\u002f");
if len (_ddf )==2{_bg ._ac =true ;_bg ._ee ,_ =_f .ParseInt (_ddf [1],10,64);for _ ,_fa :=range _ddf [1]{if _fa =='?'||_fa =='0'{_bg ._dd ++;};};};default:_ab .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};func Parse (s string )[]Format {_edf :=Lexer {};_edf .Lex (_c .NewReader (s ));_edf ._baf =append (_edf ._baf ,_edf ._efae );return _edf ._baf ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_dff :=Parse (f );if len (_dff )==1{return _ge (v ,_dff [0],false );}else if len (_dff )> 1&&v < 0{return _ge (v ,_dff [1],true );
}else if len (_dff )> 2&&v ==0{return _ge (v ,_dff [2],false );};return _ge (v ,_dff [0],false );};func _bfcd (_acbf _e .Time )_e .Time {_acbf =_acbf .UTC ();return _e .Date (_acbf .Year (),_acbf .Month (),_acbf .Day (),_acbf .Hour (),_acbf .Minute (),_acbf .Second (),_acbf .Nanosecond (),_e .Local );
};const _ad ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
func _ge (_acd float64 ,_dbb Format ,_bf bool )string {if _dbb ._fc {return NumberGeneric (_acd );};_deg :=make ([]byte ,0,20);_cd :=_a .Signbit (_acd );_ba :=_a .Abs (_acd );_ce :=int64 (0);_fe :=int64 (0);if _dbb .IsExponential {for _ba >=10{_fe ++;_ba /=10;
};for _ba < 1{_fe --;_ba *=10;};}else if _dbb ._df {_ba *=100;}else if _dbb ._ac {if _dbb ._ee ==0{_cb :=_a .Pow (10,float64 (_dbb ._dd ));_eg ,_fb :=1.0,1.0;_ =_eg ;for _fge :=1.0;_fge < _cb ;_fge ++{_ ,_cf :=_a .Modf (_ba *float64 (_fge ));if _cf < _fb {_fb =_cf ;
_eg =_fge ;if _cf ==0{break ;};};};_dbb ._ee =int64 (_eg );};_ce =int64 (_ba *float64 (_dbb ._ee )+0.5);if len (_dbb .Whole )> 0&&_ce > _dbb ._ee {_ce =int64 (_ba *float64 (_dbb ._ee ))%_dbb ._ee ;_ba -=float64 (_ce )/float64 (_dbb ._ee );}else {_ba -=float64 (_ce )/float64 (_dbb ._ee );
if _a .Abs (_ba )< 1{_fd :=true ;for _ ,_cfc :=range _dbb .Whole {if _cfc .Type ==FmtTypeDigitOpt {continue ;};if _cfc .Type ==FmtTypeLiteral &&_cfc .Literal ==' '{continue ;};_fd =false ;};if _fd {_dbb .Whole =nil ;};};};};_fed :=1;for _ ,_ff :=range _dbb .Fractional {if _ff .Type ==FmtTypeDigit ||_ff .Type ==FmtTypeDigitOpt {_fed ++;
};};_ba +=5*_a .Pow10 (-_fed );_aeg ,_fba :=_a .Modf (_ba );_deg =append (_deg ,_fcd (_aeg ,_acd ,_dbb )...);_deg =append (_deg ,_gb (_fba ,_acd ,_dbb )...);_deg =append (_deg ,_aec (_fe ,_dbb )...);if _dbb ._ac {_deg =_f .AppendInt (_deg ,_ce ,10);_deg =append (_deg ,'/');
_deg =_f .AppendInt (_deg ,_dbb ._ee ,10);};if !_bf &&_cd {return "\u002d"+string (_deg );};return string (_deg );};func (_fg FmtType )String ()string {if _fg >=FmtType (len (_ae )-1){return _dg .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_fg );
};return _ad [_ae [_fg ]:_ae [_fg +1]];};func _fcd (_cg ,_efa float64 ,_fgc Format )[]byte {if len (_fgc .Whole )==0{return nil ;};_ffg :=_e .Date (1899,12,30,0,0,0,0,_e .UTC );_bc :=_ffg .Add (_e .Duration (_efa *float64 (24*_e .Hour )));_bc =_bfcd (_bc );
_fac :=_f .AppendFloat (nil ,_cg ,'f',-1,64);_aad :=make ([]byte ,0,len (_fac ));_cgf :=0;_acc :=1;_fbab :for _dgdg :=len (_fgc .Whole )-1;_dgdg >=0;_dgdg --{_bda :=len (_fac )-1-_cgf ;_gde :=_fgc .Whole [_dgdg ];switch _gde .Type {case FmtTypeDigit :if _bda >=0{_aad =append (_aad ,_fac [_bda ]);
_cgf ++;_acc =_dgdg ;}else {_aad =append (_aad ,'0');};case FmtTypeDigitOpt :if _bda >=0{_aad =append (_aad ,_fac [_bda ]);_cgf ++;_acc =_dgdg ;}else {for _gcc :=_dgdg ;_gcc >=0;_gcc --{_ged :=_fgc .Whole [_gcc ];if _ged .Type ==FmtTypeLiteral {_aad =append (_aad ,_ged .Literal );
};};break _fbab ;};case FmtTypeDollar :for _ea :=_cgf ;_ea < len (_fac );_ea ++{_aad =append (_aad ,_fac [len (_fac )-1-_ea ]);_cgf ++;};_aad =append (_aad ,'$');case FmtTypeComma :if !_fgc ._gc {_aad =append (_aad ,',');};case FmtTypeLiteral :_aad =append (_aad ,_gde .Literal );
case FmtTypeDate :_aad =append (_aad ,_gd (_eeb (_bc ,_gde .DateTime ))...);case FmtTypeTime :_aad =append (_aad ,_gd (_cfcf (_bc ,_efa ,_gde .DateTime ))...);default:_ab .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_gde );
};};_cgfg :=_gd (_aad );if _cgf < len (_fac )&&(_cgf !=0||_fgc ._age ){_ede :=len (_fac )-_cgf ;_fbc :=make ([]byte ,len (_cgfg )+_ede );copy (_fbc ,_cgfg [0:_acc ]);copy (_fbc [_acc :],_fac [0:]);copy (_fbc [_acc +_ede :],_cgfg [_acc :]);_cgfg =_fbc ;
};if _fgc ._gc {_ead :=_af .Buffer {};_gg :=0;for _aca :=len (_cgfg )-1;_aca >=0;_aca --{if !(_cgfg [_aca ]>='0'&&_cgfg [_aca ]<='9'){_gg ++;}else {break ;};};for _bb :=0;_bb < len (_cgfg );_bb ++{_cgd :=(len (_cgfg )-_bb -_gg );if _cgd %3==0&&_cgd !=0&&_bb !=0{_ead .WriteByte (',');
};_ead .WriteByte (_cgfg [_bb ]);};_cgfg =_ead .Bytes ();};return _cgfg ;};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_ac bool ;_df bool ;_fc bool ;_gc bool ;_b bool ;_age bool ;_ee int64 ;_dd int ;};const _dc =1e11;func IsNumber (data string )(_cbcf bool ){_gga ,_bbc ,_gba :=0,0,len (data );
_cgdbe :=len (data );_ecg ,_edd ,_cgff :=0,0,0;_ =_edd ;_ =_cgff ;_ =_ecg ;{_gga =_efac ;_ecg =0;_edd =0;_cgff =0;};{if _bbc ==_gba {goto _cede ;};switch _gga {case 0:goto _fec ;case 1:goto _ggec ;case 2:goto _gfa ;case 3:goto _ced ;case 4:goto _gdgd ;
case 5:goto _aae ;case 6:goto _acef ;case 7:goto _cgffb ;};goto _eab ;_efe :_edd =_bbc ;_bbc --;{_cbcf =false ;};goto _ggg ;_dga :_edd =_bbc ;_bbc --;{_cbcf =_edd ==len (data );};goto _ggg ;_dbbd :_edd =_bbc ;_bbc --;{_cbcf =_edd ==len (data );};goto _ggg ;
_fcfe :switch _cgff {case 2:{_bbc =(_edd )-1;_cbcf =_edd ==len (data );};case 3:{_bbc =(_edd )-1;_cbcf =false ;};};goto _ggg ;_ggg :_ecg =0;if _bbc ++;_bbc ==_gba {goto _cbb ;};_fec :_ecg =_bbc ;switch data [_bbc ]{case 43:goto _gfb ;case 45:goto _gfb ;
};if 48<=data [_bbc ]&&data [_bbc ]<=57{goto _bed ;};goto _bba ;_bba :if _bbc ++;_bbc ==_gba {goto _fdf ;};_ggec :goto _bba ;_gfb :if _bbc ++;_bbc ==_gba {goto _gdbg ;};_gfa :if 48<=data [_bbc ]&&data [_bbc ]<=57{goto _bed ;};goto _bba ;_bed :if _bbc ++;
_bbc ==_gba {goto _efec ;};_ced :if data [_bbc ]==46{goto _gdb ;};if 48<=data [_bbc ]&&data [_bbc ]<=57{goto _bed ;};goto _bba ;_gdb :if _bbc ++;_bbc ==_gba {goto _dbbdd ;};_gdgd :if 48<=data [_bbc ]&&data [_bbc ]<=57{goto _ebb ;};goto _bba ;_ebb :if _bbc ++;
_bbc ==_gba {goto _cdf ;};_aae :if data [_bbc ]==69{goto _fca ;};if 48<=data [_bbc ]&&data [_bbc ]<=57{goto _ebb ;};goto _bba ;_fca :if _bbc ++;_bbc ==_gba {goto _eag ;};_acef :switch data [_bbc ]{case 43:goto _ffa ;case 45:goto _ffa ;};goto _bba ;_ffa :_edd =_bbc +1;
_cgff =3;goto _add ;_ecgc :_edd =_bbc +1;_cgff =2;goto _add ;_add :if _bbc ++;_bbc ==_gba {goto _gdgg ;};_cgffb :if 48<=data [_bbc ]&&data [_bbc ]<=57{goto _ecgc ;};goto _bba ;_eab :_cbb :_gga =0;goto _cede ;_fdf :_gga =1;goto _cede ;_gdbg :_gga =2;goto _cede ;
_efec :_gga =3;goto _cede ;_dbbdd :_gga =4;goto _cede ;_cdf :_gga =5;goto _cede ;_eag :_gga =6;goto _cede ;_gdgg :_gga =7;goto _cede ;_cede :{};if _bbc ==_cgdbe {switch _gga {case 1:goto _efe ;case 2:goto _efe ;case 3:goto _dga ;case 4:goto _efe ;case 5:goto _dbbd ;
case 6:goto _efe ;case 7:goto _fcfe ;};};};if _gga ==_fdg {return false ;};return ;};const _bdg int =34;var _ae =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};func _ec (_afe float64 )string {_bgd :=_f .FormatFloat (_afe ,'E',-1,64);_efb :=_f .FormatFloat (_afe ,'E',5,64);
if len (_bgd )< len (_efb ){return _f .FormatFloat (_afe ,'E',2,64);};return _efb ;};const _gfe int =0;func _gb (_ca ,_dae float64 ,_cbc Format )[]byte {if len (_cbc .Fractional )==0{return nil ;};_cc :=_f .AppendFloat (nil ,_ca ,'f',-1,64);if len (_cc )> 2{_cc =_cc [2:];
}else {_cc =nil ;};_bgf :=make ([]byte ,0,len (_cc ));_bgf =append (_bgf ,'.');_dca :=0;_fgd :for _gac :=0;_gac < len (_cbc .Fractional );_gac ++{_gaca :=_gac ;_acdf :=_cbc .Fractional [_gac ];switch _acdf .Type {case FmtTypeDigit :if _gaca < len (_cc ){_bgf =append (_bgf ,_cc [_gaca ]);
_dca ++;}else {_bgf =append (_bgf ,'0');};case FmtTypeDigitOpt :if _gaca >=0{_bgf =append (_bgf ,_cc [_gaca ]);_dca ++;}else {break _fgd ;};case FmtTypeLiteral :_bgf =append (_bgf ,_acdf .Literal );default:_ab .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_acdf );
};};return _bgf ;};func (_gbc *Lexer )nextFmt (){_gbc ._baf =append (_gbc ._baf ,_gbc ._efae );_gbc ._efae =Format {}};const _eaea int =-1;type Lexer struct{_efae Format ;_baf []Format ;};const _ffac int =34;const _ege int =34;

// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;const _eaeg int =0;func _aac (_aba []byte )[]byte {_gag :=len (_aba );_ega :=false ;_gded :=false ;for _fgf :=len (_aba )-1;_fgf >=0;_fgf --{if _aba [_fgf ]=='0'&&!_gded &&!_ega {_gag =_fgf ;}else if _aba [_fgf ]=='.'{_ega =true ;}else {_gded =true ;
};};if _ega &&_gded {if _aba [_gag -1]=='.'{_gag --;};return _aba [0:_gag ];};return _aba ;};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_da :=Parse (f );var _eed Format ;if len (_da )==1{_eed =_da [0];}else if len (_da )==4{_eed =_da [3];};_dda :=false ;for _ ,_eb :=range _eed .Whole {if _eb .Type ==FmtTypeText {_dda =true ;};};if !_dda {return v ;
};_fcfb :=_af .Buffer {};for _ ,_dbc :=range _eed .Whole {switch _dbc .Type {case FmtTypeLiteral :_fcfb .WriteByte (_dbc .Literal );case FmtTypeText :_fcfb .WriteString (v );};};return _fcfb .String ();};func (_cfe *Lexer )Lex (r _g .Reader ){_edb ,_ggc ,_dba :=0,0,0;
_gfc :=-1;_ecb ,_eda ,_fbcg :=0,0,0;_ =_eda ;_ =_fbcg ;_dcg :=1;_ =_dcg ;_ffgd :=make ([]byte ,4096);_gbf :=false ;for !_gbf {_ffga :=0;if _ecb > 0{_ffga =_ggc -_ecb ;};_ggc =0;_dde ,_dbde :=r .Read (_ffgd [_ffga :]);if _dde ==0||_dbde !=nil {_gbf =true ;
};_dba =_dde +_ffga ;if _dba < len (_ffgd ){_gfc =_dba ;};{_edb =_bdg ;_ecb =0;_eda =0;_fbcg =0;};{if _ggc ==_dba {goto _bbde ;};switch _edb {case 34:goto _fbf ;case 35:goto _bbca ;case 0:goto _abaf ;case 36:goto _gca ;case 37:goto _cgc ;case 1:goto _ddfa ;
case 2:goto _bbcc ;case 38:goto _cca ;case 3:goto _afgg ;case 4:goto _ggcb ;case 39:goto _aaf ;case 5:goto _fgcg ;case 6:goto _dfda ;case 7:goto _dfdc ;case 8:goto _gdgda ;case 40:goto _gea ;case 9:goto _ddb ;case 41:goto _aed ;case 10:goto _ccgc ;case 42:goto _fcfd ;
case 11:goto _cbd ;case 43:goto _gad ;case 44:goto _fag ;case 45:goto _dgad ;case 12:goto _fbcc ;case 46:goto _beg ;case 13:goto _cad ;case 14:goto _fcc ;case 15:goto _gaa ;case 16:goto _bede ;case 47:goto _fee ;case 17:goto _afd ;case 48:goto _eedb ;case 18:goto _cgfa ;
case 19:goto _gdf ;case 20:goto _ded ;case 49:goto _ggce ;case 50:goto _dggb ;case 21:goto _bgfcc ;case 22:goto _adcf ;case 23:goto _aaff ;case 24:goto _fddc ;case 25:goto _ddge ;case 51:goto _cdef ;case 26:goto _bdc ;case 52:goto _gcdb ;case 53:goto _egeb ;
case 54:goto _gec ;case 55:goto _bbd ;case 56:goto _ece ;case 57:goto _bfcc ;case 27:goto _fage ;case 28:goto _fedc ;case 29:goto _cag ;case 30:goto _gfgf ;case 31:goto _eca ;case 58:goto _dggad ;case 32:goto _fff ;case 59:goto _dcdd ;case 33:goto _feb ;
case 60:goto _ccde ;case 61:goto _gecf ;case 62:goto _ecga ;};goto _cea ;_gfag :switch _fbcg {case 2:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypeDigit ,nil );};case 3:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_ggc =(_eda )-1;
};case 8:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypePercent ,nil );};case 13:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypeFraction ,_ffgd [_ecb :_eda ]);};case 14:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypeDate ,_ffgd [_ecb :_eda ]);};case 15:{_ggc =(_eda )-1;
_cfe ._efae .AddToken (FmtTypeTime ,_ffgd [_ecb :_eda ]);};case 16:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypeTime ,_ffgd [_ecb :_eda ]);};case 18:{_ggc =(_eda )-1;};case 20:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypeLiteral ,_ffgd [_ecb :_eda ]);
};case 21:{_ggc =(_eda )-1;_cfe ._efae .AddToken (FmtTypeLiteral ,_ffgd [_ecb +1:_eda -1]);};};goto _gcd ;_faa :_ggc =(_eda )-1;{_cfe ._efae .AddToken (FmtTypeFraction ,_ffgd [_ecb :_eda ]);};goto _gcd ;_ggef :_ggc =(_eda )-1;{_cfe ._efae .AddToken (FmtTypeDigitOpt ,nil );
};goto _gcd ;_bcb :_eda =_ggc +1;{_cfe ._efae .AddToken (FmtTypeDigitOptThousands ,nil );};goto _gcd ;_dfg :_ggc =(_eda )-1;{_cfe ._efae .AddToken (FmtTypePercent ,nil );};goto _gcd ;_dffe :_ggc =(_eda )-1;{_cfe ._efae .AddToken (FmtTypeDate ,_ffgd [_ecb :_eda ]);
};goto _gcd ;_eacc :_ggc =(_eda )-1;{_cfe ._efae .AddToken (FmtTypeDigit ,nil );};goto _gcd ;_egd :_ggc =(_eda )-1;{_cfe ._efae .AddToken (FmtTypeTime ,_ffgd [_ecb :_eda ]);};goto _gcd ;_dgg :_ggc =(_eda )-1;{_cfe ._efae .AddToken (FmtTypeLiteral ,_ffgd [_ecb :_eda ]);
};goto _gcd ;_gcg :_eda =_ggc +1;{_cfe ._efae ._fc =true ;};goto _gcd ;_aab :_eda =_ggc +1;{_cfe ._efae .AddToken (FmtTypeLiteral ,_ffgd [_ecb :_eda ]);};goto _gcd ;_cfb :_eda =_ggc +1;{_cfe ._efae .AddToken (FmtTypeDollar ,nil );};goto _gcd ;_gaga :_eda =_ggc +1;
{_cfe ._efae .AddToken (FmtTypeComma ,nil );};goto _gcd ;_dgga :_eda =_ggc +1;{_cfe ._efae .AddToken (FmtTypeDecimal ,nil );};goto _gcd ;_ccc :_eda =_ggc +1;{_cfe .nextFmt ();};goto _gcd ;_bedg :_eda =_ggc +1;{_cfe ._efae .AddToken (FmtTypeText ,nil );
};goto _gcd ;_dbe :_eda =_ggc +1;{_cfe ._efae .AddToken (FmtTypeUnderscore ,nil );};goto _gcd ;_ebba :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypeLiteral ,_ffgd [_ecb :_eda ]);};goto _gcd ;_adc :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypeLiteral ,_ffgd [_ecb +1:_eda -1]);
};goto _gcd ;_fef :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypeDigitOpt ,nil );};goto _gcd ;_bea :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypeFraction ,_ffgd [_ecb :_eda ]);};goto _gcd ;_ggcg :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypePercent ,nil );
};goto _gcd ;_ada :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypeDate ,_ffgd [_ecb :_eda ]);};goto _gcd ;_ade :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypeDigit ,nil );};goto _gcd ;_bce :_eda =_ggc ;_ggc --;{_cfe ._efae .AddToken (FmtTypeTime ,_ffgd [_ecb :_eda ]);
};goto _gcd ;_fbac :_eda =_ggc ;_ggc --;{};goto _gcd ;_afg :_eda =_ggc +1;{_cfe ._efae .IsExponential =true ;};goto _gcd ;_cgdc :_eda =_ggc +1;{_cfe ._efae .AddToken (FmtTypeLiteral ,_ffgd [_ecb +1:_eda ]);};goto _gcd ;_gcd :_ecb =0;if _ggc ++;_ggc ==_dba {goto _dedf ;
};_fbf :_ecb =_ggc ;switch _ffgd [_ggc ]{case 34:goto _dfe ;case 35:goto _gaf ;case 36:goto _cfb ;case 37:goto _fefd ;case 44:goto _gaga ;case 46:goto _dgga ;case 47:goto _eef ;case 48:goto _bfab ;case 58:goto _bde ;case 59:goto _ccc ;case 63:goto _gafe ;
case 64:goto _bedg ;case 65:goto _dge ;case 69:goto _ceb ;case 71:goto _fafd ;case 91:goto _cbbc ;case 92:goto _egf ;case 95:goto _dbe ;case 100:goto _eef ;case 104:goto _bde ;case 109:goto _gcb ;case 115:goto _gbef ;case 121:goto _cfg ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _cccb ;
};goto _aab ;_dfe :_eda =_ggc +1;_fbcg =20;goto _gfeb ;_gfeb :if _ggc ++;_ggc ==_dba {goto _afc ;};_bbca :if _ffgd [_ggc ]==34{goto _bcef ;};goto _bfc ;_bfc :if _ggc ++;_ggc ==_dba {goto _acb ;};_abaf :if _ffgd [_ggc ]==34{goto _bcef ;};goto _bfc ;_bcef :_eda =_ggc +1;
_fbcg =21;goto _gdc ;_gdc :if _ggc ++;_ggc ==_dba {goto _efg ;};_gca :if _ffgd [_ggc ]==34{goto _bfc ;};goto _adc ;_gaf :_eda =_ggc +1;_fbcg =3;goto _dec ;_dec :if _ggc ++;_ggc ==_dba {goto _cbbcd ;};_cgc :switch _ffgd [_ggc ]{case 35:goto _fddb ;case 37:goto _fddb ;
case 44:goto _feg ;case 47:goto _eace ;case 48:goto _fddb ;case 63:goto _fddb ;};goto _fef ;_fddb :if _ggc ++;_ggc ==_dba {goto _cbdc ;};_ddfa :switch _ffgd [_ggc ]{case 35:goto _fddb ;case 37:goto _fddb ;case 47:goto _eace ;case 48:goto _fddb ;case 63:goto _fddb ;
};goto _gfag ;_eace :if _ggc ++;_ggc ==_dba {goto _aacd ;};_bbcc :switch _ffgd [_ggc ]{case 35:goto _ccg ;case 37:goto _dcd ;case 48:goto _bfbc ;case 63:goto _ccg ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _egb ;};goto _gfag ;_ccg :_eda =_ggc +1;goto _ebbf ;
_ebbf :if _ggc ++;_ggc ==_dba {goto _cadc ;};_cca :switch _ffgd [_ggc ]{case 35:goto _ccg ;case 37:goto _ccg ;case 44:goto _ccg ;case 46:goto _ccg ;case 48:goto _ccg ;case 63:goto _ccg ;case 65:goto _bdfc ;};goto _bea ;_bdfc :if _ggc ++;_ggc ==_dba {goto _ccdf ;
};_afgg :switch _ffgd [_ggc ]{case 47:goto _bafa ;case 77:goto _cfec ;};goto _faa ;_bafa :if _ggc ++;_ggc ==_dba {goto _dad ;};_ggcb :if _ffgd [_ggc ]==80{goto _gbd ;};goto _faa ;_gbd :_eda =_ggc +1;goto _eba ;_eba :if _ggc ++;_ggc ==_dba {goto _fgea ;
};_aaf :if _ffgd [_ggc ]==65{goto _bdfc ;};goto _bea ;_cfec :if _ggc ++;_ggc ==_dba {goto _aeca ;};_fgcg :if _ffgd [_ggc ]==47{goto _gae ;};goto _faa ;_gae :if _ggc ++;_ggc ==_dba {goto _daea ;};_dfda :if _ffgd [_ggc ]==80{goto _cfea ;};goto _faa ;_cfea :if _ggc ++;
_ggc ==_dba {goto _gda ;};_dfdc :if _ffgd [_ggc ]==77{goto _gbd ;};goto _faa ;_dcd :if _ggc ++;_ggc ==_dba {goto _gdbb ;};_gdgda :switch _ffgd [_ggc ]{case 35:goto _cedd ;case 37:goto _efd ;case 63:goto _cedd ;};if 48<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _ecd ;
};goto _gfag ;_cedd :_eda =_ggc +1;goto _fae ;_fae :if _ggc ++;_ggc ==_dba {goto _beb ;};_gea :switch _ffgd [_ggc ]{case 35:goto _ccg ;case 37:goto _eacd ;case 44:goto _ccg ;case 46:goto _ccg ;case 48:goto _ccg ;case 63:goto _ccg ;case 65:goto _bdfc ;};
goto _bea ;_eacd :if _ggc ++;_ggc ==_dba {goto _abc ;};_ddb :switch _ffgd [_ggc ]{case 35:goto _fbfb ;case 44:goto _fbfb ;case 46:goto _fbfb ;case 48:goto _fbfb ;case 63:goto _fbfb ;};goto _faa ;_fbfb :_eda =_ggc +1;goto _dbee ;_dbee :if _ggc ++;_ggc ==_dba {goto _adb ;
};_aed :switch _ffgd [_ggc ]{case 35:goto _fbfb ;case 44:goto _fbfb ;case 46:goto _fbfb ;case 48:goto _fbfb ;case 63:goto _fbfb ;case 65:goto _bdfc ;};goto _bea ;_efd :if _ggc ++;_ggc ==_dba {goto _gff ;};_ccgc :if _ffgd [_ggc ]==37{goto _efd ;};if 48<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _ecd ;
};goto _gfag ;_ecd :_eda =_ggc +1;_fbcg =13;goto _edfg ;_edfg :if _ggc ++;_ggc ==_dba {goto _fabc ;};_fcfd :switch _ffgd [_ggc ]{case 35:goto _ccg ;case 37:goto _gafg ;case 44:goto _ccg ;case 46:goto _ccg ;case 48:goto _dab ;case 63:goto _ccg ;case 65:goto _bdfc ;
};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _ecd ;};goto _bea ;_gafg :if _ggc ++;_ggc ==_dba {goto _cce ;};_cbd :switch _ffgd [_ggc ]{case 35:goto _fbfb ;case 37:goto _efd ;case 44:goto _fbfb ;case 46:goto _fbfb ;case 63:goto _fbfb ;};if 48<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _ecd ;
};goto _faa ;_dab :_eda =_ggc +1;goto _dac ;_dac :if _ggc ++;_ggc ==_dba {goto _cdd ;};_gad :switch _ffgd [_ggc ]{case 35:goto _ccg ;case 37:goto _dab ;case 44:goto _ccg ;case 46:goto _ccg ;case 48:goto _dab ;case 63:goto _ccg ;case 65:goto _bdfc ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _ecd ;
};goto _bea ;_bfbc :_eda =_ggc +1;goto _cee ;_cee :if _ggc ++;_ggc ==_dba {goto _ccec ;};_fag :switch _ffgd [_ggc ]{case 35:goto _ccg ;case 37:goto _dab ;case 44:goto _ccg ;case 46:goto _ccg ;case 48:goto _bfbc ;case 63:goto _ccg ;case 65:goto _bdfc ;};
if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _egb ;};goto _bea ;_egb :_eda =_ggc +1;goto _bgfc ;_bgfc :if _ggc ++;_ggc ==_dba {goto _dcc ;};_dgad :switch _ffgd [_ggc ]{case 35:goto _ccg ;case 37:goto _ecd ;case 44:goto _ccg ;case 46:goto _ccg ;case 48:goto _bfbc ;
case 63:goto _ccg ;case 65:goto _bdfc ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _egb ;};goto _bea ;_feg :if _ggc ++;_ggc ==_dba {goto _bcc ;};_fbcc :if _ffgd [_ggc ]==35{goto _bcb ;};goto _ggef ;_fefd :_eda =_ggc +1;_fbcg =8;goto _cgg ;_cgg :if _ggc ++;
_ggc ==_dba {goto _bga ;};_beg :switch _ffgd [_ggc ]{case 35:goto _eeba ;case 37:goto _eea ;case 48:goto _dgc ;case 63:goto _eeba ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _geb ;};goto _ggcg ;_eeba :if _ggc ++;_ggc ==_dba {goto _cebc ;};_cad :switch _ffgd [_ggc ]{case 35:goto _eeba ;
case 47:goto _eace ;case 48:goto _eeba ;case 63:goto _eeba ;};goto _dfg ;_eea :if _ggc ++;_ggc ==_dba {goto _ffea ;};_fcc :if _ffgd [_ggc ]==37{goto _eea ;};if 48<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _geb ;};goto _gfag ;_geb :if _ggc ++;_ggc ==_dba {goto _acdb ;
};_gaa :switch _ffgd [_ggc ]{case 37:goto _eea ;case 47:goto _eace ;};if 48<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _geb ;};goto _gfag ;_dgc :if _ggc ++;_ggc ==_dba {goto _adac ;};_bede :switch _ffgd [_ggc ]{case 35:goto _eeba ;case 37:goto _eea ;case 47:goto _eace ;
case 48:goto _dgc ;case 63:goto _eeba ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _geb ;};goto _dfg ;_eef :_eda =_ggc +1;goto _ffeg ;_ffeg :if _ggc ++;_ggc ==_dba {goto _edee ;};_fee :switch _ffgd [_ggc ]{case 47:goto _eef ;case 100:goto _eef ;case 109:goto _eef ;
case 121:goto _dgf ;};goto _ada ;_dgf :if _ggc ++;_ggc ==_dba {goto _fcce ;};_afd :if _ffgd [_ggc ]==121{goto _eef ;};goto _dffe ;_bfab :_eda =_ggc +1;_fbcg =2;goto _afb ;_afb :if _ggc ++;_ggc ==_dba {goto _ddbe ;};_eedb :switch _ffgd [_ggc ]{case 35:goto _fddb ;
case 37:goto _bbcb ;case 47:goto _eace ;case 48:goto _bgb ;case 63:goto _fddb ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _bcbd ;};goto _ade ;_bbcb :if _ggc ++;_ggc ==_dba {goto _cbda ;};_cgfa :switch _ffgd [_ggc ]{case 35:goto _fddb ;case 37:goto _bbcb ;
case 47:goto _eace ;case 48:goto _bbcb ;case 63:goto _fddb ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _geb ;};goto _eacc ;_bgb :if _ggc ++;_ggc ==_dba {goto _abaa ;};_gdf :switch _ffgd [_ggc ]{case 35:goto _fddb ;case 37:goto _bbcb ;case 47:goto _eace ;
case 48:goto _bgb ;case 63:goto _fddb ;};if 49<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _bcbd ;};goto _eacc ;_bcbd :if _ggc ++;_ggc ==_dba {goto _acg ;};_ded :switch _ffgd [_ggc ]{case 37:goto _geb ;case 47:goto _eace ;};if 48<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _bcbd ;
};goto _gfag ;_cccb :_eda =_ggc +1;_fbcg =20;goto _gdea ;_gdea :if _ggc ++;_ggc ==_dba {goto _ceef ;};_ggce :switch _ffgd [_ggc ]{case 37:goto _geb ;case 47:goto _eace ;};if 48<=_ffgd [_ggc ]&&_ffgd [_ggc ]<=57{goto _bcbd ;};goto _ebba ;_bde :_eda =_ggc +1;
_fbcg =15;goto _cde ;_cde :if _ggc ++;_ggc ==_dba {goto _efaf ;};_dggb :switch _ffgd [_ggc ]{case 58:goto _bde ;case 65:goto _ccdc ;case 104:goto _bde ;case 109:goto _bde ;case 115:goto _gbef ;};goto _bce ;_ccdc :if _ggc ++;_ggc ==_dba {goto _dgef ;};_bgfcc :switch _ffgd [_ggc ]{case 47:goto _gfg ;
case 77:goto _eaceg ;};goto _gfag ;_gfg :if _ggc ++;_ggc ==_dba {goto _ddga ;};_adcf :if _ffgd [_ggc ]==80{goto _bde ;};goto _gfag ;_eaceg :if _ggc ++;_ggc ==_dba {goto _dcge ;};_aaff :if _ffgd [_ggc ]==47{goto _cdeb ;};goto _gfag ;_cdeb :if _ggc ++;_ggc ==_dba {goto _fgca ;
};_fddc :if _ffgd [_ggc ]==80{goto _dce ;};goto _gfag ;_dce :if _ggc ++;_ggc ==_dba {goto _adef ;};_ddge :if _ffgd [_ggc ]==77{goto _bde ;};goto _gfag ;_gbef :_eda =_ggc +1;_fbcg =15;goto _cbcfe ;_cbcfe :if _ggc ++;_ggc ==_dba {goto _cgge ;};_cdef :switch _ffgd [_ggc ]{case 46:goto _ggab ;
case 58:goto _bde ;case 65:goto _ccdc ;case 104:goto _bde ;case 109:goto _bde ;case 115:goto _gbef ;};goto _bce ;_ggab :if _ggc ++;_ggc ==_dba {goto _agc ;};_bdc :if _ffgd [_ggc ]==48{goto _bgfe ;};goto _egd ;_bgfe :_eda =_ggc +1;_fbcg =15;goto _abb ;_abb :if _ggc ++;
_ggc ==_dba {goto _dgac ;};_gcdb :switch _ffgd [_ggc ]{case 48:goto _bbg ;case 58:goto _bde ;case 65:goto _ccdc ;case 104:goto _bde ;case 109:goto _bde ;case 115:goto _gbef ;};goto _bce ;_bbg :_eda =_ggc +1;_fbcg =15;goto _eebc ;_eebc :if _ggc ++;_ggc ==_dba {goto _dfc ;
};_egeb :switch _ffgd [_ggc ]{case 48:goto _bde ;case 58:goto _bde ;case 65:goto _ccdc ;case 104:goto _bde ;case 109:goto _bde ;case 115:goto _gbef ;};goto _bce ;_gafe :_eda =_ggc +1;_fbcg =5;goto _fafc ;_fafc :if _ggc ++;_ggc ==_dba {goto _faca ;};_gec :switch _ffgd [_ggc ]{case 35:goto _fddb ;
case 37:goto _fddb ;case 47:goto _eace ;case 48:goto _fddb ;case 63:goto _fddb ;};goto _fbac ;_dge :_eda =_ggc +1;_fbcg =20;goto _caa ;_caa :if _ggc ++;_ggc ==_dba {goto _afgb ;};_bbd :switch _ffgd [_ggc ]{case 47:goto _gfg ;case 77:goto _eaceg ;};goto _ebba ;
_ceb :if _ggc ++;_ggc ==_dba {goto _bfg ;};_ece :switch _ffgd [_ggc ]{case 43:goto _afg ;case 45:goto _afg ;};goto _ebba ;_fafd :_eda =_ggc +1;goto _cdea ;_cdea :if _ggc ++;_ggc ==_dba {goto _edg ;};_bfcc :if _ffgd [_ggc ]==101{goto _dbdc ;};goto _ebba ;
_dbdc :if _ggc ++;_ggc ==_dba {goto _ebaf ;};_fage :if _ffgd [_ggc ]==110{goto _eabg ;};goto _dgg ;_eabg :if _ggc ++;_ggc ==_dba {goto _fcdb ;};_fedc :if _ffgd [_ggc ]==101{goto _cff ;};goto _dgg ;_cff :if _ggc ++;_ggc ==_dba {goto _faae ;};_cag :if _ffgd [_ggc ]==114{goto _aff ;
};goto _dgg ;_aff :if _ggc ++;_ggc ==_dba {goto _agf ;};_gfgf :if _ffgd [_ggc ]==97{goto _acec ;};goto _dgg ;_acec :if _ggc ++;_ggc ==_dba {goto _bge ;};_eca :if _ffgd [_ggc ]==108{goto _gcg ;};goto _dgg ;_cbbc :_eda =_ggc +1;_fbcg =20;goto _begf ;_begf :if _ggc ++;
_ggc ==_dba {goto _gdgcg ;};_dggad :switch _ffgd [_ggc ]{case 104:goto _bbgf ;case 109:goto _bbgf ;case 115:goto _bbgf ;};goto _bac ;_bac :if _ggc ++;_ggc ==_dba {goto _edaa ;};_fff :if _ffgd [_ggc ]==93{goto _bdd ;};goto _bac ;_bdd :_eda =_ggc +1;_fbcg =18;
goto _fegb ;_gfef :_eda =_ggc +1;_fbcg =16;goto _fegb ;_fegb :if _ggc ++;_ggc ==_dba {goto _bgab ;};_dcdd :if _ffgd [_ggc ]==93{goto _bdd ;};goto _bac ;_bbgf :if _ggc ++;_ggc ==_dba {goto _cbba ;};_feb :if _ffgd [_ggc ]==93{goto _gfef ;};goto _bac ;_egf :if _ggc ++;
_ggc ==_dba {goto _afff ;};_ccde :goto _cgdc ;_gcb :_eda =_ggc +1;_fbcg =14;goto _dffeb ;_dffeb :if _ggc ++;_ggc ==_dba {goto _febb ;};_gecf :switch _ffgd [_ggc ]{case 47:goto _eef ;case 58:goto _bde ;case 65:goto _ccdc ;case 100:goto _eef ;case 104:goto _bde ;
case 109:goto _gcb ;case 115:goto _gbef ;case 121:goto _dgf ;};goto _ada ;_cfg :if _ggc ++;_ggc ==_dba {goto _bgfg ;};_ecga :if _ffgd [_ggc ]==121{goto _eef ;};goto _ebba ;_cea :_dedf :_edb =34;goto _bbde ;_afc :_edb =35;goto _bbde ;_acb :_edb =0;goto _bbde ;
_efg :_edb =36;goto _bbde ;_cbbcd :_edb =37;goto _bbde ;_cbdc :_edb =1;goto _bbde ;_aacd :_edb =2;goto _bbde ;_cadc :_edb =38;goto _bbde ;_ccdf :_edb =3;goto _bbde ;_dad :_edb =4;goto _bbde ;_fgea :_edb =39;goto _bbde ;_aeca :_edb =5;goto _bbde ;_daea :_edb =6;
goto _bbde ;_gda :_edb =7;goto _bbde ;_gdbb :_edb =8;goto _bbde ;_beb :_edb =40;goto _bbde ;_abc :_edb =9;goto _bbde ;_adb :_edb =41;goto _bbde ;_gff :_edb =10;goto _bbde ;_fabc :_edb =42;goto _bbde ;_cce :_edb =11;goto _bbde ;_cdd :_edb =43;goto _bbde ;
_ccec :_edb =44;goto _bbde ;_dcc :_edb =45;goto _bbde ;_bcc :_edb =12;goto _bbde ;_bga :_edb =46;goto _bbde ;_cebc :_edb =13;goto _bbde ;_ffea :_edb =14;goto _bbde ;_acdb :_edb =15;goto _bbde ;_adac :_edb =16;goto _bbde ;_edee :_edb =47;goto _bbde ;_fcce :_edb =17;
goto _bbde ;_ddbe :_edb =48;goto _bbde ;_cbda :_edb =18;goto _bbde ;_abaa :_edb =19;goto _bbde ;_acg :_edb =20;goto _bbde ;_ceef :_edb =49;goto _bbde ;_efaf :_edb =50;goto _bbde ;_dgef :_edb =21;goto _bbde ;_ddga :_edb =22;goto _bbde ;_dcge :_edb =23;goto _bbde ;
_fgca :_edb =24;goto _bbde ;_adef :_edb =25;goto _bbde ;_cgge :_edb =51;goto _bbde ;_agc :_edb =26;goto _bbde ;_dgac :_edb =52;goto _bbde ;_dfc :_edb =53;goto _bbde ;_faca :_edb =54;goto _bbde ;_afgb :_edb =55;goto _bbde ;_bfg :_edb =56;goto _bbde ;_edg :_edb =57;
goto _bbde ;_ebaf :_edb =27;goto _bbde ;_fcdb :_edb =28;goto _bbde ;_faae :_edb =29;goto _bbde ;_agf :_edb =30;goto _bbde ;_bge :_edb =31;goto _bbde ;_gdgcg :_edb =58;goto _bbde ;_edaa :_edb =32;goto _bbde ;_bgab :_edb =59;goto _bbde ;_cbba :_edb =33;goto _bbde ;
_afff :_edb =60;goto _bbde ;_febb :_edb =61;goto _bbde ;_bgfg :_edb =62;goto _bbde ;_bbde :{};if _ggc ==_gfc {switch _edb {case 35:goto _ebba ;case 0:goto _gfag ;case 36:goto _adc ;case 37:goto _fef ;case 1:goto _gfag ;case 2:goto _gfag ;case 38:goto _bea ;
case 3:goto _faa ;case 4:goto _faa ;case 39:goto _bea ;case 5:goto _faa ;case 6:goto _faa ;case 7:goto _faa ;case 8:goto _gfag ;case 40:goto _bea ;case 9:goto _faa ;case 41:goto _bea ;case 10:goto _gfag ;case 42:goto _bea ;case 11:goto _faa ;case 43:goto _bea ;
case 44:goto _bea ;case 45:goto _bea ;case 12:goto _ggef ;case 46:goto _ggcg ;case 13:goto _dfg ;case 14:goto _gfag ;case 15:goto _gfag ;case 16:goto _dfg ;case 47:goto _ada ;case 17:goto _dffe ;case 48:goto _ade ;case 18:goto _eacc ;case 19:goto _eacc ;
case 20:goto _gfag ;case 49:goto _ebba ;case 50:goto _bce ;case 21:goto _gfag ;case 22:goto _gfag ;case 23:goto _gfag ;case 24:goto _gfag ;case 25:goto _gfag ;case 51:goto _bce ;case 26:goto _egd ;case 52:goto _bce ;case 53:goto _bce ;case 54:goto _fbac ;
case 55:goto _ebba ;case 56:goto _ebba ;case 57:goto _ebba ;case 27:goto _dgg ;case 28:goto _dgg ;case 29:goto _dgg ;case 30:goto _dgg ;case 31:goto _dgg ;case 58:goto _ebba ;case 32:goto _gfag ;case 59:goto _gfag ;case 33:goto _dgg ;case 60:goto _ebba ;
case 61:goto _ada ;case 62:goto _ebba ;};};};if _ecb > 0{copy (_ffgd [0:],_ffgd [_ecb :]);};};_ =_gfc ;if _edb ==_fdg {_ab .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _a .Abs (v )>=_dc ||_a .Abs (v )<=_ag &&v !=0{return _ec (v );};_eac :=make ([]byte ,0,15);_eac =_f .AppendFloat (_eac ,v ,'f',-1,64);if len (_eac )> 11{_cab :=_eac [11]-'0';if _cab >=5&&_cab <=9{_eac [10]++;_eac =_eac [0:11];
_eac =_fgef (_eac );};_eac =_eac [0:11];}else if len (_eac )==11{if _eac [len (_eac )-1]=='9'{_eac [len (_eac )-1]++;_eac =_fgef (_eac );};};_eac =_aac (_eac );return string (_eac );};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;
FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _eeb (_baa _e .Time ,_cgdb string )[]byte {_fdd :=[]byte {};_bfd :=0;for _gdgc :=0;
_gdgc < len (_cgdb );_gdgc ++{var _edc string ;if _cgdb [_gdgc ]=='/'{_edc =string (_cgdb [_bfd :_gdgc ]);_bfd =_gdgc +1;}else if _gdgc ==len (_cgdb )-1{_edc =string (_cgdb [_bfd :_gdgc +1]);}else {continue ;};switch _edc {case "\u0079\u0079":_fdd =_baa .AppendFormat (_fdd ,"\u0030\u0036");
case "\u0079\u0079\u0079\u0079":_fdd =_baa .AppendFormat (_fdd ,"\u0032\u0030\u0030\u0036");case "\u006d":_fdd =_baa .AppendFormat (_fdd ,"\u0031");case "\u006d\u006d":_fdd =_baa .AppendFormat (_fdd ,"\u0030\u0031");case "\u006d\u006d\u006d":_fdd =_baa .AppendFormat (_fdd ,"\u004a\u0061\u006e");
case "\u006d\u006d\u006d\u006d":_fdd =_baa .AppendFormat (_fdd ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _baa .Month (){case _e .January ,_e .July ,_e .June :_fdd =append (_fdd ,'J');case _e .February :_fdd =append (_fdd ,'M');
case _e .March ,_e .May :_fdd =append (_fdd ,'M');case _e .April ,_e .August :_fdd =append (_fdd ,'A');case _e .September :_fdd =append (_fdd ,'S');case _e .October :_fdd =append (_fdd ,'O');case _e .November :_fdd =append (_fdd ,'N');case _e .December :_fdd =append (_fdd ,'D');
};case "\u0064":_fdd =_baa .AppendFormat (_fdd ,"\u0032");case "\u0064\u0064":_fdd =_baa .AppendFormat (_fdd ,"\u0030\u0032");case "\u0064\u0064\u0064":_fdd =_baa .AppendFormat (_fdd ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_fdd =_baa .AppendFormat (_fdd ,"\u004d\u006f\u006e\u0064\u0061\u0079");
default:_ab .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_edc );};if _cgdb [_gdgc ]=='/'{_fdd =append (_fdd ,'/');};};return _fdd ;};const _efac int =0;
func _aec (_eaf int64 ,_ace Format )[]byte {if !_ace .IsExponential ||len (_ace .Exponent )==0{return nil ;};_be :=_f .AppendInt (nil ,_eae (_eaf ),10);_eee :=make ([]byte ,0,len (_be )+2);_eee =append (_eee ,'E');if _eaf >=0{_eee =append (_eee ,'+');}else {_eee =append (_eee ,'-');
_eaf *=-1;};_bfb :=0;_ccd :for _ggb :=len (_ace .Exponent )-1;_ggb >=0;_ggb --{_dfdg :=len (_be )-1-_bfb ;_bdf :=_ace .Exponent [_ggb ];switch _bdf .Type {case FmtTypeDigit :if _dfdg >=0{_eee =append (_eee ,_be [_dfdg ]);_bfb ++;}else {_eee =append (_eee ,'0');
};case FmtTypeDigitOpt :if _dfdg >=0{_eee =append (_eee ,_be [_dfdg ]);_bfb ++;}else {for _dcf :=_ggb ;_dcf >=0;_dcf --{_ffe :=_ace .Exponent [_dcf ];if _ffe .Type ==FmtTypeLiteral {_eee =append (_eee ,_ffe .Literal );};};break _ccd ;};case FmtTypeLiteral :_eee =append (_eee ,_bdf .Literal );
default:_ab .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_bdf );};};if _bfb < len (_be ){_eee =append (_eee ,_be [len (_be )-_bfb -1:_bfb -1]...);
};_gd (_eee [2:]);return _eee ;};func _cfcf (_dbd _e .Time ,_gge float64 ,_bfa string )[]byte {_bfdc :=[]byte {};_bfe :=0;for _gdd :=0;_gdd < len (_bfa );_gdd ++{var _bff string ;if _bfa [_gdd ]==':'{_bff =string (_bfa [_bfe :_gdd ]);_bfe =_gdd +1;}else if _gdd ==len (_bfa )-1{_bff =string (_bfa [_bfe :_gdd +1]);
}else {continue ;};switch _bff {case "\u0064":_bfdc =_dbd .AppendFormat (_bfdc ,"\u0032");case "\u0068":_bfdc =_dbd .AppendFormat (_bfdc ,"\u0033");case "\u0068\u0068":_bfdc =_dbd .AppendFormat (_bfdc ,"\u0031\u0035");case "\u006d":_bfdc =_dbd .AppendFormat (_bfdc ,"\u0034");
case "\u006d\u006d":_bfdc =_dbd .AppendFormat (_bfdc ,"\u0030\u0034");case "\u0073":_bfdc =_dbd .Round (_e .Second ).AppendFormat (_bfdc ,"\u0035");case "\u0073\u002e\u0030":_bfdc =_dbd .Round (_e .Second /10).AppendFormat (_bfdc ,"\u0035\u002e\u0030");
case "\u0073\u002e\u0030\u0030":_bfdc =_dbd .Round (_e .Second /100).AppendFormat (_bfdc ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_bfdc =_dbd .Round (_e .Second /1000).AppendFormat (_bfdc ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_bfdc =_dbd .Round (_e .Second ).AppendFormat (_bfdc ,"\u0030\u0035");
case "\u0073\u0073\u002e\u0030":_bfdc =_dbd .Round (_e .Second /10).AppendFormat (_bfdc ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_bfdc =_dbd .Round (_e .Second /100).AppendFormat (_bfdc ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_bfdc =_dbd .Round (_e .Second /1000).AppendFormat (_bfdc ,"\u0030\u0035\u002e\u0030\u0030\u0030");
case "\u0041\u004d\u002fP\u004d":_bfdc =_dbd .AppendFormat (_bfdc ,"\u0050\u004d");case "\u005b\u0068\u005d":_bfdc =_f .AppendInt (_bfdc ,int64 (_gge *24),10);case "\u005b\u006d\u005d":_bfdc =_f .AppendInt (_bfdc ,int64 (_gge *24*60),10);case "\u005b\u0073\u005d":_bfdc =_f .AppendInt (_bfdc ,int64 (_gge *24*60*60),10);
case "":default:_ab .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bff );};if _bfa [_gdd ]==':'{_bfdc =append (_bfdc ,':');};};return _bfdc ;
};func _fgef (_cdc []byte )[]byte {for _faf :=len (_cdc )-1;_faf > 0;_faf --{if _cdc [_faf ]=='9'+1{_cdc [_faf ]='0';if _cdc [_faf -1]=='.'{_faf --;};_cdc [_faf -1]++;};};if _cdc [0]=='9'+1{_cdc [0]='0';copy (_cdc [1:],_cdc [0:]);_cdc [0]='1';};return _cdc ;
};func _gd (_dgd []byte )[]byte {for _faba :=0;_faba < len (_dgd )/2;_faba ++{_de :=len (_dgd )-1-_faba ;_dgd [_faba ],_dgd [_de ]=_dgd [_de ],_dgd [_faba ];};return _dgd ;};func _eae (_ddg int64 )int64 {if _ddg < 0{return -_ddg ;};return _ddg ;};const _ag =1e-10;


// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_ed ,_ :=_f .ParseFloat (v ,64);return Number (_ed ,f );};return String (v ,f );};