//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_cf "bytes";_c "fmt";_fc "github.com/unidoc/unioffice/common/logger";_f "io";_g "math";_a "strconv";_e "strings";_cc "time";);const _fbc int =0;const _feg int =34;func _cff (_efb ,_gbf float64 ,_dac Format )[]byte {if len (_dac .Whole )==0{return nil ;
};_fcb :=_cc .Date (1899,12,30,0,0,0,0,_cc .UTC );_edc :=_fcb .Add (_cc .Duration (_gbf *float64 (24*_cc .Hour )));_edc =_fbbg (_edc );_baa :=_a .AppendFloat (nil ,_efb ,'f',-1,64);_bedc :=make ([]byte ,0,len (_baa ));_dgc :=0;_fbd :=1;_dgcc :for _bd :=len (_dac .Whole )-1;
_bd >=0;_bd --{_gef :=len (_baa )-1-_dgc ;_ace :=_dac .Whole [_bd ];switch _ace .Type {case FmtTypeDigit :if _gef >=0{_bedc =append (_bedc ,_baa [_gef ]);_dgc ++;_fbd =_bd ;}else {_bedc =append (_bedc ,'0');};case FmtTypeDigitOpt :if _gef >=0{_bedc =append (_bedc ,_baa [_gef ]);
_dgc ++;_fbd =_bd ;}else {for _fce :=_bd ;_fce >=0;_fce --{_bc :=_dac .Whole [_fce ];if _bc .Type ==FmtTypeLiteral {_bedc =append (_bedc ,_bc .Literal );};};break _dgcc ;};case FmtTypeDollar :for _bad :=_dgc ;_bad < len (_baa );_bad ++{_bedc =append (_bedc ,_baa [len (_baa )-1-_bad ]);
_dgc ++;};_bedc =append (_bedc ,'$');case FmtTypeComma :if !_dac ._be {_bedc =append (_bedc ,',');};case FmtTypeLiteral :_bedc =append (_bedc ,_ace .Literal );case FmtTypeDate :_bedc =append (_bedc ,_fcc (_ede (_edc ,_ace .DateTime ))...);case FmtTypeTime :_bedc =append (_bedc ,_fcc (_caac (_edc ,_gbf ,_ace .DateTime ))...);
default:_fc .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_ace );};};_ecd :=_fcc (_bedc );if _dgc < len (_baa )&&(_dgc !=0||_dac ._dg ){_gc :=len (_baa )-_dgc ;
_eag :=make ([]byte ,len (_ecd )+_gc );copy (_eag ,_ecd [0:_fbd ]);copy (_eag [_fbd :],_baa [0:]);copy (_eag [_fbd +_gc :],_ecd [_fbd :]);_ecd =_eag ;};if _dac ._be {_dge :=_cf .Buffer {};_bfg :=0;for _gbcc :=len (_ecd )-1;_gbcc >=0;_gbcc --{if !(_ecd [_gbcc ]>='0'&&_ecd [_gbcc ]<='9'){_bfg ++;
}else {break ;};};for _feb :=0;_feb < len (_ecd );_feb ++{_dab :=(len (_ecd )-_feb -_bfg );if _dab %3==0&&_dab !=0&&_feb !=0{_dge .WriteByte (',');};_dge .WriteByte (_ecd [_feb ]);};_ecd =_dge .Bytes ();};return _ecd ;};func _ef (_cg float64 ,_fe Format ,_ddf bool )string {if _fe ._fd {return NumberGeneric (_cg );
};_ce :=make ([]byte ,0,20);_fee :=_g .Signbit (_cg );_adf :=_g .Abs (_cg );_efc :=int64 (0);_bea :=int64 (0);if _fe .IsExponential {for _adf >=10{_bea ++;_adf /=10;};for _adf < 1{_bea --;_adf *=10;};}else if _fe ._gdg {_adf *=100;}else if _fe ._gf {if _fe ._ed ==0{_agc :=_g .Pow (10,float64 (_fe ._ge ));
_ceb ,_agf :=1.0,1.0;_ =_ceb ;for _bg :=1.0;_bg < _agc ;_bg ++{_ ,_feeb :=_g .Modf (_adf *float64 (_bg ));if _feeb < _agf {_agf =_feeb ;_ceb =_bg ;if _feeb ==0{break ;};};};_fe ._ed =int64 (_ceb );};_efc =int64 (_adf *float64 (_fe ._ed )+0.5);if len (_fe .Whole )> 0&&_efc > _fe ._ed {_efc =int64 (_adf *float64 (_fe ._ed ))%_fe ._ed ;
_adf -=float64 (_efc )/float64 (_fe ._ed );}else {_adf -=float64 (_efc )/float64 (_fe ._ed );if _g .Abs (_adf )< 1{_ca :=true ;for _ ,_efg :=range _fe .Whole {if _efg .Type ==FmtTypeDigitOpt {continue ;};if _efg .Type ==FmtTypeLiteral &&_efg .Literal ==' '{continue ;
};_ca =false ;};if _ca {_fe .Whole =nil ;};};};};_ec :=1;for _ ,_fef :=range _fe .Fractional {if _fef .Type ==FmtTypeDigit ||_fef .Type ==FmtTypeDigitOpt {_ec ++;};};_adf +=5*_g .Pow10 (-_ec );_dad ,_dca :=_g .Modf (_adf );_ce =append (_ce ,_cff (_dad ,_cg ,_fe )...);
_ce =append (_ce ,_db (_dca ,_cg ,_fe )...);_ce =append (_ce ,_dcg (_bea ,_fe )...);if _fe ._gf {_ce =_a .AppendInt (_ce ,_efc ,10);_ce =append (_ce ,'/');_ce =_a .AppendInt (_ce ,_fe ._ed ,10);};if !_ddf &&_fee {return "\u002d"+string (_ce );};return string (_ce );
};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _g .Abs (v )>=_bf ||_g .Abs (v )<=_gd &&v !=0{return _egb (v );};_cga :=make ([]byte ,0,15);_cga =_a .AppendFloat (_cga ,v ,'f',-1,64);if len (_cga )> 11{_eb :=_cga [11]-'0';if _eb >=5&&_eb <=9{_cga [10]++;_cga =_cga [0:11];
_cga =_bdea (_cga );};_cga =_cga [0:11];}else if len (_cga )==11{if _cga [len (_cga )-1]=='9'{_cga [len (_cga )-1]++;_cga =_bdea (_cga );};};_cga =_cgf (_cga );return string (_cga );};func _bdea (_ebe []byte )[]byte {for _ff :=len (_ebe )-1;_ff > 0;_ff --{if _ebe [_ff ]=='9'+1{_ebe [_ff ]='0';
if _ebe [_ff -1]=='.'{_ff --;};_ebe [_ff -1]++;};};if _ebe [0]=='9'+1{_ebe [0]='0';copy (_ebe [1:],_ebe [0:]);_ebe [0]='1';};return _ebe ;};func _db (_efa ,_fcf float64 ,_gea Format )[]byte {if len (_gea .Fractional )==0{return nil ;};_agcd :=_a .AppendFloat (nil ,_efa ,'f',-1,64);
if len (_agcd )> 2{_agcd =_agcd [2:];}else {_agcd =nil ;};_becc :=make ([]byte ,0,len (_agcd ));_becc =append (_becc ,'.');_daf :=0;_gee :for _daff :=0;_daff < len (_gea .Fractional );_daff ++{_gcc :=_daff ;_gad :=_gea .Fractional [_daff ];switch _gad .Type {case FmtTypeDigit :if _gcc < len (_agcd ){_becc =append (_becc ,_agcd [_gcc ]);
_daf ++;}else {_becc =append (_becc ,'0');};case FmtTypeDigitOpt :if _gcc >=0{_becc =append (_becc ,_agcd [_gcc ]);_daf ++;}else {break _gee ;};case FmtTypeLiteral :_becc =append (_becc ,_gad .Literal );default:_fc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_gad );
};};return _becc ;};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_cfc :=Parse (f );var _fdd Format ;if len (_cfc )==1{_fdd =_cfc [0];}else if len (_cfc )==4{_fdd =_cfc [3];};_cfb :=false ;for _ ,_gb :=range _fdd .Whole {if _gb .Type ==FmtTypeText {_cfb =true ;};};if !_cfb {return v ;
};_ae :=_cf .Buffer {};for _ ,_da :=range _fdd .Whole {switch _da .Type {case FmtTypeLiteral :_ae .WriteByte (_da .Literal );case FmtTypeText :_ae .WriteString (v );};};return _ae .String ();};func (_d FmtType )String ()string {if _d >=FmtType (len (_ba )-1){return _c .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_d );
};return _cd [_ba [_d ]:_ba [_d +1]];};func _bde (_cffd int64 )int64 {if _cffd < 0{return -_cffd ;};return _cffd ;};func _fcc (_eg []byte )[]byte {for _gdf :=0;_gdf < len (_eg )/2;_gdf ++{_ea :=len (_eg )-1-_gdf ;_eg [_gdf ],_eg [_ea ]=_eg [_ea ],_eg [_gdf ];
};return _eg ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};

// AddToken adds a format token to the format.
func (_ag *Format )AddToken (t FmtType ,l []byte ){if _ag ._bec {_ag ._bec =false ;return ;};switch t {case FmtTypeDecimal :_ag ._dg =true ;case FmtTypeUnderscore :_ag ._bec =true ;case FmtTypeText :_ag .Whole =append (_ag .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_ag .Whole =append (_ag .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_ag ._gdg =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ga :=range l {if _ag .IsExponential {_ag .Exponent =append (_ag .Exponent ,Token {Type :t ,Literal :_ga });
}else if !_ag ._dg {_ag .Whole =append (_ag .Whole ,Token {Type :t ,Literal :_ga });}else {_ag .Fractional =append (_ag .Fractional ,Token {Type :t ,Literal :_ga });};};case FmtTypeDigitOptThousands :_ag ._be =true ;case FmtTypeFraction :_fa :=_e .Split (string (l ),"\u002f");
if len (_fa )==2{_ag ._gf =true ;_ag ._ed ,_ =_a .ParseInt (_fa [1],10,64);for _ ,_ab :=range _fa [1]{if _ab =='?'||_ab =='0'{_ag ._ge ++;};};};default:_fc .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};const _ccf int =34;func _egb (_ega float64 )string {_gbb :=_a .FormatFloat (_ega ,'E',-1,64);_caa :=_a .FormatFloat (_ega ,'E',5,64);if len (_gbb )< len (_caa ){return _a .FormatFloat (_ega ,'E',2,64);};return _caa ;};type Lexer struct{_gfe Format ;
_ggdc []Format ;};func _cgf (_bbg []byte )[]byte {_gba :=len (_bbg );_af :=false ;_ade :=false ;for _adb :=len (_bbg )-1;_adb >=0;_adb --{if _bbg [_adb ]=='0'&&!_ade &&!_af {_gba =_adb ;}else if _bbg [_adb ]=='.'{_af =true ;}else {_ade =true ;};};if _af &&_ade {if _bbg [_gba -1]=='.'{_gba --;
};return _bbg [0:_gba ];};return _bbg ;};const _fde int =-1;func Parse (s string )[]Format {_ee :=Lexer {};_ee .Lex (_e .NewReader (s ));_ee ._ggdc =append (_ee ._ggdc ,_ee ._gfe );return _ee ._ggdc ;};var _ba =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};
const _ggd int =0;func _ede (_dfb _cc .Time ,_agd string )[]byte {_gg :=[]byte {};_geec :=0;for _aef :=0;_aef < len (_agd );_aef ++{var _dff string ;if _agd [_aef ]=='/'{_dff =string (_agd [_geec :_aef ]);_geec =_aef +1;}else if _aef ==len (_agd )-1{_dff =string (_agd [_geec :_aef +1]);
}else {continue ;};switch _dff {case "\u0079\u0079":_gg =_dfb .AppendFormat (_gg ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_gg =_dfb .AppendFormat (_gg ,"\u0032\u0030\u0030\u0036");case "\u006d":_gg =_dfb .AppendFormat (_gg ,"\u0031");case "\u006d\u006d":_gg =_dfb .AppendFormat (_gg ,"\u0030\u0031");
case "\u006d\u006d\u006d":_gg =_dfb .AppendFormat (_gg ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_gg =_dfb .AppendFormat (_gg ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _dfb .Month (){case _cc .January ,_cc .July ,_cc .June :_gg =append (_gg ,'J');
case _cc .February :_gg =append (_gg ,'M');case _cc .March ,_cc .May :_gg =append (_gg ,'M');case _cc .April ,_cc .August :_gg =append (_gg ,'A');case _cc .September :_gg =append (_gg ,'S');case _cc .October :_gg =append (_gg ,'O');case _cc .November :_gg =append (_gg ,'N');
case _cc .December :_gg =append (_gg ,'D');};case "\u0064":_gg =_dfb .AppendFormat (_gg ,"\u0032");case "\u0064\u0064":_gg =_dfb .AppendFormat (_gg ,"\u0030\u0032");case "\u0064\u0064\u0064":_gg =_dfb .AppendFormat (_gg ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_gg =_dfb .AppendFormat (_gg ,"\u004d\u006f\u006e\u0064\u0061\u0079");
default:_fc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_dff );};if _agd [_aef ]=='/'{_gg =append (_gg ,'/');};};return _gg ;};func _dcg (_fdc int64 ,_cae Format )[]byte {if !_cae .IsExponential ||len (_cae .Exponent )==0{return nil ;
};_efff :=_a .AppendInt (nil ,_bde (_fdc ),10);_fbf :=make ([]byte ,0,len (_efff )+2);_fbf =append (_fbf ,'E');if _fdc >=0{_fbf =append (_fbf ,'+');}else {_fbf =append (_fbf ,'-');_fdc *=-1;};_bgd :=0;_bded :for _cfcb :=len (_cae .Exponent )-1;_cfcb >=0;
_cfcb --{_bcc :=len (_efff )-1-_bgd ;_gccg :=_cae .Exponent [_cfcb ];switch _gccg .Type {case FmtTypeDigit :if _bcc >=0{_fbf =append (_fbf ,_efff [_bcc ]);_bgd ++;}else {_fbf =append (_fbf ,'0');};case FmtTypeDigitOpt :if _bcc >=0{_fbf =append (_fbf ,_efff [_bcc ]);
_bgd ++;}else {for _gcd :=_cfcb ;_gcd >=0;_gcd --{_bcb :=_cae .Exponent [_gcd ];if _bcb .Type ==FmtTypeLiteral {_fbf =append (_fbf ,_bcb .Literal );};};break _bded ;};case FmtTypeLiteral :_fbf =append (_fbf ,_gccg .Literal );default:_fc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_gccg );
};};if _bgd < len (_efff ){_fbf =append (_fbf ,_efff [len (_efff )-_bgd -1:_bgd -1]...);};_fcc (_fbf [2:]);return _fbf ;};func IsNumber (data string )(_fg bool ){_fca ,_cdc ,_ffb :=0,0,len (data );_efbe :=len (data );_dbe ,_dga ,_bee :=0,0,0;_ =_dga ;_ =_bee ;
_ =_dbe ;{_fca =_ggd ;_dbe =0;_dga =0;_bee =0;};{if _cdc ==_ffb {goto _dfd ;};switch _fca {case 0:goto _dea ;case 1:goto _efac ;case 2:goto _bga ;case 3:goto _dffg ;case 4:goto _beb ;case 5:goto _fgea ;case 6:goto _gfa ;case 7:goto _gdd ;};goto _abc ;_fge :_dga =_cdc ;
_cdc --;{_fg =false ;};goto _abe ;_fea :_dga =_cdc ;_cdc --;{_fg =_dga ==len (data );};goto _abe ;_gff :_dga =_cdc ;_cdc --;{_fg =_dga ==len (data );};goto _abe ;_dee :switch _bee {case 2:{_cdc =(_dga )-1;_fg =_dga ==len (data );};case 3:{_cdc =(_dga )-1;
_fg =false ;};};goto _abe ;_abe :_dbe =0;if _cdc ++;_cdc ==_ffb {goto _fgb ;};_dea :_dbe =_cdc ;switch data [_cdc ]{case 43:goto _bef ;case 45:goto _bef ;};if 48<=data [_cdc ]&&data [_cdc ]<=57{goto _efd ;};goto _ege ;_ege :if _cdc ++;_cdc ==_ffb {goto _fae ;
};_efac :goto _ege ;_bef :if _cdc ++;_cdc ==_ffb {goto _dgd ;};_bga :if 48<=data [_cdc ]&&data [_cdc ]<=57{goto _efd ;};goto _ege ;_efd :if _cdc ++;_cdc ==_ffb {goto _gfac ;};_dffg :if data [_cdc ]==46{goto _edg ;};if 48<=data [_cdc ]&&data [_cdc ]<=57{goto _efd ;
};goto _ege ;_edg :if _cdc ++;_cdc ==_ffb {goto _bcd ;};_beb :if 48<=data [_cdc ]&&data [_cdc ]<=57{goto _geee ;};goto _ege ;_geee :if _cdc ++;_cdc ==_ffb {goto _bbd ;};_fgea :if data [_cdc ]==69{goto _aga ;};if 48<=data [_cdc ]&&data [_cdc ]<=57{goto _geee ;
};goto _ege ;_aga :if _cdc ++;_cdc ==_ffb {goto _ccc ;};_gfa :switch data [_cdc ]{case 43:goto _ged ;case 45:goto _ged ;};goto _ege ;_ged :_dga =_cdc +1;_bee =3;goto _ggc ;_bead :_dga =_cdc +1;_bee =2;goto _ggc ;_ggc :if _cdc ++;_cdc ==_ffb {goto _caaf ;
};_gdd :if 48<=data [_cdc ]&&data [_cdc ]<=57{goto _bead ;};goto _ege ;_abc :_fgb :_fca =0;goto _dfd ;_fae :_fca =1;goto _dfd ;_dgd :_fca =2;goto _dfd ;_gfac :_fca =3;goto _dfd ;_bcd :_fca =4;goto _dfd ;_bbd :_fca =5;goto _dfd ;_ccc :_fca =6;goto _dfd ;
_caaf :_fca =7;goto _dfd ;_dfd :{};if _cdc ==_efbe {switch _fca {case 1:goto _fge ;case 2:goto _fge ;case 3:goto _fea ;case 4:goto _fge ;case 5:goto _gff ;case 6:goto _fge ;case 7:goto _dee ;};};};if _fca ==_fga {return false ;};return ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_dd :=Parse (f );if len (_dd )==1{return _ef (v ,_dd [0],false );}else if len (_dd )> 1&&v < 0{return _ef (v ,_dd [1],true );
}else if len (_dd )> 2&&v ==0{return _ef (v ,_dd [2],false );};return _ef (v ,_dd [0],false );};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_gac ,_ :=_a .ParseFloat (v ,64);return Number (_gac ,f );};return String (v ,f );};func _caac (_fcbb _cc .Time ,_cab float64 ,_bge string )[]byte {_de :=[]byte {};_cag :=0;for _cb :=0;_cb < len (_bge );
_cb ++{var _adff string ;if _bge [_cb ]==':'{_adff =string (_bge [_cag :_cb ]);_cag =_cb +1;}else if _cb ==len (_bge )-1{_adff =string (_bge [_cag :_cb +1]);}else {continue ;};switch _adff {case "\u0064":_de =_fcbb .AppendFormat (_de ,"\u0032");case "\u0068":_de =_fcbb .AppendFormat (_de ,"\u0033");
case "\u0068\u0068":_de =_fcbb .AppendFormat (_de ,"\u0031\u0035");case "\u006d":_de =_fcbb .AppendFormat (_de ,"\u0034");case "\u006d\u006d":_de =_fcbb .AppendFormat (_de ,"\u0030\u0034");case "\u0073":_de =_fcbb .Round (_cc .Second ).AppendFormat (_de ,"\u0035");
case "\u0073\u002e\u0030":_de =_fcbb .Round (_cc .Second /10).AppendFormat (_de ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_de =_fcbb .Round (_cc .Second /100).AppendFormat (_de ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_de =_fcbb .Round (_cc .Second /1000).AppendFormat (_de ,"\u0035\u002e\u00300\u0030");
case "\u0073\u0073":_de =_fcbb .Round (_cc .Second ).AppendFormat (_de ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_de =_fcbb .Round (_cc .Second /10).AppendFormat (_de ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_de =_fcbb .Round (_cc .Second /100).AppendFormat (_de ,"\u0030\u0035\u002e0\u0030");
case "\u0073\u0073\u002e\u0030\u0030\u0030":_de =_fcbb .Round (_cc .Second /1000).AppendFormat (_de ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_de =_fcbb .AppendFormat (_de ,"\u0050\u004d");case "\u005b\u0068\u005d":_de =_a .AppendInt (_de ,int64 (_cab *24),10);
case "\u005b\u006d\u005d":_de =_a .AppendInt (_de ,int64 (_cab *24*60),10);case "\u005b\u0073\u005d":_de =_a .AppendInt (_de ,int64 (_cab *24*60*60),10);case "":default:_fc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_adff );
};if _bge [_cb ]==':'{_de =append (_de ,':');};};return _de ;};const _dde int =0;func (_cdg *Lexer )nextFmt (){_cdg ._ggdc =append (_cdg ._ggdc ,_cdg ._gfe );_cdg ._gfe =Format {}};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;
FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);const _bf =1e11;const _bfa int =34;const _cd ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
func _fbbg (_dgg _cc .Time )_cc .Time {_dgg =_dgg .UTC ();return _cc .Date (_dgg .Year (),_dgg .Month (),_dgg .Day (),_dgg .Hour (),_dgg .Minute (),_dgg .Second (),_dgg .Nanosecond (),_cc .Local );};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_gf bool ;_gdg bool ;_fd bool ;_be bool ;_bec bool ;_dg bool ;_ed int64 ;_ge int ;};func (_fbda *Lexer )Lex (r _f .Reader ){_bdf ,_gdc ,_cgd :=0,0,0;_agfe :=-1;
_ccfb ,_egf ,_fdcd :=0,0,0;_ =_egf ;_ =_fdcd ;_fdda :=1;_ =_fdda ;_gade :=make ([]byte ,4096);_fefb :=false ;for !_fefb {_ccd :=0;if _ccfb > 0{_ccd =_gdc -_ccfb ;};_gdc =0;_geac ,_ada :=r .Read (_gade [_ccd :]);if _geac ==0||_ada !=nil {_fefb =true ;};
_cgd =_geac +_ccd ;if _cgd < len (_gade ){_agfe =_cgd ;};{_bdf =_bfa ;_ccfb =0;_egf =0;_fdcd =0;};{if _gdc ==_cgd {goto _bgbd ;};switch _bdf {case 34:goto _fbe ;case 35:goto _ddg ;case 0:goto _aed ;case 36:goto _bgg ;case 37:goto _cfd ;case 1:goto _fba ;
case 2:goto _bccg ;case 38:goto _dgda ;case 3:goto _gec ;case 4:goto _fed ;case 39:goto _ccff ;case 5:goto _cgdg ;case 6:goto _gbfg ;case 7:goto _aedf ;case 8:goto _efbb ;case 40:goto _dadb ;case 9:goto _bccf ;case 41:goto _ffc ;case 10:goto _def ;case 42:goto _dgdaf ;
case 11:goto _fdg ;case 43:goto _aeff ;case 44:goto _dbd ;case 45:goto _bbgg ;case 12:goto _bca ;case 46:goto _fegb ;case 13:goto _egee ;case 14:goto _fdcc ;case 15:goto _ggf ;case 16:goto _ecf ;case 47:goto _bebc ;case 17:goto _bcde ;case 48:goto _cfbd ;
case 18:goto _eacf ;case 19:goto _bgec ;case 20:goto _ggg ;case 49:goto _eec ;case 50:goto _add ;case 21:goto _ffa ;case 22:goto _deg ;case 23:goto _eagf ;case 24:goto _geace ;case 25:goto _ebf ;case 51:goto _eaa ;case 26:goto _bcdg ;case 52:goto _efcf ;
case 53:goto _fcfa ;case 54:goto _eecd ;case 55:goto _bfag ;case 56:goto _afdf ;case 57:goto _dfc ;case 27:goto _geb ;case 28:goto _dfa ;case 29:goto _dgf ;case 30:goto _ddaa ;case 31:goto _ffae ;case 58:goto _cfe ;case 32:goto _gggd ;case 59:goto _efffg ;
case 33:goto _aecg ;case 60:goto _bfc ;case 61:goto _egec ;case 62:goto _cffe ;};goto _edac ;_cagf :switch _fdcd {case 2:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeDigit ,nil );};case 3:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeDigitOpt ,nil );
};case 5:{_gdc =(_egf )-1;};case 8:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypePercent ,nil );};case 13:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeFraction ,_gade [_ccfb :_egf ]);};case 14:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeDate ,_gade [_ccfb :_egf ]);
};case 15:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeTime ,_gade [_ccfb :_egf ]);};case 16:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeTime ,_gade [_ccfb :_egf ]);};case 18:{_gdc =(_egf )-1;};case 20:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeLiteral ,_gade [_ccfb :_egf ]);
};case 21:{_gdc =(_egf )-1;_fbda ._gfe .AddToken (FmtTypeLiteral ,_gade [_ccfb +1:_egf -1]);};};goto _bag ;_egbe :_gdc =(_egf )-1;{_fbda ._gfe .AddToken (FmtTypeFraction ,_gade [_ccfb :_egf ]);};goto _bag ;_fddc :_gdc =(_egf )-1;{_fbda ._gfe .AddToken (FmtTypeDigitOpt ,nil );
};goto _bag ;_ddef :_egf =_gdc +1;{_fbda ._gfe .AddToken (FmtTypeDigitOptThousands ,nil );};goto _bag ;_cfcd :_gdc =(_egf )-1;{_fbda ._gfe .AddToken (FmtTypePercent ,nil );};goto _bag ;_ced :_gdc =(_egf )-1;{_fbda ._gfe .AddToken (FmtTypeDate ,_gade [_ccfb :_egf ]);
};goto _bag ;_cbg :_gdc =(_egf )-1;{_fbda ._gfe .AddToken (FmtTypeDigit ,nil );};goto _bag ;_aa :_gdc =(_egf )-1;{_fbda ._gfe .AddToken (FmtTypeTime ,_gade [_ccfb :_egf ]);};goto _bag ;_gbfe :_gdc =(_egf )-1;{_fbda ._gfe .AddToken (FmtTypeLiteral ,_gade [_ccfb :_egf ]);
};goto _bag ;_gcce :_egf =_gdc +1;{_fbda ._gfe ._fd =true ;};goto _bag ;_aab :_egf =_gdc +1;{_fbda ._gfe .AddToken (FmtTypeLiteral ,_gade [_ccfb :_egf ]);};goto _bag ;_cbc :_egf =_gdc +1;{_fbda ._gfe .AddToken (FmtTypeDollar ,nil );};goto _bag ;_daa :_egf =_gdc +1;
{_fbda ._gfe .AddToken (FmtTypeComma ,nil );};goto _bag ;_fcd :_egf =_gdc +1;{_fbda ._gfe .AddToken (FmtTypeDecimal ,nil );};goto _bag ;_ebg :_egf =_gdc +1;{_fbda .nextFmt ();};goto _bag ;_eca :_egf =_gdc +1;{_fbda ._gfe .AddToken (FmtTypeText ,nil );};
goto _bag ;_beaa :_egf =_gdc +1;{_fbda ._gfe .AddToken (FmtTypeUnderscore ,nil );};goto _bag ;_daad :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypeLiteral ,_gade [_ccfb :_egf ]);};goto _bag ;_gfd :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypeLiteral ,_gade [_ccfb +1:_egf -1]);
};goto _bag ;_gadf :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypeDigitOpt ,nil );};goto _bag ;_aec :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypeFraction ,_gade [_ccfb :_egf ]);};goto _bag ;_edgd :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypePercent ,nil );
};goto _bag ;_afb :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypeDate ,_gade [_ccfb :_egf ]);};goto _bag ;_fbdc :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypeDigit ,nil );};goto _bag ;_eac :_egf =_gdc ;_gdc --;{_fbda ._gfe .AddToken (FmtTypeTime ,_gade [_ccfb :_egf ]);
};goto _bag ;_dadg :_egf =_gdc ;_gdc --;{};goto _bag ;_eeb :_egf =_gdc +1;{_fbda ._gfe .IsExponential =true ;};goto _bag ;_fec :_egf =_gdc +1;{_fbda ._gfe .AddToken (FmtTypeLiteral ,_gade [_ccfb +1:_egf ]);};goto _bag ;_bag :_ccfb =0;if _gdc ++;_gdc ==_cgd {goto _cdcc ;
};_fbe :_ccfb =_gdc ;switch _gade [_gdc ]{case 34:goto _geg ;case 35:goto _gfg ;case 36:goto _cbc ;case 37:goto _ecaa ;case 44:goto _daa ;case 46:goto _fcd ;case 47:goto _egbea ;case 48:goto _dcd ;case 58:goto _bgaa ;case 59:goto _ebg ;case 63:goto _fcaa ;
case 64:goto _eca ;case 65:goto _gge ;case 69:goto _adec ;case 71:goto _ecc ;case 91:goto _acc ;case 92:goto _edfb ;case 95:goto _beaa ;case 100:goto _egbea ;case 104:goto _bgaa ;case 109:goto _geag ;case 115:goto _gae ;case 121:goto _cagd ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _faeb ;
};goto _aab ;_geg :_egf =_gdc +1;_fdcd =20;goto _edf ;_edf :if _gdc ++;_gdc ==_cgd {goto _bcbg ;};_ddg :if _gade [_gdc ]==34{goto _ggb ;};goto _gcb ;_gcb :if _gdc ++;_gdc ==_cgd {goto _ecaf ;};_aed :if _gade [_gdc ]==34{goto _ggb ;};goto _gcb ;_ggb :_egf =_gdc +1;
_fdcd =21;goto _bebf ;_bebf :if _gdc ++;_gdc ==_cgd {goto _cffb ;};_bgg :if _gade [_gdc ]==34{goto _gcb ;};goto _gfd ;_gfg :_egf =_gdc +1;_fdcd =3;goto _caad ;_caad :if _gdc ++;_gdc ==_cgd {goto _fad ;};_cfd :switch _gade [_gdc ]{case 35:goto _bgb ;case 37:goto _bgb ;
case 44:goto _ded ;case 47:goto _fbef ;case 48:goto _bgb ;case 63:goto _bgb ;};goto _gadf ;_bgb :if _gdc ++;_gdc ==_cgd {goto _fag ;};_fba :switch _gade [_gdc ]{case 35:goto _bgb ;case 37:goto _bgb ;case 47:goto _fbef ;case 48:goto _bgb ;case 63:goto _bgb ;
};goto _cagf ;_fbef :if _gdc ++;_gdc ==_cgd {goto _bbb ;};_bccg :switch _gade [_gdc ]{case 35:goto _bagg ;case 37:goto _dbb ;case 48:goto _fbee ;case 63:goto _bagg ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _ccffe ;};goto _cagf ;_bagg :_egf =_gdc +1;
goto _gab ;_gab :if _gdc ++;_gdc ==_cgd {goto _ecaff ;};_dgda :switch _gade [_gdc ]{case 35:goto _bagg ;case 37:goto _bagg ;case 44:goto _bagg ;case 46:goto _bagg ;case 48:goto _bagg ;case 63:goto _bagg ;case 65:goto _cabc ;};goto _aec ;_cabc :if _gdc ++;
_gdc ==_cgd {goto _defb ;};_gec :switch _gade [_gdc ]{case 47:goto _bdfd ;case 77:goto _dgb ;};goto _egbe ;_bdfd :if _gdc ++;_gdc ==_cgd {goto _agg ;};_fed :if _gade [_gdc ]==80{goto _dce ;};goto _egbe ;_dce :_egf =_gdc +1;goto _afd ;_afd :if _gdc ++;_gdc ==_cgd {goto _gce ;
};_ccff :if _gade [_gdc ]==65{goto _cabc ;};goto _aec ;_dgb :if _gdc ++;_gdc ==_cgd {goto _ggdf ;};_cgdg :if _gade [_gdc ]==47{goto _gdfe ;};goto _egbe ;_gdfe :if _gdc ++;_gdc ==_cgd {goto _fcg ;};_gbfg :if _gade [_gdc ]==80{goto _aabe ;};goto _egbe ;_aabe :if _gdc ++;
_gdc ==_cgd {goto _ceg ;};_aedf :if _gade [_gdc ]==77{goto _dce ;};goto _egbe ;_dbb :if _gdc ++;_gdc ==_cgd {goto _agec ;};_efbb :switch _gade [_gdc ]{case 35:goto _dffc ;case 37:goto _fbg ;case 63:goto _dffc ;};if 48<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _age ;
};goto _cagf ;_dffc :_egf =_gdc +1;goto _cdgc ;_cdgc :if _gdc ++;_gdc ==_cgd {goto _dfbg ;};_dadb :switch _gade [_gdc ]{case 35:goto _bagg ;case 37:goto _cef ;case 44:goto _bagg ;case 46:goto _bagg ;case 48:goto _bagg ;case 63:goto _bagg ;case 65:goto _cabc ;
};goto _aec ;_cef :if _gdc ++;_gdc ==_cgd {goto _egae ;};_bccf :switch _gade [_gdc ]{case 35:goto _ddc ;case 44:goto _ddc ;case 46:goto _ddc ;case 48:goto _ddc ;case 63:goto _ddc ;};goto _egbe ;_ddc :_egf =_gdc +1;goto _fgaf ;_fgaf :if _gdc ++;_gdc ==_cgd {goto _beg ;
};_ffc :switch _gade [_gdc ]{case 35:goto _ddc ;case 44:goto _ddc ;case 46:goto _ddc ;case 48:goto _ddc ;case 63:goto _ddc ;case 65:goto _cabc ;};goto _aec ;_fbg :if _gdc ++;_gdc ==_cgd {goto _bff ;};_def :if _gade [_gdc ]==37{goto _fbg ;};if 48<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _age ;
};goto _cagf ;_age :_egf =_gdc +1;_fdcd =13;goto _edgg ;_edgg :if _gdc ++;_gdc ==_cgd {goto _adc ;};_dgdaf :switch _gade [_gdc ]{case 35:goto _bagg ;case 37:goto _dced ;case 44:goto _bagg ;case 46:goto _bagg ;case 48:goto _aea ;case 63:goto _bagg ;case 65:goto _cabc ;
};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _age ;};goto _aec ;_dced :if _gdc ++;_gdc ==_cgd {goto _gefe ;};_fdg :switch _gade [_gdc ]{case 35:goto _ddc ;case 37:goto _fbg ;case 44:goto _ddc ;case 46:goto _ddc ;case 63:goto _ddc ;};if 48<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _age ;
};goto _egbe ;_aea :_egf =_gdc +1;goto _faf ;_faf :if _gdc ++;_gdc ==_cgd {goto _acd ;};_aeff :switch _gade [_gdc ]{case 35:goto _bagg ;case 37:goto _aea ;case 44:goto _bagg ;case 46:goto _bagg ;case 48:goto _aea ;case 63:goto _bagg ;case 65:goto _cabc ;
};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _age ;};goto _aec ;_fbee :_egf =_gdc +1;goto _dec ;_dec :if _gdc ++;_gdc ==_cgd {goto _bfabb ;};_dbd :switch _gade [_gdc ]{case 35:goto _bagg ;case 37:goto _aea ;case 44:goto _bagg ;case 46:goto _bagg ;case 48:goto _fbee ;
case 63:goto _bagg ;case 65:goto _cabc ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _ccffe ;};goto _aec ;_ccffe :_egf =_gdc +1;goto _ccb ;_ccb :if _gdc ++;_gdc ==_cgd {goto _ebaa ;};_bbgg :switch _gade [_gdc ]{case 35:goto _bagg ;case 37:goto _age ;
case 44:goto _bagg ;case 46:goto _bagg ;case 48:goto _fbee ;case 63:goto _bagg ;case 65:goto _cabc ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _ccffe ;};goto _aec ;_ded :if _gdc ++;_gdc ==_cgd {goto _aeb ;};_bca :if _gade [_gdc ]==35{goto _ddef ;};
goto _fddc ;_ecaa :_egf =_gdc +1;_fdcd =8;goto _fafb ;_fafb :if _gdc ++;_gdc ==_cgd {goto _fded ;};_fegb :switch _gade [_gdc ]{case 35:goto _gcg ;case 37:goto _fcef ;case 48:goto _bce ;case 63:goto _gcg ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _eba ;
};goto _edgd ;_gcg :if _gdc ++;_gdc ==_cgd {goto _dcdc ;};_egee :switch _gade [_gdc ]{case 35:goto _gcg ;case 47:goto _fbef ;case 48:goto _gcg ;case 63:goto _gcg ;};goto _cfcd ;_fcef :if _gdc ++;_gdc ==_cgd {goto _aabd ;};_fdcc :if _gade [_gdc ]==37{goto _fcef ;
};if 48<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _eba ;};goto _cagf ;_eba :if _gdc ++;_gdc ==_cgd {goto _fcfd ;};_ggf :switch _gade [_gdc ]{case 37:goto _fcef ;case 47:goto _fbef ;};if 48<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _eba ;};goto _cagf ;_bce :if _gdc ++;
_gdc ==_cgd {goto _agdd ;};_ecf :switch _gade [_gdc ]{case 35:goto _gcg ;case 37:goto _fcef ;case 47:goto _fbef ;case 48:goto _bce ;case 63:goto _gcg ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _eba ;};goto _cfcd ;_egbea :_egf =_gdc +1;goto _aae ;_aae :if _gdc ++;
_gdc ==_cgd {goto _gacf ;};_bebc :switch _gade [_gdc ]{case 47:goto _egbea ;case 100:goto _egbea ;case 109:goto _egbea ;case 121:goto _dgad ;};goto _afb ;_dgad :if _gdc ++;_gdc ==_cgd {goto _ddb ;};_bcde :if _gade [_gdc ]==121{goto _egbea ;};goto _ced ;
_dcd :_egf =_gdc +1;_fdcd =2;goto _bcda ;_bcda :if _gdc ++;_gdc ==_cgd {goto _eeae ;};_cfbd :switch _gade [_gdc ]{case 35:goto _bgb ;case 37:goto _agb ;case 47:goto _fbef ;case 48:goto _caf ;case 63:goto _bgb ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _fbb ;
};goto _fbdc ;_agb :if _gdc ++;_gdc ==_cgd {goto _gddg ;};_eacf :switch _gade [_gdc ]{case 35:goto _bgb ;case 37:goto _agb ;case 47:goto _fbef ;case 48:goto _agb ;case 63:goto _bgb ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _eba ;};goto _cbg ;_caf :if _gdc ++;
_gdc ==_cgd {goto _egc ;};_bgec :switch _gade [_gdc ]{case 35:goto _bgb ;case 37:goto _agb ;case 47:goto _fbef ;case 48:goto _caf ;case 63:goto _bgb ;};if 49<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _fbb ;};goto _cbg ;_fbb :if _gdc ++;_gdc ==_cgd {goto _befa ;
};_ggg :switch _gade [_gdc ]{case 37:goto _eba ;case 47:goto _fbef ;};if 48<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _fbb ;};goto _cagf ;_faeb :_egf =_gdc +1;_fdcd =20;goto _gfda ;_gfda :if _gdc ++;_gdc ==_cgd {goto _efga ;};_eec :switch _gade [_gdc ]{case 37:goto _eba ;
case 47:goto _fbef ;};if 48<=_gade [_gdc ]&&_gade [_gdc ]<=57{goto _fbb ;};goto _daad ;_bgaa :_egf =_gdc +1;_fdcd =15;goto _afe ;_afe :if _gdc ++;_gdc ==_cgd {goto _cdba ;};_add :switch _gade [_gdc ]{case 58:goto _bgaa ;case 65:goto _cfce ;case 104:goto _bgaa ;
case 109:goto _bgaa ;case 115:goto _gae ;};goto _eac ;_cfce :if _gdc ++;_gdc ==_cgd {goto _adad ;};_ffa :switch _gade [_gdc ]{case 47:goto _dcc ;case 77:goto _geed ;};goto _cagf ;_dcc :if _gdc ++;_gdc ==_cgd {goto _cgc ;};_deg :if _gade [_gdc ]==80{goto _bgaa ;
};goto _cagf ;_geed :if _gdc ++;_gdc ==_cgd {goto _bbdf ;};_eagf :if _gade [_gdc ]==47{goto _aefb ;};goto _cagf ;_aefb :if _gdc ++;_gdc ==_cgd {goto _aff ;};_geace :if _gade [_gdc ]==80{goto _dda ;};goto _cagf ;_dda :if _gdc ++;_gdc ==_cgd {goto _agga ;
};_ebf :if _gade [_gdc ]==77{goto _bgaa ;};goto _cagf ;_gae :_egf =_gdc +1;_fdcd =15;goto _beda ;_beda :if _gdc ++;_gdc ==_cgd {goto _ffd ;};_eaa :switch _gade [_gdc ]{case 46:goto _dba ;case 58:goto _bgaa ;case 65:goto _cfce ;case 104:goto _bgaa ;case 109:goto _bgaa ;
case 115:goto _gae ;};goto _eac ;_dba :if _gdc ++;_gdc ==_cgd {goto _dbc ;};_bcdg :if _gade [_gdc ]==48{goto _effff ;};goto _aa ;_effff :_egf =_gdc +1;_fdcd =15;goto _egga ;_egga :if _gdc ++;_gdc ==_cgd {goto _fdee ;};_efcf :switch _gade [_gdc ]{case 48:goto _cdb ;
case 58:goto _bgaa ;case 65:goto _cfce ;case 104:goto _bgaa ;case 109:goto _bgaa ;case 115:goto _gae ;};goto _eac ;_cdb :_egf =_gdc +1;_fdcd =15;goto _afa ;_afa :if _gdc ++;_gdc ==_cgd {goto _ggdce ;};_fcfa :switch _gade [_gdc ]{case 48:goto _bgaa ;case 58:goto _bgaa ;
case 65:goto _cfce ;case 104:goto _bgaa ;case 109:goto _bgaa ;case 115:goto _gae ;};goto _eac ;_fcaa :_egf =_gdc +1;_fdcd =5;goto _ffag ;_ffag :if _gdc ++;_gdc ==_cgd {goto _cefc ;};_eecd :switch _gade [_gdc ]{case 35:goto _bgb ;case 37:goto _bgb ;case 47:goto _fbef ;
case 48:goto _bgb ;case 63:goto _bgb ;};goto _dadg ;_gge :_egf =_gdc +1;_fdcd =20;goto _eea ;_eea :if _gdc ++;_gdc ==_cgd {goto _gaae ;};_bfag :switch _gade [_gdc ]{case 47:goto _dcc ;case 77:goto _geed ;};goto _daad ;_adec :if _gdc ++;_gdc ==_cgd {goto _ffac ;
};_afdf :switch _gade [_gdc ]{case 43:goto _eeb ;case 45:goto _eeb ;};goto _daad ;_ecc :_egf =_gdc +1;goto _gbce ;_gbce :if _gdc ++;_gdc ==_cgd {goto _gag ;};_dfc :if _gade [_gdc ]==101{goto _fcca ;};goto _daad ;_fcca :if _gdc ++;_gdc ==_cgd {goto _efcd ;
};_geb :if _gade [_gdc ]==110{goto _gbac ;};goto _gbfe ;_gbac :if _gdc ++;_gdc ==_cgd {goto _cgfe ;};_dfa :if _gade [_gdc ]==101{goto _bfab ;};goto _gbfe ;_bfab :if _gdc ++;_gdc ==_cgd {goto _gbd ;};_dgf :if _gade [_gdc ]==114{goto _aee ;};goto _gbfe ;
_aee :if _gdc ++;_gdc ==_cgd {goto _bdb ;};_ddaa :if _gade [_gdc ]==97{goto _gdgd ;};goto _gbfe ;_gdgd :if _gdc ++;_gdc ==_cgd {goto _gbba ;};_ffae :if _gade [_gdc ]==108{goto _gcce ;};goto _gbfe ;_acc :_egf =_gdc +1;_fdcd =20;goto _cfcde ;_cfcde :if _gdc ++;
_gdc ==_cgd {goto _affe ;};_cfe :switch _gade [_gdc ]{case 104:goto _afc ;case 109:goto _afc ;case 115:goto _afc ;};goto _bcdd ;_bcdd :if _gdc ++;_gdc ==_cgd {goto _bdeae ;};_gggd :if _gade [_gdc ]==93{goto _cbf ;};goto _bcdd ;_cbf :_egf =_gdc +1;_fdcd =18;
goto _gffe ;_fefe :_egf =_gdc +1;_fdcd =16;goto _gffe ;_gffe :if _gdc ++;_gdc ==_cgd {goto _dccg ;};_efffg :if _gade [_gdc ]==93{goto _cbf ;};goto _bcdd ;_afc :if _gdc ++;_gdc ==_cgd {goto _cagc ;};_aecg :if _gade [_gdc ]==93{goto _fefe ;};goto _bcdd ;
_edfb :if _gdc ++;_gdc ==_cgd {goto _ffcd ;};_bfc :goto _fec ;_geag :_egf =_gdc +1;_fdcd =14;goto _fbbe ;_fbbe :if _gdc ++;_gdc ==_cgd {goto _acg ;};_egec :switch _gade [_gdc ]{case 47:goto _egbea ;case 58:goto _bgaa ;case 65:goto _cfce ;case 100:goto _egbea ;
case 104:goto _bgaa ;case 109:goto _geag ;case 115:goto _gae ;case 121:goto _dgad ;};goto _afb ;_cagd :if _gdc ++;_gdc ==_cgd {goto _bgee ;};_cffe :if _gade [_gdc ]==121{goto _egbea ;};goto _daad ;_edac :_cdcc :_bdf =34;goto _bgbd ;_bcbg :_bdf =35;goto _bgbd ;
_ecaf :_bdf =0;goto _bgbd ;_cffb :_bdf =36;goto _bgbd ;_fad :_bdf =37;goto _bgbd ;_fag :_bdf =1;goto _bgbd ;_bbb :_bdf =2;goto _bgbd ;_ecaff :_bdf =38;goto _bgbd ;_defb :_bdf =3;goto _bgbd ;_agg :_bdf =4;goto _bgbd ;_gce :_bdf =39;goto _bgbd ;_ggdf :_bdf =5;
goto _bgbd ;_fcg :_bdf =6;goto _bgbd ;_ceg :_bdf =7;goto _bgbd ;_agec :_bdf =8;goto _bgbd ;_dfbg :_bdf =40;goto _bgbd ;_egae :_bdf =9;goto _bgbd ;_beg :_bdf =41;goto _bgbd ;_bff :_bdf =10;goto _bgbd ;_adc :_bdf =42;goto _bgbd ;_gefe :_bdf =11;goto _bgbd ;
_acd :_bdf =43;goto _bgbd ;_bfabb :_bdf =44;goto _bgbd ;_ebaa :_bdf =45;goto _bgbd ;_aeb :_bdf =12;goto _bgbd ;_fded :_bdf =46;goto _bgbd ;_dcdc :_bdf =13;goto _bgbd ;_aabd :_bdf =14;goto _bgbd ;_fcfd :_bdf =15;goto _bgbd ;_agdd :_bdf =16;goto _bgbd ;_gacf :_bdf =47;
goto _bgbd ;_ddb :_bdf =17;goto _bgbd ;_eeae :_bdf =48;goto _bgbd ;_gddg :_bdf =18;goto _bgbd ;_egc :_bdf =19;goto _bgbd ;_befa :_bdf =20;goto _bgbd ;_efga :_bdf =49;goto _bgbd ;_cdba :_bdf =50;goto _bgbd ;_adad :_bdf =21;goto _bgbd ;_cgc :_bdf =22;goto _bgbd ;
_bbdf :_bdf =23;goto _bgbd ;_aff :_bdf =24;goto _bgbd ;_agga :_bdf =25;goto _bgbd ;_ffd :_bdf =51;goto _bgbd ;_dbc :_bdf =26;goto _bgbd ;_fdee :_bdf =52;goto _bgbd ;_ggdce :_bdf =53;goto _bgbd ;_cefc :_bdf =54;goto _bgbd ;_gaae :_bdf =55;goto _bgbd ;_ffac :_bdf =56;
goto _bgbd ;_gag :_bdf =57;goto _bgbd ;_efcd :_bdf =27;goto _bgbd ;_cgfe :_bdf =28;goto _bgbd ;_gbd :_bdf =29;goto _bgbd ;_bdb :_bdf =30;goto _bgbd ;_gbba :_bdf =31;goto _bgbd ;_affe :_bdf =58;goto _bgbd ;_bdeae :_bdf =32;goto _bgbd ;_dccg :_bdf =59;goto _bgbd ;
_cagc :_bdf =33;goto _bgbd ;_ffcd :_bdf =60;goto _bgbd ;_acg :_bdf =61;goto _bgbd ;_bgee :_bdf =62;goto _bgbd ;_bgbd :{};if _gdc ==_agfe {switch _bdf {case 35:goto _daad ;case 0:goto _cagf ;case 36:goto _gfd ;case 37:goto _gadf ;case 1:goto _cagf ;case 2:goto _cagf ;
case 38:goto _aec ;case 3:goto _egbe ;case 4:goto _egbe ;case 39:goto _aec ;case 5:goto _egbe ;case 6:goto _egbe ;case 7:goto _egbe ;case 8:goto _cagf ;case 40:goto _aec ;case 9:goto _egbe ;case 41:goto _aec ;case 10:goto _cagf ;case 42:goto _aec ;case 11:goto _egbe ;
case 43:goto _aec ;case 44:goto _aec ;case 45:goto _aec ;case 12:goto _fddc ;case 46:goto _edgd ;case 13:goto _cfcd ;case 14:goto _cagf ;case 15:goto _cagf ;case 16:goto _cfcd ;case 47:goto _afb ;case 17:goto _ced ;case 48:goto _fbdc ;case 18:goto _cbg ;
case 19:goto _cbg ;case 20:goto _cagf ;case 49:goto _daad ;case 50:goto _eac ;case 21:goto _cagf ;case 22:goto _cagf ;case 23:goto _cagf ;case 24:goto _cagf ;case 25:goto _cagf ;case 51:goto _eac ;case 26:goto _aa ;case 52:goto _eac ;case 53:goto _eac ;
case 54:goto _dadg ;case 55:goto _daad ;case 56:goto _daad ;case 57:goto _daad ;case 27:goto _gbfe ;case 28:goto _gbfe ;case 29:goto _gbfe ;case 30:goto _gbfe ;case 31:goto _gbfe ;case 58:goto _daad ;case 32:goto _cagf ;case 59:goto _cagf ;case 33:goto _gbfe ;
case 60:goto _daad ;case 61:goto _afb ;case 62:goto _daad ;};};};if _ccfb > 0{copy (_gade [0:],_gade [_ccfb :]);};};_ =_agfe ;if _bdf ==_fga {_fc .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};
};const _fga int =-1;

// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;const _gd =1e-10;