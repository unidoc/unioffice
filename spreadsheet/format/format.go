//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_c "bytes";_b "fmt";_ee "github.com/unidoc/unioffice/v2/common/logger";_e "io";_gg "math";_eb "strconv";_g "strings";_ac "time";);

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_ab :=Parse (f );if len (_ab )==1{return _be (v ,_ab [0],false );}else if len (_ab )> 1&&v < 0{return _be (v ,_ab [1],true );
}else if len (_ab )> 2&&v ==0{return _be (v ,_ab [2],false );};return _be (v ,_ab [0],false );};func _ebg (_dbc int64 )int64 {if _dbc < 0{return -_dbc ;};return _dbc ;};func IsNumber (data string )(_gdb bool ){_fdf ,_ebf ,_dda :=0,0,len (data );_gcd :=len (data );
_eaf ,_gcag ,_aad :=0,0,0;_ =_gcag ;_ =_aad ;_ =_eaf ;{_fdf =_afff ;_eaf =0;_gcag =0;_aad =0;};{if _ebf ==_dda {goto _fgfd ;};switch _fdf {case 0:goto _cad ;case 1:goto _dfd ;case 2:goto _ebd ;case 3:goto _beeg ;case 4:goto _fcf ;case 5:goto _fcec ;case 6:goto _fbd ;
case 7:goto _gbf ;};goto _ggf ;_ccf :_gcag =_ebf ;_ebf --;{_gdb =false ;};goto _fbc ;_gbd :_gcag =_ebf ;_ebf --;{_gdb =_gcag ==len (data );};goto _fbc ;_fccd :_gcag =_ebf ;_ebf --;{_gdb =_gcag ==len (data );};goto _fbc ;_afce :switch _aad {case 2:{_ebf =(_gcag )-1;
_gdb =_gcag ==len (data );};case 3:{_ebf =(_gcag )-1;_gdb =false ;};};goto _fbc ;_fbc :_eaf =0;if _ebf ++;_ebf ==_dda {goto _ddc ;};_cad :_eaf =_ebf ;switch data [_ebf ]{case 43:goto _fca ;case 45:goto _fca ;};if 48<=data [_ebf ]&&data [_ebf ]<=57{goto _acac ;
};goto _efc ;_efc :if _ebf ++;_ebf ==_dda {goto _faf ;};_dfd :goto _efc ;_fca :if _ebf ++;_ebf ==_dda {goto _fed ;};_ebd :if 48<=data [_ebf ]&&data [_ebf ]<=57{goto _acac ;};goto _efc ;_acac :if _ebf ++;_ebf ==_dda {goto _aaaa ;};_beeg :if data [_ebf ]==46{goto _bfc ;
};if 48<=data [_ebf ]&&data [_ebf ]<=57{goto _acac ;};goto _efc ;_bfc :if _ebf ++;_ebf ==_dda {goto _ded ;};_fcf :if 48<=data [_ebf ]&&data [_ebf ]<=57{goto _bfe ;};goto _efc ;_bfe :if _ebf ++;_ebf ==_dda {goto _cab ;};_fcec :if data [_ebf ]==69{goto _fac ;
};if 48<=data [_ebf ]&&data [_ebf ]<=57{goto _bfe ;};goto _efc ;_fac :if _ebf ++;_ebf ==_dda {goto _eae ;};_fbd :switch data [_ebf ]{case 43:goto _acab ;case 45:goto _acab ;};goto _efc ;_acab :_gcag =_ebf +1;_aad =3;goto _gccg ;_ceda :_gcag =_ebf +1;_aad =2;
goto _gccg ;_gccg :if _ebf ++;_ebf ==_dda {goto _gcagc ;};_gbf :if 48<=data [_ebf ]&&data [_ebf ]<=57{goto _ceda ;};goto _efc ;_ggf :_ddc :_fdf =0;goto _fgfd ;_faf :_fdf =1;goto _fgfd ;_fed :_fdf =2;goto _fgfd ;_aaaa :_fdf =3;goto _fgfd ;_ded :_fdf =4;
goto _fgfd ;_cab :_fdf =5;goto _fgfd ;_eae :_fdf =6;goto _fgfd ;_gcagc :_fdf =7;goto _fgfd ;_fgfd :{};if _ebf ==_gcd {switch _fdf {case 1:goto _ccf ;case 2:goto _ccf ;case 3:goto _gbd ;case 4:goto _ccf ;case 5:goto _fccd ;case 6:goto _ccf ;case 7:goto _afce ;
};};};if _fdf ==_eee {return false ;};return ;};const _eee int =-1;

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};func Parse (s string )[]Format {_fae :=Lexer {};_fae .Lex (_g .NewReader (s ));_fae ._ecac =append (_fae ._ecac ,_fae ._cce );return _fae ._ecac ;};const _fc =1e11;func _be (_ga float64 ,_cda Format ,_dbf bool )string {if _cda ._aa {return NumberGeneric (_ga );
};_cfd :=make ([]byte ,0,20);_cgf :=_gg .Signbit (_ga );_gge :=_gg .Abs (_ga );_ceb :=int64 (0);_fa :=int64 (0);if _cda .IsExponential {for _gge >=10{_fa ++;_gge /=10;};for _gge < 1{_fa --;_gge *=10;};}else if _cda ._ec {_gge *=100;}else if _cda ._fcc {if _cda ._cc ==0{_ggbe :=_gg .Pow (10,float64 (_cda ._dg ));
_bg ,_bga :=1.0,1.0;_ =_bg ;for _efe :=1.0;_efe < _ggbe ;_efe ++{_ ,_cdd :=_gg .Modf (_gge *float64 (_efe ));if _cdd < _bga {_bga =_cdd ;_bg =_efe ;if _cdd ==0{break ;};};};_cda ._cc =int64 (_bg );};_ceb =int64 (_gge *float64 (_cda ._cc )+0.5);if len (_cda .Whole )> 0&&_ceb > _cda ._cc {_ceb =int64 (_gge *float64 (_cda ._cc ))%_cda ._cc ;
_gge -=float64 (_ceb )/float64 (_cda ._cc );}else {_gge -=float64 (_ceb )/float64 (_cda ._cc );if _gg .Abs (_gge )< 1{_aeg :=true ;for _ ,_aca :=range _cda .Whole {if _aca .Type ==FmtTypeDigitOpt {continue ;};if _aca .Type ==FmtTypeLiteral &&_aca .Literal ==' '{continue ;
};_aeg =false ;};if _aeg {_cda .Whole =nil ;};};};};_gad :=1;for _ ,_acc :=range _cda .Fractional {if _acc .Type ==FmtTypeDigit ||_acc .Type ==FmtTypeDigitOpt {_gad ++;};};_gge +=5*_gg .Pow10 (-_gad );_bac ,_ged :=_gg .Modf (_gge );_cfd =append (_cfd ,_fe (_bac ,_ga ,_cda )...);
_cfd =append (_cfd ,_ag (_ged ,_ga ,_cda )...);_cfd =append (_cfd ,_fgg (_fa ,_cda )...);if _cda ._fcc {_cfd =_eb .AppendInt (_cfd ,_ceb ,10);_cfd =append (_cfd ,'/');_cfd =_eb .AppendInt (_cfd ,_cda ._cc ,10);};if !_dbf &&_cgf {return "\u002d"+string (_cfd );
};return string (_cfd );};func _ag (_feg ,_age float64 ,_bed Format )[]byte {if len (_bed .Fractional )==0{return nil ;};_accb :=_eb .AppendFloat (nil ,_feg ,'f',-1,64);if len (_accb )> 2{_accb =_accb [2:];}else {_accb =nil ;};_afe :=make ([]byte ,0,len (_accb ));
_afe =append (_afe ,'.');_ede :=0;_dde :for _afc :=0;_afc < len (_bed .Fractional );_afc ++{_bc :=_afc ;_fd :=_bed .Fractional [_afc ];switch _fd .Type {case FmtTypeDigit :if _bc < len (_accb ){_afe =append (_afe ,_accb [_bc ]);_ede ++;}else {_afe =append (_afe ,'0');
};case FmtTypeDigitOpt :if _bc >=0{_afe =append (_afe ,_accb [_bc ]);_ede ++;}else {break _dde ;};case FmtTypeLiteral :_afe =append (_afe ,_fd .Literal );default:_ee .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_fd );
};};return _afe ;};const _cgc int =-1;

// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;func _ebed (_efee []byte )[]byte {_faa :=len (_efee );_gca :=false ;_bgg :=false ;for _bf :=len (_efee )-1;_bf >=0;_bf --{if _efee [_bf ]=='0'&&!_bgg &&!_gca {_faa =_bf ;}else if _efee [_bf ]=='.'{_gca =true ;}else {_bgg =true ;};};if _gca &&_bgg {if _efee [_faa -1]=='.'{_faa --;
};return _efee [0:_faa ];};return _efee ;};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;
FmtTypeText ;);const _dbe int =0;

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_fcc bool ;_ec bool ;_aa bool ;_fg bool ;_aaa bool ;_d bool ;_cc int64 ;_dg int ;};func _fgg (_eaa int64 ,_cag Format )[]byte {if !_cag .IsExponential ||len (_cag .Exponent )==0{return nil ;
};_agg :=_eb .AppendInt (nil ,_ebg (_eaa ),10);_edg :=make ([]byte ,0,len (_agg )+2);_edg =append (_edg ,'E');if _eaa >=0{_edg =append (_edg ,'+');}else {_edg =append (_edg ,'-');_eaa *=-1;};_ffd :=0;_gadg :for _afeb :=len (_cag .Exponent )-1;_afeb >=0;
_afeb --{_afg :=len (_agg )-1-_ffd ;_bdbb :=_cag .Exponent [_afeb ];switch _bdbb .Type {case FmtTypeDigit :if _afg >=0{_edg =append (_edg ,_agg [_afg ]);_ffd ++;}else {_edg =append (_edg ,'0');};case FmtTypeDigitOpt :if _afg >=0{_edg =append (_edg ,_agg [_afg ]);
_ffd ++;}else {for _cbd :=_afeb ;_cbd >=0;_cbd --{_ccaa :=_cag .Exponent [_cbd ];if _ccaa .Type ==FmtTypeLiteral {_edg =append (_edg ,_ccaa .Literal );};};break _gadg ;};case FmtTypeLiteral :_edg =append (_edg ,_bdbb .Literal );default:_ee .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_bdbb );
};};if _ffd < len (_agg ){_edg =append (_edg ,_agg [len (_agg )-_ffd -1:_ffd -1]...);};_gcc (_edg [2:]);return _edg ;};type Lexer struct{_cce Format ;_ecac []Format ;};func _gcc (_gcb []byte )[]byte {for _cf :=0;_cf < len (_gcb )/2;_cf ++{_ef :=len (_gcb )-1-_cf ;
_gcb [_cf ],_gcb [_ef ]=_gcb [_ef ],_gcb [_cf ];};return _gcb ;};const _fegc int =34;func _fb (_fde []byte )[]byte {for _ad :=len (_fde )-1;_ad > 0;_ad --{if _fde [_ad ]=='9'+1{_fde [_ad ]='0';if _fde [_ad -1]=='.'{_ad --;};_fde [_ad -1]++;};};if _fde [0]=='9'+1{_fde [0]='0';
copy (_fde [1:],_fde [0:]);_fde [0]='1';};return _fde ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _gg .Abs (v )>=_fc ||_gg .Abs (v )<=_bd &&v !=0{return _feb (v );};_edf :=make ([]byte ,0,15);_edf =_eb .AppendFloat (_edf ,v ,'f',-1,64);if len (_edf )> 11{_gee :=_edf [11]-'0';if _gee >=5&&_gee <=9{_edf [10]++;
_edf =_edf [0:11];_edf =_fb (_edf );};_edf =_edf [0:11];}else if len (_edf )==11{if _edf [len (_edf )-1]=='9'{_edf [len (_edf )-1]++;_edf =_fb (_edf );};};_edf =_ebed (_edf );return string (_edf );};func _fe (_gd ,_dae float64 ,_cfb Format )[]byte {if len (_cfb .Whole )==0{return nil ;
};_eg :=_ac .Date (1899,12,30,0,0,0,0,_ac .UTC );_gb :=_eg .Add (_ac .Duration (_dae *float64 (24*_ac .Hour )));_gb =_gged (_gb );_ebe :=_eb .AppendFloat (nil ,_gd ,'f',-1,64);_caf :=make ([]byte ,0,len (_ebe ));_df :=0;_afa :=1;_gdg :for _dfc :=len (_cfb .Whole )-1;
_dfc >=0;_dfc --{_gba :=len (_ebe )-1-_df ;_ced :=_cfb .Whole [_dfc ];switch _ced .Type {case FmtTypeDigit :if _gba >=0{_caf =append (_caf ,_ebe [_gba ]);_df ++;_afa =_dfc ;}else {_caf =append (_caf ,'0');};case FmtTypeDigitOpt :if _gba >=0{_caf =append (_caf ,_ebe [_gba ]);
_df ++;_afa =_dfc ;}else {for _ff :=_dfc ;_ff >=0;_ff --{_cb :=_cfb .Whole [_ff ];if _cb .Type ==FmtTypeLiteral {_caf =append (_caf ,_cb .Literal );};};break _gdg ;};case FmtTypeDollar :for _edb :=_df ;_edb < len (_ebe );_edb ++{_caf =append (_caf ,_ebe [len (_ebe )-1-_edb ]);
_df ++;};_caf =append (_caf ,'$');case FmtTypeComma :if !_cfb ._fg {_caf =append (_caf ,',');};case FmtTypeLiteral :_caf =append (_caf ,_ced .Literal );case FmtTypeDate :_caf =append (_caf ,_gcc (_ecf (_gb ,_ced .DateTime ))...);case FmtTypeTime :_caf =append (_caf ,_gcc (_bcc (_gb ,_dae ,_ced .DateTime ))...);
default:_ee .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_ced );};};_eag :=_gcc (_caf );if _df < len (_ebe )&&(_df !=0||_cfb ._d ){_ggeg :=len (_ebe )-_df ;
_bee :=make ([]byte ,len (_eag )+_ggeg );copy (_bee ,_eag [0:_afa ]);copy (_bee [_afa :],_ebe [0:]);copy (_bee [_afa +_ggeg :],_eag [_afa :]);_eag =_bee ;};if _cfb ._fg {_aaf :=_c .Buffer {};_cca :=0;for _beg :=len (_eag )-1;_beg >=0;_beg --{if !(_eag [_beg ]>='0'&&_eag [_beg ]<='9'){_cca ++;
}else {break ;};};for _gbc :=0;_gbc < len (_eag );_gbc ++{_bdb :=(len (_eag )-_gbc -_cca );if _bdb %3==0&&_bdb !=0&&_gbc !=0{_aaf .WriteByte (',');};_aaf .WriteByte (_eag [_gbc ]);};_eag =_aaf .Bytes ();};return _eag ;};var _f =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};
const _ba ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
func (_abb *Lexer )Lex (r _e .Reader ){_dfe ,_dad ,_bfb :=0,0,0;_facg :=-1;_cfbe ,_bef ,_cgcb :=0,0,0;_ =_bef ;_ =_cgcb ;_bdbg :=1;_ =_bdbg ;_daf :=make ([]byte ,4096);_cbdd :=false ;for !_cbdd {_cdg :=0;if _cfbe > 0{_cdg =_dad -_cfbe ;};_dad =0;_gde ,_fef :=r .Read (_daf [_cdg :]);
if _gde ==0||_fef !=nil {_cbdd =true ;};_bfb =_gde +_cdg ;if _bfb < len (_daf ){_facg =_bfb ;};{_dfe =_afb ;_cfbe =0;_bef =0;_cgcb =0;};{if _dad ==_bfb {goto _eccd ;};switch _dfe {case 34:goto _cfc ;case 35:goto _bgaf ;case 0:goto _ccc ;case 36:goto _bgge ;
case 37:goto _bbb ;case 1:goto _dcd ;case 2:goto _eea ;case 38:goto _fgb ;case 3:goto _bafb ;case 4:goto _ebc ;case 39:goto _eebb ;case 5:goto _adec ;case 6:goto _cec ;case 7:goto _acbf ;case 8:goto _egg ;case 40:goto _fcad ;case 9:goto _aga ;case 41:goto _cgd ;
case 10:goto _bafa ;case 42:goto _bccg ;case 11:goto _efb ;case 43:goto _fcfd ;case 44:goto _gfbg ;case 45:goto _aafa ;case 12:goto _efg ;case 46:goto _babc ;case 13:goto _cefd ;case 14:goto _fbg ;case 15:goto _cbf ;case 16:goto _gaea ;case 47:goto _ddeb ;
case 17:goto _eeed ;case 48:goto _afbd ;case 18:goto _gaf ;case 19:goto _ffc ;case 20:goto _bggd ;case 49:goto _gec ;case 50:goto _eda ;case 21:goto _cage ;case 22:goto _beegf ;case 23:goto _dge ;case 24:goto _dec ;case 25:goto _cbba ;case 51:goto _fda ;
case 26:goto _fbfd ;case 52:goto _gffc ;case 53:goto _acg ;case 54:goto _fcfa ;case 55:goto _cafg ;case 56:goto _fbfc ;case 57:goto _dcfb ;case 27:goto _gadd ;case 28:goto _dgeg ;case 29:goto _eafd ;case 30:goto _eafa ;case 31:goto _acfa ;case 58:goto _ege ;
case 32:goto _bbc ;case 59:goto _fddd ;case 33:goto _cgcc ;case 60:goto _ffca ;case 61:goto _agb ;case 62:goto _aege ;};goto _febf ;_gac :switch _cgcb {case 2:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeDigit ,nil );};case 3:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeDigitOpt ,nil );
};case 5:{_dad =(_bef )-1;};case 8:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypePercent ,nil );};case 13:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeFraction ,_daf [_cfbe :_bef ]);};case 14:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeDate ,_daf [_cfbe :_bef ]);
};case 15:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeTime ,_daf [_cfbe :_bef ]);};case 16:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeTime ,_daf [_cfbe :_bef ]);};case 18:{_dad =(_bef )-1;};case 20:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeLiteral ,_daf [_cfbe :_bef ]);
};case 21:{_dad =(_bef )-1;_abb ._cce .AddToken (FmtTypeLiteral ,_daf [_cfbe +1:_bef -1]);};};goto _cfgd ;_eeg :_dad =(_bef )-1;{_abb ._cce .AddToken (FmtTypeFraction ,_daf [_cfbe :_bef ]);};goto _cfgd ;_gfb :_dad =(_bef )-1;{_abb ._cce .AddToken (FmtTypeDigitOpt ,nil );
};goto _cfgd ;_cef :_bef =_dad +1;{_abb ._cce .AddToken (FmtTypeDigitOptThousands ,nil );};goto _cfgd ;_ece :_dad =(_bef )-1;{_abb ._cce .AddToken (FmtTypePercent ,nil );};goto _cfgd ;_aed :_dad =(_bef )-1;{_abb ._cce .AddToken (FmtTypeDate ,_daf [_cfbe :_bef ]);
};goto _cfgd ;_geed :_dad =(_bef )-1;{_abb ._cce .AddToken (FmtTypeDigit ,nil );};goto _cfgd ;_bae :_dad =(_bef )-1;{_abb ._cce .AddToken (FmtTypeTime ,_daf [_cfbe :_bef ]);};goto _cfgd ;_ecc :_dad =(_bef )-1;{_abb ._cce .AddToken (FmtTypeLiteral ,_daf [_cfbe :_bef ]);
};goto _cfgd ;_acb :_bef =_dad +1;{_abb ._cce ._aa =true ;};goto _cfgd ;_ccfg :_bef =_dad +1;{_abb ._cce .AddToken (FmtTypeLiteral ,_daf [_cfbe :_bef ]);};goto _cfgd ;_eba :_bef =_dad +1;{_abb ._cce .AddToken (FmtTypeDollar ,nil );};goto _cfgd ;_gcca :_bef =_dad +1;
{_abb ._cce .AddToken (FmtTypeComma ,nil );};goto _cfgd ;_fdfe :_bef =_dad +1;{_abb ._cce .AddToken (FmtTypeDecimal ,nil );};goto _cfgd ;_egd :_bef =_dad +1;{_abb .nextFmt ();};goto _cfgd ;_adb :_bef =_dad +1;{_abb ._cce .AddToken (FmtTypeText ,nil );};
goto _cfgd ;_dadf :_bef =_dad +1;{_abb ._cce .AddToken (FmtTypeUnderscore ,nil );};goto _cfgd ;_abbb :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypeLiteral ,_daf [_cfbe :_bef ]);};goto _cfgd ;_cfg :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypeLiteral ,_daf [_cfbe +1:_bef -1]);
};goto _cfgd ;_bbe :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypeDigitOpt ,nil );};goto _cfgd ;_fbde :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypeFraction ,_daf [_cfbe :_bef ]);};goto _cfgd ;_ffg :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypePercent ,nil );
};goto _cfgd ;_eeb :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypeDate ,_daf [_cfbe :_bef ]);};goto _cfgd ;_aggd :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypeDigit ,nil );};goto _cfgd ;_baf :_bef =_dad ;_dad --;{_abb ._cce .AddToken (FmtTypeTime ,_daf [_cfbe :_bef ]);
};goto _cfgd ;_cdgf :_bef =_dad ;_dad --;{};goto _cfgd ;_beb :_bef =_dad +1;{_abb ._cce .IsExponential =true ;};goto _cfgd ;_bacc :_bef =_dad +1;{_abb ._cce .AddToken (FmtTypeLiteral ,_daf [_cfbe +1:_bef ]);};goto _cfgd ;_cfgd :_cfbe =0;if _dad ++;_dad ==_bfb {goto _dfdg ;
};_cfc :_cfbe =_dad ;switch _daf [_dad ]{case 34:goto _gdgg ;case 35:goto _agf ;case 36:goto _eba ;case 37:goto _efce ;case 44:goto _gcca ;case 46:goto _fdfe ;case 47:goto _aegf ;case 48:goto _geb ;case 58:goto _fcca ;case 59:goto _egd ;case 63:goto _feffg ;
case 64:goto _adb ;case 65:goto _febd ;case 69:goto _edd ;case 71:goto _acf ;case 91:goto _ecca ;case 92:goto _dgaa ;case 95:goto _dadf ;case 100:goto _aegf ;case 104:goto _fcca ;case 109:goto _fdg ;case 115:goto _gfa ;case 121:goto _aac ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _efcb ;
};goto _ccfg ;_gdgg :_bef =_dad +1;_cgcb =20;goto _ccbd ;_ccbd :if _dad ++;_dad ==_bfb {goto _bgb ;};_bgaf :if _daf [_dad ]==34{goto _cfcb ;};goto _edc ;_edc :if _dad ++;_dad ==_bfb {goto _geec ;};_ccc :if _daf [_dad ]==34{goto _cfcb ;};goto _edc ;_cfcb :_bef =_dad +1;
_cgcb =21;goto _feff ;_feff :if _dad ++;_dad ==_bfb {goto _dfbd ;};_bgge :if _daf [_dad ]==34{goto _edc ;};goto _cfg ;_agf :_bef =_dad +1;_cgcb =3;goto _bgf ;_bgf :if _dad ++;_dad ==_bfb {goto _ageg ;};_bbb :switch _daf [_dad ]{case 35:goto _bab ;case 37:goto _bab ;
case 44:goto _def ;case 47:goto _fff ;case 48:goto _bab ;case 63:goto _bab ;};goto _bbe ;_bab :if _dad ++;_dad ==_bfb {goto _bfa ;};_dcd :switch _daf [_dad ]{case 35:goto _bab ;case 37:goto _bab ;case 47:goto _fff ;case 48:goto _bab ;case 63:goto _bab ;
};goto _gac ;_fff :if _dad ++;_dad ==_bfb {goto _cfe ;};_eea :switch _daf [_dad ]{case 35:goto _fee ;case 37:goto _bgfc ;case 48:goto _agc ;case 63:goto _fee ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _eed ;};goto _gac ;_fee :_bef =_dad +1;goto _gdgd ;
_gdgd :if _dad ++;_dad ==_bfb {goto _gcef ;};_fgb :switch _daf [_dad ]{case 35:goto _fee ;case 37:goto _fee ;case 44:goto _fee ;case 46:goto _fee ;case 48:goto _fee ;case 63:goto _fee ;case 65:goto _dadd ;};goto _fbde ;_dadd :if _dad ++;_dad ==_bfb {goto _gadc ;
};_bafb :switch _daf [_dad ]{case 47:goto _ebfe ;case 77:goto _ecff ;};goto _eeg ;_ebfe :if _dad ++;_dad ==_bfb {goto _fdaf ;};_ebc :if _daf [_dad ]==80{goto _gae ;};goto _eeg ;_gae :_bef =_dad +1;goto _dcc ;_dcc :if _dad ++;_dad ==_bfb {goto _adga ;};
_eebb :if _daf [_dad ]==65{goto _dadd ;};goto _fbde ;_ecff :if _dad ++;_dad ==_bfb {goto _edfbd ;};_adec :if _daf [_dad ]==47{goto _aag ;};goto _eeg ;_aag :if _dad ++;_dad ==_bfb {goto _dbac ;};_cec :if _daf [_dad ]==80{goto _fbf ;};goto _eeg ;_fbf :if _dad ++;
_dad ==_bfb {goto _cbgf ;};_acbf :if _daf [_dad ]==77{goto _gae ;};goto _eeg ;_bgfc :if _dad ++;_dad ==_bfb {goto _egc ;};_egg :switch _daf [_dad ]{case 35:goto _dcb ;case 37:goto _feab ;case 63:goto _dcb ;};if 48<=_daf [_dad ]&&_daf [_dad ]<=57{goto _gcbg ;
};goto _gac ;_dcb :_bef =_dad +1;goto _bcb ;_bcb :if _dad ++;_dad ==_bfb {goto _gdee ;};_fcad :switch _daf [_dad ]{case 35:goto _fee ;case 37:goto _ccbde ;case 44:goto _fee ;case 46:goto _fee ;case 48:goto _fee ;case 63:goto _fee ;case 65:goto _dadd ;};
goto _fbde ;_ccbde :if _dad ++;_dad ==_bfb {goto _gedf ;};_aga :switch _daf [_dad ]{case 35:goto _fga ;case 44:goto _fga ;case 46:goto _fga ;case 48:goto _fga ;case 63:goto _fga ;};goto _eeg ;_fga :_bef =_dad +1;goto _gfec ;_gfec :if _dad ++;_dad ==_bfb {goto _bgff ;
};_cgd :switch _daf [_dad ]{case 35:goto _fga ;case 44:goto _fga ;case 46:goto _fga ;case 48:goto _fga ;case 63:goto _fga ;case 65:goto _dadd ;};goto _fbde ;_feab :if _dad ++;_dad ==_bfb {goto _ffde ;};_bafa :if _daf [_dad ]==37{goto _feab ;};if 48<=_daf [_dad ]&&_daf [_dad ]<=57{goto _gcbg ;
};goto _gac ;_gcbg :_bef =_dad +1;_cgcb =13;goto _acca ;_acca :if _dad ++;_dad ==_bfb {goto _cecg ;};_bccg :switch _daf [_dad ]{case 35:goto _fee ;case 37:goto _fcef ;case 44:goto _fee ;case 46:goto _fee ;case 48:goto _adg ;case 63:goto _fee ;case 65:goto _dadd ;
};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _gcbg ;};goto _fbde ;_fcef :if _dad ++;_dad ==_bfb {goto _ebef ;};_efb :switch _daf [_dad ]{case 35:goto _fga ;case 37:goto _feab ;case 44:goto _fga ;case 46:goto _fga ;case 63:goto _fga ;};if 48<=_daf [_dad ]&&_daf [_dad ]<=57{goto _gcbg ;
};goto _eeg ;_adg :_bef =_dad +1;goto _fdd ;_fdd :if _dad ++;_dad ==_bfb {goto _cfde ;};_fcfd :switch _daf [_dad ]{case 35:goto _fee ;case 37:goto _adg ;case 44:goto _fee ;case 46:goto _fee ;case 48:goto _adg ;case 63:goto _fee ;case 65:goto _dadd ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _gcbg ;
};goto _fbde ;_agc :_bef =_dad +1;goto _gab ;_gab :if _dad ++;_dad ==_bfb {goto _ccbf ;};_gfbg :switch _daf [_dad ]{case 35:goto _fee ;case 37:goto _adg ;case 44:goto _fee ;case 46:goto _fee ;case 48:goto _agc ;case 63:goto _fee ;case 65:goto _dadd ;};
if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _eed ;};goto _fbde ;_eed :_bef =_dad +1;goto _dba ;_dba :if _dad ++;_dad ==_bfb {goto _geca ;};_aafa :switch _daf [_dad ]{case 35:goto _fee ;case 37:goto _gcbg ;case 44:goto _fee ;case 46:goto _fee ;case 48:goto _agc ;
case 63:goto _fee ;case 65:goto _dadd ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _eed ;};goto _fbde ;_def :if _dad ++;_dad ==_bfb {goto _bffc ;};_efg :if _daf [_dad ]==35{goto _cef ;};goto _gfb ;_efce :_bef =_dad +1;_cgcb =8;goto _bbg ;_bbg :if _dad ++;
_dad ==_bfb {goto _aaef ;};_babc :switch _daf [_dad ]{case 35:goto _ebfb ;case 37:goto _gbe ;case 48:goto _cabg ;case 63:goto _ebfb ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _defa ;};goto _ffg ;_ebfb :if _dad ++;_dad ==_bfb {goto _efeb ;};_cefd :switch _daf [_dad ]{case 35:goto _ebfb ;
case 47:goto _fff ;case 48:goto _ebfb ;case 63:goto _ebfb ;};goto _ece ;_gbe :if _dad ++;_dad ==_bfb {goto _afgc ;};_fbg :if _daf [_dad ]==37{goto _gbe ;};if 48<=_daf [_dad ]&&_daf [_dad ]<=57{goto _defa ;};goto _gac ;_defa :if _dad ++;_dad ==_bfb {goto _cdaf ;
};_cbf :switch _daf [_dad ]{case 37:goto _gbe ;case 47:goto _fff ;};if 48<=_daf [_dad ]&&_daf [_dad ]<=57{goto _defa ;};goto _gac ;_cabg :if _dad ++;_dad ==_bfb {goto _cbdf ;};_gaea :switch _daf [_dad ]{case 35:goto _ebfb ;case 37:goto _gbe ;case 47:goto _fff ;
case 48:goto _cabg ;case 63:goto _ebfb ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _defa ;};goto _ece ;_aegf :_bef =_dad +1;goto _aab ;_aab :if _dad ++;_dad ==_bfb {goto _dcbc ;};_ddeb :switch _daf [_dad ]{case 47:goto _aegf ;case 100:goto _aegf ;case 109:goto _aegf ;
case 121:goto _bec ;};goto _eeb ;_bec :if _dad ++;_dad ==_bfb {goto _ecb ;};_eeed :if _daf [_dad ]==121{goto _aegf ;};goto _aed ;_geb :_bef =_dad +1;_cgcb =2;goto _aee ;_aee :if _dad ++;_dad ==_bfb {goto _ada ;};_afbd :switch _daf [_dad ]{case 35:goto _bab ;
case 37:goto _bff ;case 47:goto _fff ;case 48:goto _gdd ;case 63:goto _bab ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _cbb ;};goto _aggd ;_bff :if _dad ++;_dad ==_bfb {goto _bebc ;};_gaf :switch _daf [_dad ]{case 35:goto _bab ;case 37:goto _bff ;case 47:goto _fff ;
case 48:goto _bff ;case 63:goto _bab ;};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _defa ;};goto _geed ;_gdd :if _dad ++;_dad ==_bfb {goto _abbe ;};_ffc :switch _daf [_dad ]{case 35:goto _bab ;case 37:goto _bff ;case 47:goto _fff ;case 48:goto _gdd ;case 63:goto _bab ;
};if 49<=_daf [_dad ]&&_daf [_dad ]<=57{goto _cbb ;};goto _geed ;_cbb :if _dad ++;_dad ==_bfb {goto _ddcc ;};_bggd :switch _daf [_dad ]{case 37:goto _defa ;case 47:goto _fff ;};if 48<=_daf [_dad ]&&_daf [_dad ]<=57{goto _cbb ;};goto _gac ;_efcb :_bef =_dad +1;
_cgcb =20;goto _cdde ;_cdde :if _dad ++;_dad ==_bfb {goto _eggf ;};_gec :switch _daf [_dad ]{case 37:goto _defa ;case 47:goto _fff ;};if 48<=_daf [_dad ]&&_daf [_dad ]<=57{goto _cbb ;};goto _abbb ;_fcca :_bef =_dad +1;_cgcb =15;goto _gfd ;_gfd :if _dad ++;
_dad ==_bfb {goto _fag ;};_eda :switch _daf [_dad ]{case 58:goto _fcca ;case 65:goto _gcdf ;case 104:goto _fcca ;case 109:goto _fcca ;case 115:goto _gfa ;};goto _baf ;_gcdf :if _dad ++;_dad ==_bfb {goto _bccb ;};_cage :switch _daf [_dad ]{case 47:goto _aabd ;
case 77:goto _gfg ;};goto _gac ;_aabd :if _dad ++;_dad ==_bfb {goto _gfff ;};_beegf :if _daf [_dad ]==80{goto _fcca ;};goto _gac ;_gfg :if _dad ++;_dad ==_bfb {goto _cccd ;};_dge :if _daf [_dad ]==47{goto _ffge ;};goto _gac ;_ffge :if _dad ++;_dad ==_bfb {goto _ffe ;
};_dec :if _daf [_dad ]==80{goto _eegf ;};goto _gac ;_eegf :if _dad ++;_dad ==_bfb {goto _gbdc ;};_cbba :if _daf [_dad ]==77{goto _fcca ;};goto _gac ;_gfa :_bef =_dad +1;_cgcb =15;goto _dcg ;_dcg :if _dad ++;_dad ==_bfb {goto _dca ;};_fda :switch _daf [_dad ]{case 46:goto _ddcf ;
case 58:goto _fcca ;case 65:goto _gcdf ;case 104:goto _fcca ;case 109:goto _fcca ;case 115:goto _gfa ;};goto _baf ;_ddcf :if _dad ++;_dad ==_bfb {goto _daae ;};_fbfd :if _daf [_dad ]==48{goto _fcadg ;};goto _bae ;_fcadg :_bef =_dad +1;_cgcb =15;goto _ddd ;
_ddd :if _dad ++;_dad ==_bfb {goto _bebb ;};_gffc :switch _daf [_dad ]{case 48:goto _ggg ;case 58:goto _fcca ;case 65:goto _gcdf ;case 104:goto _fcca ;case 109:goto _fcca ;case 115:goto _gfa ;};goto _baf ;_ggg :_bef =_dad +1;_cgcb =15;goto _edfb ;_edfb :if _dad ++;
_dad ==_bfb {goto _dddg ;};_acg :switch _daf [_dad ]{case 48:goto _fcca ;case 58:goto _fcca ;case 65:goto _gcdf ;case 104:goto _fcca ;case 109:goto _fcca ;case 115:goto _gfa ;};goto _baf ;_feffg :_bef =_dad +1;_cgcb =5;goto _fbfe ;_fbfe :if _dad ++;_dad ==_bfb {goto _dbfa ;
};_fcfa :switch _daf [_dad ]{case 35:goto _bab ;case 37:goto _bab ;case 47:goto _fff ;case 48:goto _bab ;case 63:goto _bab ;};goto _cdgf ;_febd :_bef =_dad +1;_cgcb =20;goto _cegg ;_cegg :if _dad ++;_dad ==_bfb {goto _gfgb ;};_cafg :switch _daf [_dad ]{case 47:goto _aabd ;
case 77:goto _gfg ;};goto _abbb ;_edd :if _dad ++;_dad ==_bfb {goto _dbae ;};_fbfc :switch _daf [_dad ]{case 43:goto _beb ;case 45:goto _beb ;};goto _abbb ;_acf :_bef =_dad +1;goto _dcf ;_dcf :if _dad ++;_dad ==_bfb {goto _eeag ;};_dcfb :if _daf [_dad ]==101{goto _fad ;
};goto _abbb ;_fad :if _dad ++;_dad ==_bfb {goto _cea ;};_gadd :if _daf [_dad ]==110{goto _bce ;};goto _ecc ;_bce :if _dad ++;_dad ==_bfb {goto _daff ;};_dgeg :if _daf [_dad ]==101{goto _cafe ;};goto _ecc ;_cafe :if _dad ++;_dad ==_bfb {goto _bbaf ;};_eafd :if _daf [_dad ]==114{goto _dgea ;
};goto _ecc ;_dgea :if _dad ++;_dad ==_bfb {goto _daag ;};_eafa :if _daf [_dad ]==97{goto _gce ;};goto _ecc ;_gce :if _dad ++;_dad ==_bfb {goto _agege ;};_acfa :if _daf [_dad ]==108{goto _acb ;};goto _ecc ;_ecca :_bef =_dad +1;_cgcb =20;goto _gaddc ;_gaddc :if _dad ++;
_dad ==_bfb {goto _daffc ;};_ege :switch _daf [_dad ]{case 104:goto _cbg ;case 109:goto _cbg ;case 115:goto _cbg ;};goto _dce ;_dce :if _dad ++;_dad ==_bfb {goto _eebg ;};_bbc :if _daf [_dad ]==93{goto _ebde ;};goto _dce ;_ebde :_bef =_dad +1;_cgcb =18;
goto _egec ;_fge :_bef =_dad +1;_cgcb =16;goto _egec ;_egec :if _dad ++;_dad ==_bfb {goto _ggbf ;};_fddd :if _daf [_dad ]==93{goto _ebde ;};goto _dce ;_cbg :if _dad ++;_dad ==_bfb {goto _efd ;};_cgcc :if _daf [_dad ]==93{goto _fge ;};goto _dce ;_dgaa :if _dad ++;
_dad ==_bfb {goto _edaa ;};_ffca :goto _bacc ;_fdg :_bef =_dad +1;_cgcb =14;goto _befd ;_befd :if _dad ++;_dad ==_bfb {goto _gea ;};_agb :switch _daf [_dad ]{case 47:goto _aegf ;case 58:goto _fcca ;case 65:goto _gcdf ;case 100:goto _aegf ;case 104:goto _fcca ;
case 109:goto _fdg ;case 115:goto _gfa ;case 121:goto _bec ;};goto _eeb ;_aac :if _dad ++;_dad ==_bfb {goto _dcdf ;};_aege :if _daf [_dad ]==121{goto _aegf ;};goto _abbb ;_febf :_dfdg :_dfe =34;goto _eccd ;_bgb :_dfe =35;goto _eccd ;_geec :_dfe =0;goto _eccd ;
_dfbd :_dfe =36;goto _eccd ;_ageg :_dfe =37;goto _eccd ;_bfa :_dfe =1;goto _eccd ;_cfe :_dfe =2;goto _eccd ;_gcef :_dfe =38;goto _eccd ;_gadc :_dfe =3;goto _eccd ;_fdaf :_dfe =4;goto _eccd ;_adga :_dfe =39;goto _eccd ;_edfbd :_dfe =5;goto _eccd ;_dbac :_dfe =6;
goto _eccd ;_cbgf :_dfe =7;goto _eccd ;_egc :_dfe =8;goto _eccd ;_gdee :_dfe =40;goto _eccd ;_gedf :_dfe =9;goto _eccd ;_bgff :_dfe =41;goto _eccd ;_ffde :_dfe =10;goto _eccd ;_cecg :_dfe =42;goto _eccd ;_ebef :_dfe =11;goto _eccd ;_cfde :_dfe =43;goto _eccd ;
_ccbf :_dfe =44;goto _eccd ;_geca :_dfe =45;goto _eccd ;_bffc :_dfe =12;goto _eccd ;_aaef :_dfe =46;goto _eccd ;_efeb :_dfe =13;goto _eccd ;_afgc :_dfe =14;goto _eccd ;_cdaf :_dfe =15;goto _eccd ;_cbdf :_dfe =16;goto _eccd ;_dcbc :_dfe =47;goto _eccd ;
_ecb :_dfe =17;goto _eccd ;_ada :_dfe =48;goto _eccd ;_bebc :_dfe =18;goto _eccd ;_abbe :_dfe =19;goto _eccd ;_ddcc :_dfe =20;goto _eccd ;_eggf :_dfe =49;goto _eccd ;_fag :_dfe =50;goto _eccd ;_bccb :_dfe =21;goto _eccd ;_gfff :_dfe =22;goto _eccd ;_cccd :_dfe =23;
goto _eccd ;_ffe :_dfe =24;goto _eccd ;_gbdc :_dfe =25;goto _eccd ;_dca :_dfe =51;goto _eccd ;_daae :_dfe =26;goto _eccd ;_bebb :_dfe =52;goto _eccd ;_dddg :_dfe =53;goto _eccd ;_dbfa :_dfe =54;goto _eccd ;_gfgb :_dfe =55;goto _eccd ;_dbae :_dfe =56;goto _eccd ;
_eeag :_dfe =57;goto _eccd ;_cea :_dfe =27;goto _eccd ;_daff :_dfe =28;goto _eccd ;_bbaf :_dfe =29;goto _eccd ;_daag :_dfe =30;goto _eccd ;_agege :_dfe =31;goto _eccd ;_daffc :_dfe =58;goto _eccd ;_eebg :_dfe =32;goto _eccd ;_ggbf :_dfe =59;goto _eccd ;
_efd :_dfe =33;goto _eccd ;_edaa :_dfe =60;goto _eccd ;_gea :_dfe =61;goto _eccd ;_dcdf :_dfe =62;goto _eccd ;_eccd :{};if _dad ==_facg {switch _dfe {case 35:goto _abbb ;case 0:goto _gac ;case 36:goto _cfg ;case 37:goto _bbe ;case 1:goto _gac ;case 2:goto _gac ;
case 38:goto _fbde ;case 3:goto _eeg ;case 4:goto _eeg ;case 39:goto _fbde ;case 5:goto _eeg ;case 6:goto _eeg ;case 7:goto _eeg ;case 8:goto _gac ;case 40:goto _fbde ;case 9:goto _eeg ;case 41:goto _fbde ;case 10:goto _gac ;case 42:goto _fbde ;case 11:goto _eeg ;
case 43:goto _fbde ;case 44:goto _fbde ;case 45:goto _fbde ;case 12:goto _gfb ;case 46:goto _ffg ;case 13:goto _ece ;case 14:goto _gac ;case 15:goto _gac ;case 16:goto _ece ;case 47:goto _eeb ;case 17:goto _aed ;case 48:goto _aggd ;case 18:goto _geed ;
case 19:goto _geed ;case 20:goto _gac ;case 49:goto _abbb ;case 50:goto _baf ;case 21:goto _gac ;case 22:goto _gac ;case 23:goto _gac ;case 24:goto _gac ;case 25:goto _gac ;case 51:goto _baf ;case 26:goto _bae ;case 52:goto _baf ;case 53:goto _baf ;case 54:goto _cdgf ;
case 55:goto _abbb ;case 56:goto _abbb ;case 57:goto _abbb ;case 27:goto _ecc ;case 28:goto _ecc ;case 29:goto _ecc ;case 30:goto _ecc ;case 31:goto _ecc ;case 58:goto _abbb ;case 32:goto _gac ;case 59:goto _gac ;case 33:goto _ecc ;case 60:goto _abbb ;
case 61:goto _eeb ;case 62:goto _abbb ;};};};if _cfbe > 0{copy (_daf [0:],_daf [_cfbe :]);};};_ =_facg ;if _dfe ==_eee {_ee .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};func _feb (_de float64 )string {_aff :=_eb .FormatFloat (_de ,'E',-1,64);
_feba :=_eb .FormatFloat (_de ,'E',5,64);if len (_aff )< len (_feba ){return _eb .FormatFloat (_de ,'E',2,64);};return _feba ;};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_cg ,_ :=_eb .ParseFloat (v ,64);return Number (_cg ,f );};return String (v ,f );};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_eef :=Parse (f );var _da Format ;if len (_eef )==1{_da =_eef [0];}else if len (_eef )==4{_da =_eef [3];};_fgc :=false ;for _ ,_gcg :=range _da .Whole {if _gcg .Type ==FmtTypeText {_fgc =true ;};};if !_fgc {return v ;
};_gf :=_c .Buffer {};for _ ,_ge :=range _da .Whole {switch _ge .Type {case FmtTypeLiteral :_gf .WriteByte (_ge .Literal );case FmtTypeText :_gf .WriteString (v );};};return _gf .String ();};func _ecf (_dc _ac .Time ,_bcf string )[]byte {_eff :=[]byte {};
_dea :=0;for _ggba :=0;_ggba < len (_bcf );_ggba ++{var _fcb string ;if _bcf [_ggba ]=='/'{_fcb =string (_bcf [_dea :_ggba ]);_dea =_ggba +1;}else if _ggba ==len (_bcf )-1{_fcb =string (_bcf [_dea :_ggba +1]);}else {continue ;};switch _fcb {case "\u0079\u0079":_eff =_dc .AppendFormat (_eff ,"\u0030\u0036");
case "\u0079\u0079\u0079\u0079":_eff =_dc .AppendFormat (_eff ,"\u0032\u0030\u0030\u0036");case "\u006d":_eff =_dc .AppendFormat (_eff ,"\u0031");case "\u006d\u006d":_eff =_dc .AppendFormat (_eff ,"\u0030\u0031");case "\u006d\u006d\u006d":_eff =_dc .AppendFormat (_eff ,"\u004a\u0061\u006e");
case "\u006d\u006d\u006d\u006d":_eff =_dc .AppendFormat (_eff ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _dc .Month (){case _ac .January ,_ac .July ,_ac .June :_eff =append (_eff ,'J');case _ac .February :_eff =append (_eff ,'M');
case _ac .March ,_ac .May :_eff =append (_eff ,'M');case _ac .April ,_ac .August :_eff =append (_eff ,'A');case _ac .September :_eff =append (_eff ,'S');case _ac .October :_eff =append (_eff ,'O');case _ac .November :_eff =append (_eff ,'N');case _ac .December :_eff =append (_eff ,'D');
};case "\u0064":_eff =_dc .AppendFormat (_eff ,"\u0032");case "\u0064\u0064":_eff =_dc .AppendFormat (_eff ,"\u0030\u0032");case "\u0064\u0064\u0064":_eff =_dc .AppendFormat (_eff ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_eff =_dc .AppendFormat (_eff ,"\u004d\u006f\u006e\u0064\u0061\u0079");
default:_ee .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_fcb );};if _bcf [_ggba ]=='/'{_eff =append (_eff ,'/');};};return _eff ;};const _afb int =34;
const _gff int =0;

// AddToken adds a format token to the format.
func (_cd *Format )AddToken (t FmtType ,l []byte ){if _cd ._aaa {_cd ._aaa =false ;return ;};switch t {case FmtTypeDecimal :_cd ._d =true ;case FmtTypeUnderscore :_cd ._aaa =true ;case FmtTypeText :_cd .Whole =append (_cd .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_cd .Whole =append (_cd .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_cd ._ec =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ca :=range l {if _cd .IsExponential {_cd .Exponent =append (_cd .Exponent ,Token {Type :t ,Literal :_ca });
}else if !_cd ._d {_cd .Whole =append (_cd .Whole ,Token {Type :t ,Literal :_ca });}else {_cd .Fractional =append (_cd .Fractional ,Token {Type :t ,Literal :_ca });};};case FmtTypeDigitOptThousands :_cd ._fg =true ;case FmtTypeFraction :_gc :=_g .Split (string (l ),"\u002f");
if len (_gc )==2{_cd ._fcc =true ;_cd ._cc ,_ =_eb .ParseInt (_gc [1],10,64);for _ ,_ea :=range _gc [1]{if _ea =='?'||_ea =='0'{_cd ._dg ++;};};};default:_ee .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};func (_ce FmtType )String ()string {if _ce >=FmtType (len (_f )-1){return _b .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_ce );};return _ba [_f [_ce ]:_f [_ce +1]];};const _aae int =34;func _bcc (_bea _ac .Time ,_daa float64 ,_cdf string )[]byte {_fea :=[]byte {};
_eca :=0;for _ccb :=0;_ccb < len (_cdf );_ccb ++{var _bba string ;if _cdf [_ccb ]==':'{_bba =string (_cdf [_eca :_ccb ]);_eca =_ccb +1;}else if _ccb ==len (_cdf )-1{_bba =string (_cdf [_eca :_ccb +1]);}else {continue ;};switch _bba {case "\u0064":_fea =_bea .AppendFormat (_fea ,"\u0032");
case "\u0068":_fea =_bea .AppendFormat (_fea ,"\u0033");case "\u0068\u0068":_fea =_bea .AppendFormat (_fea ,"\u0031\u0035");case "\u006d":_fea =_bea .AppendFormat (_fea ,"\u0034");case "\u006d\u006d":_fea =_bea .AppendFormat (_fea ,"\u0030\u0034");case "\u0073":_fea =_bea .Round (_ac .Second ).AppendFormat (_fea ,"\u0035");
case "\u0073\u002e\u0030":_fea =_bea .Round (_ac .Second /10).AppendFormat (_fea ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_fea =_bea .Round (_ac .Second /100).AppendFormat (_fea ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_fea =_bea .Round (_ac .Second /1000).AppendFormat (_fea ,"\u0035\u002e\u00300\u0030");
case "\u0073\u0073":_fea =_bea .Round (_ac .Second ).AppendFormat (_fea ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_fea =_bea .Round (_ac .Second /10).AppendFormat (_fea ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_fea =_bea .Round (_ac .Second /100).AppendFormat (_fea ,"\u0030\u0035\u002e0\u0030");
case "\u0073\u0073\u002e\u0030\u0030\u0030":_fea =_bea .Round (_ac .Second /1000).AppendFormat (_fea ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_fea =_bea .AppendFormat (_fea ,"\u0050\u004d");case "\u005b\u0068\u005d":_fea =_eb .AppendInt (_fea ,int64 (_daa *24),10);
case "\u005b\u006d\u005d":_fea =_eb .AppendInt (_fea ,int64 (_daa *24*60),10);case "\u005b\u0073\u005d":_fea =_eb .AppendInt (_fea ,int64 (_daa *24*60*60),10);case "":default:_ee .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bba );
};if _cdf [_ccb ]==':'{_fea =append (_fea ,':');};};return _fea ;};func _gged (_agef _ac .Time )_ac .Time {_agef =_agef .UTC ();return _ac .Date (_agef .Year (),_agef .Month (),_agef .Day (),_agef .Hour (),_agef .Minute (),_agef .Second (),_agef .Nanosecond (),_ac .Local );
};func (_ceg *Lexer )nextFmt (){_ceg ._ecac =append (_ceg ._ecac ,_ceg ._cce );_ceg ._cce =Format {}};const _afff int =0;const _bd =1e-10;