//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_bc "bytes";_c "fmt";_d "github.com/unidoc/unioffice/v2/common/logger";_e "io";_ac "math";_a "strconv";_ed "strings";_ee "time";);func _dda (_gf []byte )[]byte {for _cf :=0;_cf < len (_gf )/2;_cf ++{_cg :=len (_gf )-1-_cf ;_gf [_cf ],_gf [_cg ]=_gf [_cg ],_gf [_cf ];
};return _gf ;};func _bbg (_egb float64 )string {_cea :=_a .FormatFloat (_egb ,'E',-1,64);_cegc :=_a .FormatFloat (_egb ,'E',5,64);if len (_cea )< len (_cegc ){return _a .FormatFloat (_egb ,'E',2,64);};return _cegc ;};const _gfdd int =0;func (_dce *Lexer )Lex (r _e .Reader ){_ceb ,_egba ,_aeb :=0,0,0;
_bba :=-1;_afe ,_ceaf ,_bgb :=0,0,0;_ =_ceaf ;_ =_bgb ;_fbad :=1;_ =_fbad ;_cgb :=make ([]byte ,4096);_afab :=false ;for !_afab {_gcc :=0;if _afe > 0{_gcc =_egba -_afe ;};_egba =0;_fecc ,_ced :=r .Read (_cgb [_gcc :]);if _fecc ==0||_ced !=nil {_afab =true ;
};_aeb =_fecc +_gcc ;if _aeb < len (_cgb ){_bba =_aeb ;};{_ceb =_bbga ;_afe =0;_ceaf =0;_bgb =0;};{if _egba ==_aeb {goto _bfaa ;};switch _ceb {case 34:goto _gdf ;case 35:goto _fbe ;case 0:goto _fbcf ;case 36:goto _dca ;case 37:goto _ecb ;case 1:goto _ddee ;
case 2:goto _dcec ;case 38:goto _edd ;case 3:goto _gggc ;case 4:goto _bgg ;case 39:goto _gef ;case 5:goto _agd ;case 6:goto _edcd ;case 7:goto _fad ;case 8:goto _aedc ;case 40:goto _eafe ;case 9:goto _fdbc ;case 41:goto _bcg ;case 10:goto _dff ;case 42:goto _fgac ;
case 11:goto _bcee ;case 43:goto _gbdd ;case 44:goto _ddde ;case 45:goto _abgg ;case 12:goto _dcgc ;case 46:goto _ffg ;case 13:goto _gcd ;case 14:goto _fcc ;case 15:goto _fada ;case 16:goto _cfd ;case 47:goto _gbe ;case 17:goto _afca ;case 48:goto _baef ;
case 18:goto _gag ;case 19:goto _eebe ;case 20:goto _edcg ;case 49:goto _cfdf ;case 50:goto _agb ;case 21:goto _gffe ;case 22:goto _fcg ;case 23:goto _ecea ;case 24:goto _abggf ;case 25:goto _ccd ;case 51:goto _efbd ;case 26:goto _acgf ;case 52:goto _efd ;
case 53:goto _aaaf ;case 54:goto _fbfc ;case 55:goto _cfdg ;case 56:goto _acge ;case 57:goto _egbd ;case 27:goto _eag ;case 28:goto _cedc ;case 29:goto _gad ;case 30:goto _acd ;case 31:goto _ecbc ;case 58:goto _bdgc ;case 32:goto _dfb ;case 59:goto _fcgg ;
case 33:goto _cab ;case 60:goto _eafg ;case 61:goto _eacg ;case 62:goto _cgbc ;};goto _gfc ;_fggd :switch _bgb {case 2:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeDigit ,nil );};case 3:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeDigitOpt ,nil );
};case 5:{_egba =(_ceaf )-1;};case 8:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypePercent ,nil );};case 13:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeFraction ,_cgb [_afe :_ceaf ]);};case 14:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeDate ,_cgb [_afe :_ceaf ]);
};case 15:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeTime ,_cgb [_afe :_ceaf ]);};case 16:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeTime ,_cgb [_afe :_ceaf ]);};case 18:{_egba =(_ceaf )-1;};case 20:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeLiteral ,_cgb [_afe :_ceaf ]);
};case 21:{_egba =(_ceaf )-1;_dce ._fbfg .AddToken (FmtTypeLiteral ,_cgb [_afe +1:_ceaf -1]);};};goto _gfbd ;_eaf :_egba =(_ceaf )-1;{_dce ._fbfg .AddToken (FmtTypeFraction ,_cgb [_afe :_ceaf ]);};goto _gfbd ;_fbgf :_egba =(_ceaf )-1;{_dce ._fbfg .AddToken (FmtTypeDigitOpt ,nil );
};goto _gfbd ;_aff :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeDigitOptThousands ,nil );};goto _gfbd ;_bdf :_egba =(_ceaf )-1;{_dce ._fbfg .AddToken (FmtTypePercent ,nil );};goto _gfbd ;_aca :_egba =(_ceaf )-1;{_dce ._fbfg .AddToken (FmtTypeDate ,_cgb [_afe :_ceaf ]);
};goto _gfbd ;_dcdd :_egba =(_ceaf )-1;{_dce ._fbfg .AddToken (FmtTypeDigit ,nil );};goto _gfbd ;_fce :_egba =(_ceaf )-1;{_dce ._fbfg .AddToken (FmtTypeTime ,_cgb [_afe :_ceaf ]);};goto _gfbd ;_dee :_egba =(_ceaf )-1;{_dce ._fbfg .AddToken (FmtTypeLiteral ,_cgb [_afe :_ceaf ]);
};goto _gfbd ;_dbb :_ceaf =_egba +1;{_dce ._fbfg ._ddf =true ;};goto _gfbd ;_fda :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeLiteral ,_cgb [_afe :_ceaf ]);};goto _gfbd ;_bdge :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeDollar ,nil );};goto _gfbd ;
_fde :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeComma ,nil );};goto _gfbd ;_aabe :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeDecimal ,nil );};goto _gfbd ;_aed :_ceaf =_egba +1;{_dce .nextFmt ();};goto _gfbd ;_aad :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeText ,nil );
};goto _gfbd ;_cfee :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeUnderscore ,nil );};goto _gfbd ;_ffed :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypeLiteral ,_cgb [_afe :_ceaf ]);};goto _gfbd ;_bede :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypeLiteral ,_cgb [_afe +1:_ceaf -1]);
};goto _gfbd ;_bee :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypeDigitOpt ,nil );};goto _gfbd ;_edc :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypeFraction ,_cgb [_afe :_ceaf ]);};goto _gfbd ;_fgga :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypePercent ,nil );
};goto _gfbd ;_fca :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypeDate ,_cgb [_afe :_ceaf ]);};goto _gfbd ;_bdd :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypeDigit ,nil );};goto _gfbd ;_acgb :_ceaf =_egba ;_egba --;{_dce ._fbfg .AddToken (FmtTypeTime ,_cgb [_afe :_ceaf ]);
};goto _gfbd ;_cba :_ceaf =_egba ;_egba --;{};goto _gfbd ;_ace :_ceaf =_egba +1;{_dce ._fbfg .IsExponential =true ;};goto _gfbd ;_dgdc :_ceaf =_egba +1;{_dce ._fbfg .AddToken (FmtTypeLiteral ,_cgb [_afe +1:_ceaf ]);};goto _gfbd ;_gfbd :_afe =0;if _egba ++;
_egba ==_aeb {goto _aedb ;};_gdf :_afe =_egba ;switch _cgb [_egba ]{case 34:goto _acea ;case 35:goto _eaa ;case 36:goto _bdge ;case 37:goto _cbd ;case 44:goto _fde ;case 46:goto _aabe ;case 47:goto _cbeg ;case 48:goto _ecbe ;case 58:goto _dede ;case 59:goto _aed ;
case 63:goto _fbbg ;case 64:goto _aad ;case 65:goto _bcb ;case 69:goto _afd ;case 71:goto _cfad ;case 91:goto _geg ;case 92:goto _ada ;case 95:goto _cfee ;case 100:goto _cbeg ;case 104:goto _dede ;case 109:goto _ege ;case 115:goto _dbg ;case 121:goto _fea ;
};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _bfa ;};goto _fda ;_acea :_ceaf =_egba +1;_bgb =20;goto _eea ;_eea :if _egba ++;_egba ==_aeb {goto _eggf ;};_fbe :if _cgb [_egba ]==34{goto _cce ;};goto _agc ;_agc :if _egba ++;_egba ==_aeb {goto _afgf ;};
_fbcf :if _cgb [_egba ]==34{goto _cce ;};goto _agc ;_cce :_ceaf =_egba +1;_bgb =21;goto _fcb ;_fcb :if _egba ++;_egba ==_aeb {goto _afabf ;};_dca :if _cgb [_egba ]==34{goto _agc ;};goto _bede ;_eaa :_ceaf =_egba +1;_bgb =3;goto _ccb ;_ccb :if _egba ++;
_egba ==_aeb {goto _dcdc ;};_ecb :switch _cgb [_egba ]{case 35:goto _agf ;case 37:goto _agf ;case 44:goto _cfac ;case 47:goto _bae ;case 48:goto _agf ;case 63:goto _agf ;};goto _bee ;_agf :if _egba ++;_egba ==_aeb {goto _ecdc ;};_ddee :switch _cgb [_egba ]{case 35:goto _agf ;
case 37:goto _agf ;case 47:goto _bae ;case 48:goto _agf ;case 63:goto _agf ;};goto _fggd ;_bae :if _egba ++;_egba ==_aeb {goto _fcca ;};_dcec :switch _cgb [_egba ]{case 35:goto _ffd ;case 37:goto _edf ;case 48:goto _aeba ;case 63:goto _ffd ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _eaad ;
};goto _fggd ;_ffd :_ceaf =_egba +1;goto _afg ;_afg :if _egba ++;_egba ==_aeb {goto _bbfe ;};_edd :switch _cgb [_egba ]{case 35:goto _ffd ;case 37:goto _ffd ;case 44:goto _ffd ;case 46:goto _ffd ;case 48:goto _ffd ;case 63:goto _ffd ;case 65:goto _bfd ;
};goto _edc ;_bfd :if _egba ++;_egba ==_aeb {goto _ffae ;};_gggc :switch _cgb [_egba ]{case 47:goto _gacf ;case 77:goto _bcc ;};goto _eaf ;_gacf :if _egba ++;_egba ==_aeb {goto _gfdg ;};_bgg :if _cgb [_egba ]==80{goto _ggf ;};goto _eaf ;_ggf :_ceaf =_egba +1;
goto _dbe ;_dbe :if _egba ++;_egba ==_aeb {goto _edgb ;};_gef :if _cgb [_egba ]==65{goto _bfd ;};goto _edc ;_bcc :if _egba ++;_egba ==_aeb {goto _afbb ;};_agd :if _cgb [_egba ]==47{goto _adca ;};goto _eaf ;_adca :if _egba ++;_egba ==_aeb {goto _ffad ;};
_edcd :if _cgb [_egba ]==80{goto _egf ;};goto _eaf ;_egf :if _egba ++;_egba ==_aeb {goto _fgef ;};_fad :if _cgb [_egba ]==77{goto _ggf ;};goto _eaf ;_edf :if _egba ++;_egba ==_aeb {goto _dafe ;};_aedc :switch _cgb [_egba ]{case 35:goto _fgf ;case 37:goto _dgcb ;
case 63:goto _fgf ;};if 48<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _daf ;};goto _fggd ;_fgf :_ceaf =_egba +1;goto _cac ;_cac :if _egba ++;_egba ==_aeb {goto _gffg ;};_eafe :switch _cgb [_egba ]{case 35:goto _ffd ;case 37:goto _dfcg ;case 44:goto _ffd ;case 46:goto _ffd ;
case 48:goto _ffd ;case 63:goto _ffd ;case 65:goto _bfd ;};goto _edc ;_dfcg :if _egba ++;_egba ==_aeb {goto _ead ;};_fdbc :switch _cgb [_egba ]{case 35:goto _abgf ;case 44:goto _abgf ;case 46:goto _abgf ;case 48:goto _abgf ;case 63:goto _abgf ;};goto _eaf ;
_abgf :_ceaf =_egba +1;goto _dac ;_dac :if _egba ++;_egba ==_aeb {goto _feed ;};_bcg :switch _cgb [_egba ]{case 35:goto _abgf ;case 44:goto _abgf ;case 46:goto _abgf ;case 48:goto _abgf ;case 63:goto _abgf ;case 65:goto _bfd ;};goto _edc ;_dgcb :if _egba ++;
_egba ==_aeb {goto _bedc ;};_dff :if _cgb [_egba ]==37{goto _dgcb ;};if 48<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _daf ;};goto _fggd ;_daf :_ceaf =_egba +1;_bgb =13;goto _eebf ;_eebf :if _egba ++;_egba ==_aeb {goto _edaf ;};_fgac :switch _cgb [_egba ]{case 35:goto _ffd ;
case 37:goto _cgee ;case 44:goto _ffd ;case 46:goto _ffd ;case 48:goto _fcea ;case 63:goto _ffd ;case 65:goto _bfd ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _daf ;};goto _edc ;_cgee :if _egba ++;_egba ==_aeb {goto _cgd ;};_bcee :switch _cgb [_egba ]{case 35:goto _abgf ;
case 37:goto _dgcb ;case 44:goto _abgf ;case 46:goto _abgf ;case 63:goto _abgf ;};if 48<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _daf ;};goto _eaf ;_fcea :_ceaf =_egba +1;goto _dag ;_dag :if _egba ++;_egba ==_aeb {goto _eec ;};_gbdd :switch _cgb [_egba ]{case 35:goto _ffd ;
case 37:goto _fcea ;case 44:goto _ffd ;case 46:goto _ffd ;case 48:goto _fcea ;case 63:goto _ffd ;case 65:goto _bfd ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _daf ;};goto _edc ;_aeba :_ceaf =_egba +1;goto _fac ;_fac :if _egba ++;_egba ==_aeb {goto _ggfg ;
};_ddde :switch _cgb [_egba ]{case 35:goto _ffd ;case 37:goto _fcea ;case 44:goto _ffd ;case 46:goto _ffd ;case 48:goto _aeba ;case 63:goto _ffd ;case 65:goto _bfd ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _eaad ;};goto _edc ;_eaad :_ceaf =_egba +1;
goto _eda ;_eda :if _egba ++;_egba ==_aeb {goto _cbde ;};_abgg :switch _cgb [_egba ]{case 35:goto _ffd ;case 37:goto _daf ;case 44:goto _ffd ;case 46:goto _ffd ;case 48:goto _aeba ;case 63:goto _ffd ;case 65:goto _bfd ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _eaad ;
};goto _edc ;_cfac :if _egba ++;_egba ==_aeb {goto _feaa ;};_dcgc :if _cgb [_egba ]==35{goto _aff ;};goto _fbgf ;_cbd :_ceaf =_egba +1;_bgb =8;goto _adb ;_adb :if _egba ++;_egba ==_aeb {goto _aga ;};_ffg :switch _cgb [_egba ]{case 35:goto _efg ;case 37:goto _edg ;
case 48:goto _daad ;case 63:goto _efg ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _edfg ;};goto _fgga ;_efg :if _egba ++;_egba ==_aeb {goto _aeg ;};_gcd :switch _cgb [_egba ]{case 35:goto _efg ;case 47:goto _bae ;case 48:goto _efg ;case 63:goto _efg ;
};goto _bdf ;_edg :if _egba ++;_egba ==_aeb {goto _cgdb ;};_fcc :if _cgb [_egba ]==37{goto _edg ;};if 48<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _edfg ;};goto _fggd ;_edfg :if _egba ++;_egba ==_aeb {goto _gge ;};_fada :switch _cgb [_egba ]{case 37:goto _edg ;
case 47:goto _bae ;};if 48<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _edfg ;};goto _fggd ;_daad :if _egba ++;_egba ==_aeb {goto _eacd ;};_cfd :switch _cgb [_egba ]{case 35:goto _efg ;case 37:goto _edg ;case 47:goto _bae ;case 48:goto _daad ;case 63:goto _efg ;
};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _edfg ;};goto _bdf ;_cbeg :_ceaf =_egba +1;goto _bgc ;_bgc :if _egba ++;_egba ==_aeb {goto _ebb ;};_gbe :switch _cgb [_egba ]{case 47:goto _cbeg ;case 100:goto _cbeg ;case 109:goto _cbeg ;case 121:goto _egd ;
};goto _fca ;_egd :if _egba ++;_egba ==_aeb {goto _gbf ;};_afca :if _cgb [_egba ]==121{goto _cbeg ;};goto _aca ;_ecbe :_ceaf =_egba +1;_bgb =2;goto _cdcd ;_cdcd :if _egba ++;_egba ==_aeb {goto _facfe ;};_baef :switch _cgb [_egba ]{case 35:goto _agf ;case 37:goto _abcg ;
case 47:goto _bae ;case 48:goto _fdeg ;case 63:goto _agf ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _cdg ;};goto _bdd ;_abcg :if _egba ++;_egba ==_aeb {goto _bdgb ;};_gag :switch _cgb [_egba ]{case 35:goto _agf ;case 37:goto _abcg ;case 47:goto _bae ;
case 48:goto _abcg ;case 63:goto _agf ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _edfg ;};goto _dcdd ;_fdeg :if _egba ++;_egba ==_aeb {goto _eagc ;};_eebe :switch _cgb [_egba ]{case 35:goto _agf ;case 37:goto _abcg ;case 47:goto _bae ;case 48:goto _fdeg ;
case 63:goto _agf ;};if 49<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _cdg ;};goto _dcdd ;_cdg :if _egba ++;_egba ==_aeb {goto _fdf ;};_edcg :switch _cgb [_egba ]{case 37:goto _edfg ;case 47:goto _bae ;};if 48<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _cdg ;};
goto _fggd ;_bfa :_ceaf =_egba +1;_bgb =20;goto _abcc ;_abcc :if _egba ++;_egba ==_aeb {goto _cfc ;};_cfdf :switch _cgb [_egba ]{case 37:goto _edfg ;case 47:goto _bae ;};if 48<=_cgb [_egba ]&&_cgb [_egba ]<=57{goto _cdg ;};goto _ffed ;_dede :_ceaf =_egba +1;
_bgb =15;goto _faca ;_faca :if _egba ++;_egba ==_aeb {goto _ggc ;};_agb :switch _cgb [_egba ]{case 58:goto _dede ;case 65:goto _cda ;case 104:goto _dede ;case 109:goto _dede ;case 115:goto _dbg ;};goto _acgb ;_cda :if _egba ++;_egba ==_aeb {goto _bbaf ;
};_gffe :switch _cgb [_egba ]{case 47:goto _ffc ;case 77:goto _adee ;};goto _fggd ;_ffc :if _egba ++;_egba ==_aeb {goto _eed ;};_fcg :if _cgb [_egba ]==80{goto _dede ;};goto _fggd ;_adee :if _egba ++;_egba ==_aeb {goto _efcg ;};_ecea :if _cgb [_egba ]==47{goto _abfe ;
};goto _fggd ;_abfe :if _egba ++;_egba ==_aeb {goto _gadg ;};_abggf :if _cgb [_egba ]==80{goto _gcf ;};goto _fggd ;_gcf :if _egba ++;_egba ==_aeb {goto _ggcd ;};_ccd :if _cgb [_egba ]==77{goto _dede ;};goto _fggd ;_dbg :_ceaf =_egba +1;_bgb =15;goto _efc ;
_efc :if _egba ++;_egba ==_aeb {goto _fbce ;};_efbd :switch _cgb [_egba ]{case 46:goto _eff ;case 58:goto _dede ;case 65:goto _cda ;case 104:goto _dede ;case 109:goto _dede ;case 115:goto _dbg ;};goto _acgb ;_eff :if _egba ++;_egba ==_aeb {goto _aced ;
};_acgf :if _cgb [_egba ]==48{goto _facf ;};goto _fce ;_facf :_ceaf =_egba +1;_bgb =15;goto _bef ;_bef :if _egba ++;_egba ==_aeb {goto _fbgg ;};_efd :switch _cgb [_egba ]{case 48:goto _fgad ;case 58:goto _dede ;case 65:goto _cda ;case 104:goto _dede ;case 109:goto _dede ;
case 115:goto _dbg ;};goto _acgb ;_fgad :_ceaf =_egba +1;_bgb =15;goto _aea ;_aea :if _egba ++;_egba ==_aeb {goto _gdd ;};_aaaf :switch _cgb [_egba ]{case 48:goto _dede ;case 58:goto _dede ;case 65:goto _cda ;case 104:goto _dede ;case 109:goto _dede ;case 115:goto _dbg ;
};goto _acgb ;_fbbg :_ceaf =_egba +1;_bgb =5;goto _eae ;_eae :if _egba ++;_egba ==_aeb {goto _eaed ;};_fbfc :switch _cgb [_egba ]{case 35:goto _agf ;case 37:goto _agf ;case 47:goto _bae ;case 48:goto _agf ;case 63:goto _agf ;};goto _cba ;_bcb :_ceaf =_egba +1;
_bgb =20;goto _baa ;_baa :if _egba ++;_egba ==_aeb {goto _adf ;};_cfdg :switch _cgb [_egba ]{case 47:goto _ffc ;case 77:goto _adee ;};goto _ffed ;_afd :if _egba ++;_egba ==_aeb {goto _baf ;};_acge :switch _cgb [_egba ]{case 43:goto _ace ;case 45:goto _ace ;
};goto _ffed ;_cfad :_ceaf =_egba +1;goto _gda ;_gda :if _egba ++;_egba ==_aeb {goto _ffb ;};_egbd :if _cgb [_egba ]==101{goto _bbgd ;};goto _ffed ;_bbgd :if _egba ++;_egba ==_aeb {goto _ega ;};_eag :if _cgb [_egba ]==110{goto _efdg ;};goto _dee ;_efdg :if _egba ++;
_egba ==_aeb {goto _edaa ;};_cedc :if _cgb [_egba ]==101{goto _efcf ;};goto _dee ;_efcf :if _egba ++;_egba ==_aeb {goto _ddda ;};_gad :if _cgb [_egba ]==114{goto _fee ;};goto _dee ;_fee :if _egba ++;_egba ==_aeb {goto _bde ;};_acd :if _cgb [_egba ]==97{goto _aade ;
};goto _dee ;_aade :if _egba ++;_egba ==_aeb {goto _dfce ;};_ecbc :if _cgb [_egba ]==108{goto _dbb ;};goto _dee ;_geg :_ceaf =_egba +1;_bgb =20;goto _gfab ;_gfab :if _egba ++;_egba ==_aeb {goto _aeaa ;};_bdgc :switch _cgb [_egba ]{case 104:goto _acdg ;
case 109:goto _acdg ;case 115:goto _acdg ;};goto _egg ;_egg :if _egba ++;_egba ==_aeb {goto _bac ;};_dfb :if _cgb [_egba ]==93{goto _dbgb ;};goto _egg ;_dbgb :_ceaf =_egba +1;_bgb =18;goto _ceab ;_eafd :_ceaf =_egba +1;_bgb =16;goto _ceab ;_ceab :if _egba ++;
_egba ==_aeb {goto _aafc ;};_fcgg :if _cgb [_egba ]==93{goto _dbgb ;};goto _egg ;_acdg :if _egba ++;_egba ==_aeb {goto _gce ;};_cab :if _cgb [_egba ]==93{goto _eafd ;};goto _egg ;_ada :if _egba ++;_egba ==_aeb {goto _deef ;};_eafg :goto _dgdc ;_ege :_ceaf =_egba +1;
_bgb =14;goto _cfbb ;_cfbb :if _egba ++;_egba ==_aeb {goto _ffba ;};_eacg :switch _cgb [_egba ]{case 47:goto _cbeg ;case 58:goto _dede ;case 65:goto _cda ;case 100:goto _cbeg ;case 104:goto _dede ;case 109:goto _ege ;case 115:goto _dbg ;case 121:goto _egd ;
};goto _fca ;_fea :if _egba ++;_egba ==_aeb {goto _bgcg ;};_cgbc :if _cgb [_egba ]==121{goto _cbeg ;};goto _ffed ;_gfc :_aedb :_ceb =34;goto _bfaa ;_eggf :_ceb =35;goto _bfaa ;_afgf :_ceb =0;goto _bfaa ;_afabf :_ceb =36;goto _bfaa ;_dcdc :_ceb =37;goto _bfaa ;
_ecdc :_ceb =1;goto _bfaa ;_fcca :_ceb =2;goto _bfaa ;_bbfe :_ceb =38;goto _bfaa ;_ffae :_ceb =3;goto _bfaa ;_gfdg :_ceb =4;goto _bfaa ;_edgb :_ceb =39;goto _bfaa ;_afbb :_ceb =5;goto _bfaa ;_ffad :_ceb =6;goto _bfaa ;_fgef :_ceb =7;goto _bfaa ;_dafe :_ceb =8;
goto _bfaa ;_gffg :_ceb =40;goto _bfaa ;_ead :_ceb =9;goto _bfaa ;_feed :_ceb =41;goto _bfaa ;_bedc :_ceb =10;goto _bfaa ;_edaf :_ceb =42;goto _bfaa ;_cgd :_ceb =11;goto _bfaa ;_eec :_ceb =43;goto _bfaa ;_ggfg :_ceb =44;goto _bfaa ;_cbde :_ceb =45;goto _bfaa ;
_feaa :_ceb =12;goto _bfaa ;_aga :_ceb =46;goto _bfaa ;_aeg :_ceb =13;goto _bfaa ;_cgdb :_ceb =14;goto _bfaa ;_gge :_ceb =15;goto _bfaa ;_eacd :_ceb =16;goto _bfaa ;_ebb :_ceb =47;goto _bfaa ;_gbf :_ceb =17;goto _bfaa ;_facfe :_ceb =48;goto _bfaa ;_bdgb :_ceb =18;
goto _bfaa ;_eagc :_ceb =19;goto _bfaa ;_fdf :_ceb =20;goto _bfaa ;_cfc :_ceb =49;goto _bfaa ;_ggc :_ceb =50;goto _bfaa ;_bbaf :_ceb =21;goto _bfaa ;_eed :_ceb =22;goto _bfaa ;_efcg :_ceb =23;goto _bfaa ;_gadg :_ceb =24;goto _bfaa ;_ggcd :_ceb =25;goto _bfaa ;
_fbce :_ceb =51;goto _bfaa ;_aced :_ceb =26;goto _bfaa ;_fbgg :_ceb =52;goto _bfaa ;_gdd :_ceb =53;goto _bfaa ;_eaed :_ceb =54;goto _bfaa ;_adf :_ceb =55;goto _bfaa ;_baf :_ceb =56;goto _bfaa ;_ffb :_ceb =57;goto _bfaa ;_ega :_ceb =27;goto _bfaa ;_edaa :_ceb =28;
goto _bfaa ;_ddda :_ceb =29;goto _bfaa ;_bde :_ceb =30;goto _bfaa ;_dfce :_ceb =31;goto _bfaa ;_aeaa :_ceb =58;goto _bfaa ;_bac :_ceb =32;goto _bfaa ;_aafc :_ceb =59;goto _bfaa ;_gce :_ceb =33;goto _bfaa ;_deef :_ceb =60;goto _bfaa ;_ffba :_ceb =61;goto _bfaa ;
_bgcg :_ceb =62;goto _bfaa ;_bfaa :{};if _egba ==_bba {switch _ceb {case 35:goto _ffed ;case 0:goto _fggd ;case 36:goto _bede ;case 37:goto _bee ;case 1:goto _fggd ;case 2:goto _fggd ;case 38:goto _edc ;case 3:goto _eaf ;case 4:goto _eaf ;case 39:goto _edc ;
case 5:goto _eaf ;case 6:goto _eaf ;case 7:goto _eaf ;case 8:goto _fggd ;case 40:goto _edc ;case 9:goto _eaf ;case 41:goto _edc ;case 10:goto _fggd ;case 42:goto _edc ;case 11:goto _eaf ;case 43:goto _edc ;case 44:goto _edc ;case 45:goto _edc ;case 12:goto _fbgf ;
case 46:goto _fgga ;case 13:goto _bdf ;case 14:goto _fggd ;case 15:goto _fggd ;case 16:goto _bdf ;case 47:goto _fca ;case 17:goto _aca ;case 48:goto _bdd ;case 18:goto _dcdd ;case 19:goto _dcdd ;case 20:goto _fggd ;case 49:goto _ffed ;case 50:goto _acgb ;
case 21:goto _fggd ;case 22:goto _fggd ;case 23:goto _fggd ;case 24:goto _fggd ;case 25:goto _fggd ;case 51:goto _acgb ;case 26:goto _fce ;case 52:goto _acgb ;case 53:goto _acgb ;case 54:goto _cba ;case 55:goto _ffed ;case 56:goto _ffed ;case 57:goto _ffed ;
case 27:goto _dee ;case 28:goto _dee ;case 29:goto _dee ;case 30:goto _dee ;case 31:goto _dee ;case 58:goto _ffed ;case 32:goto _fggd ;case 59:goto _fggd ;case 33:goto _dee ;case 60:goto _ffed ;case 61:goto _fca ;case 62:goto _ffed ;};};};if _afe > 0{copy (_cgb [0:],_cgb [_afe :]);
};};_ =_bba ;if _ceb ==_ade {_d .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};func IsNumber (data string )(_gfg bool ){_dbd ,_bcf ,_dab :=0,0,len (data );_aaa :=len (data );_gff ,_dcc ,_dec :=0,0,0;
_ =_dcc ;_ =_dec ;_ =_gff ;{_dbd =_gfdd ;_gff =0;_dcc =0;_dec =0;};{if _bcf ==_dab {goto _ddad ;};switch _dbd {case 0:goto _fegg ;case 1:goto _gaf ;case 2:goto _gac ;case 3:goto _fdd ;case 4:goto _feca ;case 5:goto _adc ;case 6:goto _bbc ;case 7:goto _efe ;
};goto _bdg ;_bce :_dcc =_bcf ;_bcf --;{_gfg =false ;};goto _gde ;_abgd :_dcc =_bcf ;_bcf --;{_gfg =_dcc ==len (data );};goto _gde ;_fcf :_dcc =_bcf ;_bcf --;{_gfg =_dcc ==len (data );};goto _gde ;_acb :switch _dec {case 2:{_bcf =(_dcc )-1;_gfg =_dcc ==len (data );
};case 3:{_bcf =(_dcc )-1;_gfg =false ;};};goto _gde ;_gde :_gff =0;if _bcf ++;_bcf ==_dab {goto _fbc ;};_fegg :_gff =_bcf ;switch data [_bcf ]{case 43:goto _dfee ;case 45:goto _dfee ;};if 48<=data [_bcf ]&&data [_bcf ]<=57{goto _bgd ;};goto _fdb ;_fdb :if _bcf ++;
_bcf ==_dab {goto _ecf ;};_gaf :goto _fdb ;_dfee :if _bcf ++;_bcf ==_dab {goto _ggd ;};_gac :if 48<=data [_bcf ]&&data [_bcf ]<=57{goto _bgd ;};goto _fdb ;_bgd :if _bcf ++;_bcf ==_dab {goto _cae ;};_fdd :if data [_bcf ]==46{goto _geed ;};if 48<=data [_bcf ]&&data [_bcf ]<=57{goto _bgd ;
};goto _fdb ;_geed :if _bcf ++;_bcf ==_dab {goto _beda ;};_feca :if 48<=data [_bcf ]&&data [_bcf ]<=57{goto _dbf ;};goto _fdb ;_dbf :if _bcf ++;_bcf ==_dab {goto _ebaa ;};_adc :if data [_bcf ]==69{goto _acg ;};if 48<=data [_bcf ]&&data [_bcf ]<=57{goto _dbf ;
};goto _fdb ;_acg :if _bcf ++;_bcf ==_dab {goto _gga ;};_bbc :switch data [_bcf ]{case 43:goto _bga ;case 45:goto _bga ;};goto _fdb ;_bga :_dcc =_bcf +1;_dec =3;goto _bbf ;_ece :_dcc =_bcf +1;_dec =2;goto _bbf ;_bbf :if _bcf ++;_bcf ==_dab {goto _ebg ;
};_efe :if 48<=data [_bcf ]&&data [_bcf ]<=57{goto _ece ;};goto _fdb ;_bdg :_fbc :_dbd =0;goto _ddad ;_ecf :_dbd =1;goto _ddad ;_ggd :_dbd =2;goto _ddad ;_cae :_dbd =3;goto _ddad ;_beda :_dbd =4;goto _ddad ;_ebaa :_dbd =5;goto _ddad ;_gga :_dbd =6;goto _ddad ;
_ebg :_dbd =7;goto _ddad ;_ddad :{};if _bcf ==_aaa {switch _dbd {case 1:goto _bce ;case 2:goto _bce ;case 3:goto _abgd ;case 4:goto _bce ;case 5:goto _fcf ;case 6:goto _bce ;case 7:goto _acb ;};};};if _dbd ==_ade {return false ;};return ;};const _aa =1e-10;


// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;const _fbae int =0;

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _ac .Abs (v )>=_ca ||_ac .Abs (v )<=_aa &&v !=0{return _bbg (v );};_dcf :=make ([]byte ,0,15);_dcf =_a .AppendFloat (_dcf ,v ,'f',-1,64);if len (_dcf )> 11{_ffa :=_dcf [11]-'0';if _ffa >=5&&_ffa <=9{_dcf [10]++;
_dcf =_dcf [0:11];_dcf =_aab (_dcf );};_dcf =_dcf [0:11];}else if len (_dcf )==11{if _dcf [len (_dcf )-1]=='9'{_dcf [len (_dcf )-1]++;_dcf =_aab (_dcf );};};_dcf =_faa (_dcf );return string (_dcf );};

// AddToken adds a format token to the format.
func (_cc *Format )AddToken (t FmtType ,l []byte ){if _cc ._df {_cc ._df =false ;return ;};switch t {case FmtTypeDecimal :_cc ._gd =true ;case FmtTypeUnderscore :_cc ._df =true ;case FmtTypeText :_cc .Whole =append (_cc .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_cc .Whole =append (_cc .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_cc ._ddc =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ga :=range l {if _cc .IsExponential {_cc .Exponent =append (_cc .Exponent ,Token {Type :t ,Literal :_ga });
}else if !_cc ._gd {_cc .Whole =append (_cc .Whole ,Token {Type :t ,Literal :_ga });}else {_cc .Fractional =append (_cc .Fractional ,Token {Type :t ,Literal :_ga });};};case FmtTypeDigitOptThousands :_cc ._ea =true ;case FmtTypeFraction :_eb :=_ed .Split (string (l ),"\u002f");
if len (_eb )==2{_cc ._ab =true ;_cc ._fd ,_ =_a .ParseInt (_eb [1],10,64);for _ ,_fe :=range _eb [1]{if _fe =='?'||_fe =='0'{_cc ._ge ++;};};};default:_d .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_ebf :=Parse (f );if len (_ebf )==1{return _ef (v ,_ebf [0],false );}else if len (_ebf )> 1&&v < 0{return _ef (v ,_ebf [1],true );
}else if len (_ebf )> 2&&v ==0{return _ef (v ,_ebf [2],false );};return _ef (v ,_ebf [0],false );};func _dfe (_afa int64 ,_dga Format )[]byte {if !_dga .IsExponential ||len (_dga .Exponent )==0{return nil ;};_cfa :=_a .AppendInt (nil ,_dgde (_afa ),10);
_gfd :=make ([]byte ,0,len (_cfa )+2);_gfd =append (_gfd ,'E');if _afa >=0{_gfd =append (_gfd ,'+');}else {_gfd =append (_gfd ,'-');_afa *=-1;};_fecg :=0;_fa :for _afb :=len (_dga .Exponent )-1;_afb >=0;_afb --{_ae :=len (_cfa )-1-_fecg ;_cegd :=_dga .Exponent [_afb ];
switch _cegd .Type {case FmtTypeDigit :if _ae >=0{_gfd =append (_gfd ,_cfa [_ae ]);_fecg ++;}else {_gfd =append (_gfd ,'0');};case FmtTypeDigitOpt :if _ae >=0{_gfd =append (_gfd ,_cfa [_ae ]);_fecg ++;}else {for _bbe :=_afb ;_bbe >=0;_bbe --{_bg :=_dga .Exponent [_bbe ];
if _bg .Type ==FmtTypeLiteral {_gfd =append (_gfd ,_bg .Literal );};};break _fa ;};case FmtTypeLiteral :_gfd =append (_gfd ,_cegd .Literal );default:_d .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_cegd );
};};if _fecg < len (_cfa ){_gfd =append (_gfd ,_cfa [len (_cfa )-_fecg -1:_fecg -1]...);};_dda (_gfd [2:]);return _gfd ;};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_eac ,_ :=_a .ParseFloat (v ,64);return Number (_eac ,f );};return String (v ,f );};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_ab bool ;_ddc bool ;_ddf bool ;_ea bool ;_df bool ;_gd bool ;_fd int64 ;_ge int ;};const _ddd int =34;const _ca =1e11;func (_ggge *Lexer )nextFmt (){_ggge ._ag =append (_ggge ._ag ,_ggge ._fbfg );
_ggge ._fbfg =Format {}};const _cge int =34;type Lexer struct{_fbfg Format ;_ag []Format ;};func _bgbd (_gdad _ee .Time )_ee .Time {_gdad =_gdad .UTC ();return _ee .Date (_gdad .Year (),_gdad .Month (),_gdad .Day (),_gdad .Hour (),_gdad .Minute (),_gdad .Second (),_gdad .Nanosecond (),_ee .Local );
};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _aab (_ffe []byte )[]byte {for _feg :=len (_ffe )-1;
_feg > 0;_feg --{if _ffe [_feg ]=='9'+1{_ffe [_feg ]='0';if _ffe [_feg -1]=='.'{_feg --;};_ffe [_feg -1]++;};};if _ffe [0]=='9'+1{_ffe [0]='0';copy (_ffe [1:],_ffe [0:]);_ffe [0]='1';};return _ffe ;};const _bbga int =34;func _cfe (_bb ,_bda float64 ,_abfg Format )[]byte {if len (_abfg .Whole )==0{return nil ;
};_eeb :=_ee .Date (1899,12,30,0,0,0,0,_ee .UTC );_gbd :=_eeb .Add (_ee .Duration (_bda *float64 (24*_ee .Hour )));_gbd =_bgbd (_gbd );_gab :=_a .AppendFloat (nil ,_bb ,'f',-1,64);_bdc :=make ([]byte ,0,len (_gab ));_fec :=0;_aafg :=1;_gc :for _gea :=len (_abfg .Whole )-1;
_gea >=0;_gea --{_gee :=len (_gab )-1-_fec ;_fbd :=_abfg .Whole [_gea ];switch _fbd .Type {case FmtTypeDigit :if _gee >=0{_bdc =append (_bdc ,_gab [_gee ]);_fec ++;_aafg =_gea ;}else {_bdc =append (_bdc ,'0');};case FmtTypeDigitOpt :if _gee >=0{_bdc =append (_bdc ,_gab [_gee ]);
_fec ++;_aafg =_gea ;}else {for _cdf :=_gea ;_cdf >=0;_cdf --{_abe :=_abfg .Whole [_cdf ];if _abe .Type ==FmtTypeLiteral {_bdc =append (_bdc ,_abe .Literal );};};break _gc ;};case FmtTypeDollar :for _daa :=_fec ;_daa < len (_gab );_daa ++{_bdc =append (_bdc ,_gab [len (_gab )-1-_daa ]);
_fec ++;};_bdc =append (_bdc ,'$');case FmtTypeComma :if !_abfg ._ea {_bdc =append (_bdc ,',');};case FmtTypeLiteral :_bdc =append (_bdc ,_fbd .Literal );case FmtTypeDate :_bdc =append (_bdc ,_dda (_eabe (_gbd ,_fbd .DateTime ))...);case FmtTypeTime :_bdc =append (_bdc ,_dda (_ba (_gbd ,_bda ,_fbd .DateTime ))...);
default:_d .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_fbd );};};_cdb :=_dda (_bdc );if _fec < len (_gab )&&(_fec !=0||_abfg ._gd ){_geb :=len (_gab )-_fec ;
_eba :=make ([]byte ,len (_cdb )+_geb );copy (_eba ,_cdb [0:_aafg ]);copy (_eba [_aafg :],_gab [0:]);copy (_eba [_aafg +_geb :],_cdb [_aafg :]);_cdb =_eba ;};if _abfg ._ea {_dde :=_bc .Buffer {};_ceg :=0;for _de :=len (_cdb )-1;_de >=0;_de --{if !(_cdb [_de ]>='0'&&_cdb [_de ]<='9'){_ceg ++;
}else {break ;};};for _ebad :=0;_ebad < len (_cdb );_ebad ++{_ged :=(len (_cdb )-_ebad -_ceg );if _ged %3==0&&_ged !=0&&_ebad !=0{_dde .WriteByte (',');};_dde .WriteByte (_cdb [_ebad ]);};_cdb =_dde .Bytes ();};return _cdb ;};func _faa (_gfa []byte )[]byte {_cfb :=len (_gfa );
_ad :=false ;_fab :=false ;for _ddcb :=len (_gfa )-1;_ddcb >=0;_ddcb --{if _gfa [_ddcb ]=='0'&&!_fab &&!_ad {_cfb =_ddcb ;}else if _gfa [_ddcb ]=='.'{_ad =true ;}else {_fab =true ;};};if _ad &&_fab {if _gfa [_cfb -1]=='.'{_cfb --;};return _gfa [0:_cfb ];
};return _gfa ;};const _dd ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
func _ef (_abf float64 ,_dfc Format ,_eab bool )string {if _dfc ._ddf {return NumberGeneric (_abf );};_da :=make ([]byte ,0,20);_eg :=_ac .Signbit (_abf );_af :=_ac .Abs (_abf );_dba :=int64 (0);_dc :=int64 (0);if _dfc .IsExponential {for _af >=10{_dc ++;
_af /=10;};for _af < 1{_dc --;_af *=10;};}else if _dfc ._ddc {_af *=100;}else if _dfc ._ab {if _dfc ._fd ==0{_ce :=_ac .Pow (10,float64 (_dfc ._ge ));_bdb ,_gb :=1.0,1.0;_ =_bdb ;for _cb :=1.0;_cb < _ce ;_cb ++{_ ,_ecc :=_ac .Modf (_af *float64 (_cb ));
if _ecc < _gb {_gb =_ecc ;_bdb =_cb ;if _ecc ==0{break ;};};};_dfc ._fd =int64 (_bdb );};_dba =int64 (_af *float64 (_dfc ._fd )+0.5);if len (_dfc .Whole )> 0&&_dba > _dfc ._fd {_dba =int64 (_af *float64 (_dfc ._fd ))%_dfc ._fd ;_af -=float64 (_dba )/float64 (_dfc ._fd );
}else {_af -=float64 (_dba )/float64 (_dfc ._fd );if _ac .Abs (_af )< 1{_fbf :=true ;for _ ,_bf :=range _dfc .Whole {if _bf .Type ==FmtTypeDigitOpt {continue ;};if _bf .Type ==FmtTypeLiteral &&_bf .Literal ==' '{continue ;};_fbf =false ;};if _fbf {_dfc .Whole =nil ;
};};};};_aba :=1;for _ ,_bfc :=range _dfc .Fractional {if _bfc .Type ==FmtTypeDigit ||_bfc .Type ==FmtTypeDigitOpt {_aba ++;};};_af +=5*_ac .Pow10 (-_aba );_gbg ,_efb :=_ac .Modf (_af );_da =append (_da ,_cfe (_gbg ,_abf ,_dfc )...);_da =append (_da ,_fge (_efb ,_abf ,_dfc )...);
_da =append (_da ,_dfe (_dc ,_dfc )...);if _dfc ._ab {_da =_a .AppendInt (_da ,_dba ,10);_da =append (_da ,'/');_da =_a .AppendInt (_da ,_dfc ._fd ,10);};if !_eab &&_eg {return "\u002d"+string (_da );};return string (_da );};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_bd :=Parse (f );var _dg Format ;if len (_bd )==1{_dg =_bd [0];}else if len (_bd )==4{_dg =_bd [3];};_ec :=false ;for _ ,_abc :=range _dg .Whole {if _abc .Type ==FmtTypeText {_ec =true ;};};if !_ec {return v ;};
_fg :=_bc .Buffer {};for _ ,_acc :=range _dg .Whole {switch _acc .Type {case FmtTypeLiteral :_fg .WriteByte (_acc .Literal );case FmtTypeText :_fg .WriteString (v );};};return _fg .String ();};func _eabe (_beg _ee .Time ,_ecd string )[]byte {_fga :=[]byte {};
_cbe :=0;for _fba :=0;_fba < len (_ecd );_fba ++{var _egc string ;if _ecd [_fba ]=='/'{_egc =string (_ecd [_cbe :_fba ]);_cbe =_fba +1;}else if _fba ==len (_ecd )-1{_egc =string (_ecd [_cbe :_fba +1]);}else {continue ;};switch _egc {case "\u0079\u0079":_fga =_beg .AppendFormat (_fga ,"\u0030\u0036");
case "\u0079\u0079\u0079\u0079":_fga =_beg .AppendFormat (_fga ,"\u0032\u0030\u0030\u0036");case "\u006d":_fga =_beg .AppendFormat (_fga ,"\u0031");case "\u006d\u006d":_fga =_beg .AppendFormat (_fga ,"\u0030\u0031");case "\u006d\u006d\u006d":_fga =_beg .AppendFormat (_fga ,"\u004a\u0061\u006e");
case "\u006d\u006d\u006d\u006d":_fga =_beg .AppendFormat (_fga ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _beg .Month (){case _ee .January ,_ee .July ,_ee .June :_fga =append (_fga ,'J');case _ee .February :_fga =append (_fga ,'M');
case _ee .March ,_ee .May :_fga =append (_fga ,'M');case _ee .April ,_ee .August :_fga =append (_fga ,'A');case _ee .September :_fga =append (_fga ,'S');case _ee .October :_fga =append (_fga ,'O');case _ee .November :_fga =append (_fga ,'N');case _ee .December :_fga =append (_fga ,'D');
};case "\u0064":_fga =_beg .AppendFormat (_fga ,"\u0032");case "\u0064\u0064":_fga =_beg .AppendFormat (_fga ,"\u0030\u0032");case "\u0064\u0064\u0064":_fga =_beg .AppendFormat (_fga ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_fga =_beg .AppendFormat (_fga ,"\u004d\u006f\u006e\u0064\u0061\u0079");
default:_d .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_egc );};if _ecd [_fba ]=='/'{_fga =append (_fga ,'/');};};return _fga ;};func Parse (s string )[]Format {_fbb :=Lexer {};
_fbb .Lex (_ed .NewReader (s ));_fbb ._ag =append (_fbb ._ag ,_fbb ._fbfg );return _fbb ._ag ;};func _dgde (_dcg int64 )int64 {if _dcg < 0{return -_dcg ;};return _dcg ;};func _fge (_fgeb ,_ecg float64 ,_gfb Format )[]byte {if len (_gfb .Fractional )==0{return nil ;
};_cdc :=_a .AppendFloat (nil ,_fgeb ,'f',-1,64);if len (_cdc )> 2{_cdc =_cdc [2:];}else {_cdc =nil ;};_caf :=make ([]byte ,0,len (_cdc ));_caf =append (_caf ,'.');_ff :=0;_dgd :for _bca :=0;_bca < len (_gfb .Fractional );_bca ++{_geeg :=_bca ;_gdb :=_gfb .Fractional [_bca ];
switch _gdb .Type {case FmtTypeDigit :if _geeg < len (_cdc ){_caf =append (_caf ,_cdc [_geeg ]);_ff ++;}else {_caf =append (_caf ,'0');};case FmtTypeDigitOpt :if _geeg >=0{_caf =append (_caf ,_cdc [_geeg ]);_ff ++;}else {break _dgd ;};case FmtTypeLiteral :_caf =append (_caf ,_gdb .Literal );
default:_d .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_gdb );};};return _caf ;};const _bec int =0;
const _fabf int =-1;func _ba (_ded _ee .Time ,_gg float64 ,_fdg string )[]byte {_dbad :=[]byte {};_ggg :=0;for _fgg :=0;_fgg < len (_fdg );_fgg ++{var _abg string ;if _fdg [_fgg ]==':'{_abg =string (_fdg [_ggg :_fgg ]);_ggg =_fgg +1;}else if _fgg ==len (_fdg )-1{_abg =string (_fdg [_ggg :_fgg +1]);
}else {continue ;};switch _abg {case "\u0064":_dbad =_ded .AppendFormat (_dbad ,"\u0032");case "\u0068":_dbad =_ded .AppendFormat (_dbad ,"\u0033");case "\u0068\u0068":_dbad =_ded .AppendFormat (_dbad ,"\u0031\u0035");case "\u006d":_dbad =_ded .AppendFormat (_dbad ,"\u0034");
case "\u006d\u006d":_dbad =_ded .AppendFormat (_dbad ,"\u0030\u0034");case "\u0073":_dbad =_ded .Round (_ee .Second ).AppendFormat (_dbad ,"\u0035");case "\u0073\u002e\u0030":_dbad =_ded .Round (_ee .Second /10).AppendFormat (_dbad ,"\u0035\u002e\u0030");
case "\u0073\u002e\u0030\u0030":_dbad =_ded .Round (_ee .Second /100).AppendFormat (_dbad ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_dbad =_ded .Round (_ee .Second /1000).AppendFormat (_dbad ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_dbad =_ded .Round (_ee .Second ).AppendFormat (_dbad ,"\u0030\u0035");
case "\u0073\u0073\u002e\u0030":_dbad =_ded .Round (_ee .Second /10).AppendFormat (_dbad ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_dbad =_ded .Round (_ee .Second /100).AppendFormat (_dbad ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_dbad =_ded .Round (_ee .Second /1000).AppendFormat (_dbad ,"\u0030\u0035\u002e\u0030\u0030\u0030");
case "\u0041\u004d\u002fP\u004d":_dbad =_ded .AppendFormat (_dbad ,"\u0050\u004d");case "\u005b\u0068\u005d":_dbad =_a .AppendInt (_dbad ,int64 (_gg *24),10);case "\u005b\u006d\u005d":_dbad =_a .AppendInt (_dbad ,int64 (_gg *24*60),10);case "\u005b\u0073\u005d":_dbad =_a .AppendInt (_dbad ,int64 (_gg *24*60*60),10);
case "":default:_d .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_abg );};if _fdg [_fgg ]==':'{_dbad =append (_dbad ,':');};};return _dbad ;
};const _ade int =-1;var _g =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};func (_f FmtType )String ()string {if _f >=FmtType (len (_g )-1){return _c .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_f );};return _dd [_g [_f ]:_g [_f +1]];
};