//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_ff "bytes";_c "fmt";_fd "github.com/unidoc/unioffice/v2/common/logger";_f "io";_e "math";_d "strconv";_g "strings";_cc "time";);

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};func _gba (_fbb []byte )[]byte {for _eda :=0;_eda < len (_fbb )/2;_eda ++{_be :=len (_fbb )-1-_eda ;_fbb [_eda ],_fbb [_be ]=_fbb [_be ],_fbb [_eda ];};return _fbb ;};var _cb =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};


// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;func _gbd (_agg ,_aff float64 ,_edf Format )[]byte {if len (_edf .Whole )==0{return nil ;};_fc :=_cc .Date (1899,12,30,0,0,0,0,_cc .UTC );_ebg :=_fc .Add (_cc .Duration (_aff *float64 (24*_cc .Hour )));_ebg =_bdfb (_ebg );_cfg :=_d .AppendFloat (nil ,_agg ,'f',-1,64);
_ace :=make ([]byte ,0,len (_cfg ));_bbg :=0;_bae :=1;_aa :for _ddc :=len (_edf .Whole )-1;_ddc >=0;_ddc --{_bd :=len (_cfg )-1-_bbg ;_da :=_edf .Whole [_ddc ];switch _da .Type {case FmtTypeDigit :if _bd >=0{_ace =append (_ace ,_cfg [_bd ]);_bbg ++;_bae =_ddc ;
}else {_ace =append (_ace ,'0');};case FmtTypeDigitOpt :if _bd >=0{_ace =append (_ace ,_cfg [_bd ]);_bbg ++;_bae =_ddc ;}else {for _ab :=_ddc ;_ab >=0;_ab --{_cec :=_edf .Whole [_ab ];if _cec .Type ==FmtTypeLiteral {_ace =append (_ace ,_cec .Literal );
};};break _aa ;};case FmtTypeDollar :for _eg :=_bbg ;_eg < len (_cfg );_eg ++{_ace =append (_ace ,_cfg [len (_cfg )-1-_eg ]);_bbg ++;};_ace =append (_ace ,'$');case FmtTypeComma :if !_edf ._ec {_ace =append (_ace ,',');};case FmtTypeLiteral :_ace =append (_ace ,_da .Literal );
case FmtTypeDate :_ace =append (_ace ,_gba (_gdf (_ebg ,_da .DateTime ))...);case FmtTypeTime :_ace =append (_ace ,_gba (_facg (_ebg ,_aff ,_da .DateTime ))...);default:_fd .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_da );
};};_cgdd :=_gba (_ace );if _bbg < len (_cfg )&&(_bbg !=0||_edf ._dg ){_cfe :=len (_cfg )-_bbg ;_ede :=make ([]byte ,len (_cgdd )+_cfe );copy (_ede ,_cgdd [0:_bae ]);copy (_ede [_bae :],_cfg [0:]);copy (_ede [_bae +_cfe :],_cgdd [_bae :]);_cgdd =_ede ;
};if _edf ._ec {_ebb :=_ff .Buffer {};_gca :=0;for _gd :=len (_cgdd )-1;_gd >=0;_gd --{if !(_cgdd [_gd ]>='0'&&_cgdd [_gd ]<='9'){_gca ++;}else {break ;};};for _caf :=0;_caf < len (_cgdd );_caf ++{_daa :=(len (_cgdd )-_caf -_gca );if _daa %3==0&&_daa !=0&&_caf !=0{_ebb .WriteByte (',');
};_ebb .WriteByte (_cgdd [_caf ]);};_cgdd =_ebb .Bytes ();};return _cgdd ;};func _fbbg (_gfd float64 )string {_bfg :=_d .FormatFloat (_gfd ,'E',-1,64);_agf :=_d .FormatFloat (_gfd ,'E',5,64);if len (_bfg )< len (_agf ){return _d .FormatFloat (_gfd ,'E',2,64);
};return _agf ;};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_ac ,_ :=_d .ParseFloat (v ,64);return Number (_ac ,f );};return String (v ,f );};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_ed bool ;_b bool ;_dd bool ;_ec bool ;_ag bool ;_dg bool ;_cg int64 ;_fb int ;};func _fdf (_cf float64 ,_bbfa Format ,_ffd bool )string {if _bbfa ._dd {return NumberGeneric (_cf );
};_ga :=make ([]byte ,0,20);_ge :=_e .Signbit (_cf );_bg :=_e .Abs (_cf );_ffdf :=int64 (0);_cdaa :=int64 (0);if _bbfa .IsExponential {for _bg >=10{_cdaa ++;_bg /=10;};for _bg < 1{_cdaa --;_bg *=10;};}else if _bbfa ._b {_bg *=100;}else if _bbfa ._ed {if _bbfa ._cg ==0{_ccf :=_e .Pow (10,float64 (_bbfa ._fb ));
_fed ,_cgd :=1.0,1.0;_ =_fed ;for _bbfb :=1.0;_bbfb < _ccf ;_bbfb ++{_ ,_bfb :=_e .Modf (_bg *float64 (_bbfb ));if _bfb < _cgd {_cgd =_bfb ;_fed =_bbfb ;if _bfb ==0{break ;};};};_bbfa ._cg =int64 (_fed );};_ffdf =int64 (_bg *float64 (_bbfa ._cg )+0.5);
if len (_bbfa .Whole )> 0&&_ffdf > _bbfa ._cg {_ffdf =int64 (_bg *float64 (_bbfa ._cg ))%_bbfa ._cg ;_bg -=float64 (_ffdf )/float64 (_bbfa ._cg );}else {_bg -=float64 (_ffdf )/float64 (_bbfa ._cg );if _e .Abs (_bg )< 1{_bga :=true ;for _ ,_gg :=range _bbfa .Whole {if _gg .Type ==FmtTypeDigitOpt {continue ;
};if _gg .Type ==FmtTypeLiteral &&_gg .Literal ==' '{continue ;};_bga =false ;};if _bga {_bbfa .Whole =nil ;};};};};_bbfc :=1;for _ ,_cga :=range _bbfa .Fractional {if _cga .Type ==FmtTypeDigit ||_cga .Type ==FmtTypeDigitOpt {_bbfc ++;};};_bg +=5*_e .Pow10 (-_bbfc );
_ad ,_ca :=_e .Modf (_bg );_ga =append (_ga ,_gbd (_ad ,_cf ,_bbfa )...);_ga =append (_ga ,_fg (_ca ,_cf ,_bbfa )...);_ga =append (_ga ,_ceb (_cdaa ,_bbfa )...);if _bbfa ._ed {_ga =_d .AppendInt (_ga ,_ffdf ,10);_ga =append (_ga ,'/');_ga =_d .AppendInt (_ga ,_bbfa ._cg ,10);
};if !_ffd &&_ge {return "\u002d"+string (_ga );};return string (_ga );};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_ced :=Parse (f );if len (_ced )==1{return _fdf (v ,_ced [0],false );}else if len (_ced )> 1&&v < 0{return _fdf (v ,_ced [1],true );
}else if len (_ced )> 2&&v ==0{return _fdf (v ,_ced [2],false );};return _fdf (v ,_ced [0],false );};func _aga (_fac []byte )[]byte {_bdf :=len (_fac );_daaf :=false ;_ebgg :=false ;for _bab :=len (_fac )-1;_bab >=0;_bab --{if _fac [_bab ]=='0'&&!_ebgg &&!_daaf {_bdf =_bab ;
}else if _fac [_bab ]=='.'{_daaf =true ;}else {_ebgg =true ;};};if _daaf &&_ebgg {if _fac [_bdf -1]=='.'{_bdf --;};return _fac [0:_bdf ];};return _fac ;};func _afa (_bdba []byte )[]byte {for _abf :=len (_bdba )-1;_abf > 0;_abf --{if _bdba [_abf ]=='9'+1{_bdba [_abf ]='0';
if _bdba [_abf -1]=='.'{_abf --;};_bdba [_abf -1]++;};};if _bdba [0]=='9'+1{_bdba [0]='0';copy (_bdba [1:],_bdba [0:]);_bdba [0]='1';};return _bdba ;};const _ddd int =0;func IsNumber (data string )(_aee bool ){_edc ,_bggb ,_gagf :=0,0,len (data );_adf :=len (data );
_ddb ,_cdf ,_fcb :=0,0,0;_ =_cdf ;_ =_fcb ;_ =_ddb ;{_edc =_gce ;_ddb =0;_cdf =0;_fcb =0;};{if _bggb ==_gagf {goto _adc ;};switch _edc {case 0:goto _bgd ;case 1:goto _ccd ;case 2:goto _agaf ;case 3:goto _ega ;case 4:goto _eef ;case 5:goto _acg ;case 6:goto _acb ;
case 7:goto _ddcg ;};goto _ebf ;_gcac :_cdf =_bggb ;_bggb --;{_aee =false ;};goto _aabg ;_ded :_cdf =_bggb ;_bggb --;{_aee =_cdf ==len (data );};goto _aabg ;_bea :_cdf =_bggb ;_bggb --;{_aee =_cdf ==len (data );};goto _aabg ;_baa :switch _fcb {case 2:{_bggb =(_cdf )-1;
_aee =_cdf ==len (data );};case 3:{_bggb =(_cdf )-1;_aee =false ;};};goto _aabg ;_aabg :_ddb =0;if _bggb ++;_bggb ==_gagf {goto _bc ;};_bgd :_ddb =_bggb ;switch data [_bggb ]{case 43:goto _gbc ;case 45:goto _gbc ;};if 48<=data [_bggb ]&&data [_bggb ]<=57{goto _ebga ;
};goto _bff ;_bff :if _bggb ++;_bggb ==_gagf {goto _dedg ;};_ccd :goto _bff ;_gbc :if _bggb ++;_bggb ==_gagf {goto _cea ;};_agaf :if 48<=data [_bggb ]&&data [_bggb ]<=57{goto _ebga ;};goto _bff ;_ebga :if _bggb ++;_bggb ==_gagf {goto _cfb ;};_ega :if data [_bggb ]==46{goto _aeef ;
};if 48<=data [_bggb ]&&data [_bggb ]<=57{goto _ebga ;};goto _bff ;_aeef :if _bggb ++;_bggb ==_gagf {goto _gfda ;};_eef :if 48<=data [_bggb ]&&data [_bggb ]<=57{goto _aead ;};goto _bff ;_aead :if _bggb ++;_bggb ==_gagf {goto _fbg ;};_acg :if data [_bggb ]==69{goto _gcf ;
};if 48<=data [_bggb ]&&data [_bggb ]<=57{goto _aead ;};goto _bff ;_gcf :if _bggb ++;_bggb ==_gagf {goto _bad ;};_acb :switch data [_bggb ]{case 43:goto _aabb ;case 45:goto _aabb ;};goto _bff ;_aabb :_cdf =_bggb +1;_fcb =3;goto _fff ;_baf :_cdf =_bggb +1;
_fcb =2;goto _fff ;_fff :if _bggb ++;_bggb ==_gagf {goto _bbe ;};_ddcg :if 48<=data [_bggb ]&&data [_bggb ]<=57{goto _baf ;};goto _bff ;_ebf :_bc :_edc =0;goto _adc ;_dedg :_edc =1;goto _adc ;_cea :_edc =2;goto _adc ;_cfb :_edc =3;goto _adc ;_gfda :_edc =4;
goto _adc ;_fbg :_edc =5;goto _adc ;_bad :_edc =6;goto _adc ;_bbe :_edc =7;goto _adc ;_adc :{};if _bggb ==_adf {switch _edc {case 1:goto _gcac ;case 2:goto _gcac ;case 3:goto _ded ;case 4:goto _gcac ;case 5:goto _bea ;case 6:goto _gcac ;case 7:goto _baa ;
};};};if _edc ==_babc {return false ;};return ;};func _gdf (_gfe _cc .Time ,_abfg string )[]byte {_ef :=[]byte {};_geg :=0;for _de :=0;_de < len (_abfg );_de ++{var _gbad string ;if _abfg [_de ]=='/'{_gbad =string (_abfg [_geg :_de ]);_geg =_de +1;}else if _de ==len (_abfg )-1{_gbad =string (_abfg [_geg :_de +1]);
}else {continue ;};switch _gbad {case "\u0079\u0079":_ef =_gfe .AppendFormat (_ef ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_ef =_gfe .AppendFormat (_ef ,"\u0032\u0030\u0030\u0036");case "\u006d":_ef =_gfe .AppendFormat (_ef ,"\u0031");case "\u006d\u006d":_ef =_gfe .AppendFormat (_ef ,"\u0030\u0031");
case "\u006d\u006d\u006d":_ef =_gfe .AppendFormat (_ef ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_ef =_gfe .AppendFormat (_ef ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _gfe .Month (){case _cc .January ,_cc .July ,_cc .June :_ef =append (_ef ,'J');
case _cc .February :_ef =append (_ef ,'M');case _cc .March ,_cc .May :_ef =append (_ef ,'M');case _cc .April ,_cc .August :_ef =append (_ef ,'A');case _cc .September :_ef =append (_ef ,'S');case _cc .October :_ef =append (_ef ,'O');case _cc .November :_ef =append (_ef ,'N');
case _cc .December :_ef =append (_ef ,'D');};case "\u0064":_ef =_gfe .AppendFormat (_ef ,"\u0032");case "\u0064\u0064":_ef =_gfe .AppendFormat (_ef ,"\u0030\u0032");case "\u0064\u0064\u0064":_ef =_gfe .AppendFormat (_ef ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_ef =_gfe .AppendFormat (_ef ,"\u004d\u006f\u006e\u0064\u0061\u0079");
default:_fd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_gbad );};if _abfg [_de ]=='/'{_ef =append (_ef ,'/');};};return _ef ;};const _afff int =34;
const _gce int =0;func (_dcf *Lexer )Lex (r _f .Reader ){_gaff ,_gec ,_fbc :=0,0,0;_gge :=-1;_cgc ,_dab ,_fbf :=0,0,0;_ =_dab ;_ =_fbf ;_dga :=1;_ =_dga ;_dda :=make ([]byte ,4096);_ggec :=false ;for !_ggec {_bgf :=0;if _cgc > 0{_bgf =_gec -_cgc ;};_gec =0;
_cag ,_edaa :=r .Read (_dda [_bgf :]);if _cag ==0||_edaa !=nil {_ggec =true ;};_fbc =_cag +_bgf ;if _fbc < len (_dda ){_gge =_fbc ;};{_gaff =_afff ;_cgc =0;_dab =0;_fbf =0;};{if _gec ==_fbc {goto _gcda ;};switch _gaff {case 34:goto _gfb ;case 35:goto _ddbg ;
case 0:goto _befe ;case 36:goto _eff ;case 37:goto _gdfa ;case 1:goto _fbd ;case 2:goto _agea ;case 38:goto _cdg ;case 3:goto _fbce ;case 4:goto _bfc ;case 39:goto _aba ;case 5:goto _acfg ;case 6:goto _efg ;case 7:goto _gcea ;case 8:goto _ecdf ;case 40:goto _eaf ;
case 9:goto _cgf ;case 41:goto _bfec ;case 10:goto _gbgg ;case 42:goto _cbd ;case 11:goto _ffdfg ;case 43:goto _abfgc ;case 44:goto _eeg ;case 45:goto _deb ;case 12:goto _fdd ;case 46:goto _ggff ;case 13:goto _gaec ;case 14:goto _eeca ;case 15:goto _gbgd ;
case 16:goto _badf ;case 47:goto _beb ;case 17:goto _ddg ;case 48:goto _ceca ;case 18:goto _eafe ;case 19:goto _cgfa ;case 20:goto _cfc ;case 49:goto _add ;case 50:goto _aeg ;case 21:goto _edec ;case 22:goto _agfd ;case 23:goto _bcd ;case 24:goto _gafd ;
case 25:goto _bfa ;case 51:goto _bedf ;case 26:goto _fde ;case 52:goto _fbdd ;case 53:goto _fda ;case 54:goto _aef ;case 55:goto _edb ;case 56:goto _afge ;case 57:goto _bcf ;case 27:goto _eac ;case 28:goto _fgg ;case 29:goto _fece ;case 30:goto _eeb ;case 31:goto _gfga ;
case 58:goto _fga ;case 32:goto _dcag ;case 59:goto _aae ;case 33:goto _edd ;case 60:goto _edag ;case 61:goto _fedb ;case 62:goto _fgc ;};goto _bebb ;_ecc :switch _fbf {case 2:{_gec =(_dab )-1;_dcf ._age .AddToken (FmtTypeDigit ,nil );};case 3:{_gec =(_dab )-1;
_dcf ._age .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_gec =(_dab )-1;};case 8:{_gec =(_dab )-1;_dcf ._age .AddToken (FmtTypePercent ,nil );};case 13:{_gec =(_dab )-1;_dcf ._age .AddToken (FmtTypeFraction ,_dda [_cgc :_dab ]);};case 14:{_gec =(_dab )-1;
_dcf ._age .AddToken (FmtTypeDate ,_dda [_cgc :_dab ]);};case 15:{_gec =(_dab )-1;_dcf ._age .AddToken (FmtTypeTime ,_dda [_cgc :_dab ]);};case 16:{_gec =(_dab )-1;_dcf ._age .AddToken (FmtTypeTime ,_dda [_cgc :_dab ]);};case 18:{_gec =(_dab )-1;};case 20:{_gec =(_dab )-1;
_dcf ._age .AddToken (FmtTypeLiteral ,_dda [_cgc :_dab ]);};case 21:{_gec =(_dab )-1;_dcf ._age .AddToken (FmtTypeLiteral ,_dda [_cgc +1:_dab -1]);};};goto _ddfg ;_dgd :_gec =(_dab )-1;{_dcf ._age .AddToken (FmtTypeFraction ,_dda [_cgc :_dab ]);};goto _ddfg ;
_bac :_gec =(_dab )-1;{_dcf ._age .AddToken (FmtTypeDigitOpt ,nil );};goto _ddfg ;_becd :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeDigitOptThousands ,nil );};goto _ddfg ;_abc :_gec =(_dab )-1;{_dcf ._age .AddToken (FmtTypePercent ,nil );};goto _ddfg ;
_bcg :_gec =(_dab )-1;{_dcf ._age .AddToken (FmtTypeDate ,_dda [_cgc :_dab ]);};goto _ddfg ;_aag :_gec =(_dab )-1;{_dcf ._age .AddToken (FmtTypeDigit ,nil );};goto _ddfg ;_gbaf :_gec =(_dab )-1;{_dcf ._age .AddToken (FmtTypeTime ,_dda [_cgc :_dab ]);};
goto _ddfg ;_gbce :_gec =(_dab )-1;{_dcf ._age .AddToken (FmtTypeLiteral ,_dda [_cgc :_dab ]);};goto _ddfg ;_fee :_dab =_gec +1;{_dcf ._age ._dd =true ;};goto _ddfg ;_ecd :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeLiteral ,_dda [_cgc :_dab ]);};goto _ddfg ;
_dge :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeDollar ,nil );};goto _ddfg ;_fca :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeComma ,nil );};goto _ddfg ;_ecae :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeDecimal ,nil );};goto _ddfg ;_ffa :_dab =_gec +1;
{_dcf .nextFmt ();};goto _ddfg ;_bca :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeText ,nil );};goto _ddfg ;_dbg :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeUnderscore ,nil );};goto _ddfg ;_dede :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypeLiteral ,_dda [_cgc :_dab ]);
};goto _ddfg ;_gff :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypeLiteral ,_dda [_cgc +1:_dab -1]);};goto _ddfg ;_ddae :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypeDigitOpt ,nil );};goto _ddfg ;_dfad :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypeFraction ,_dda [_cgc :_dab ]);
};goto _ddfg ;_affc :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypePercent ,nil );};goto _ddfg ;_ggf :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypeDate ,_dda [_cgc :_dab ]);};goto _ddfg ;_cgdf :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypeDigit ,nil );
};goto _ddfg ;_bfe :_dab =_gec ;_gec --;{_dcf ._age .AddToken (FmtTypeTime ,_dda [_cgc :_dab ]);};goto _ddfg ;_fcf :_dab =_gec ;_gec --;{};goto _ddfg ;_fbbgc :_dab =_gec +1;{_dcf ._age .IsExponential =true ;};goto _ddfg ;_abe :_dab =_gec +1;{_dcf ._age .AddToken (FmtTypeLiteral ,_dda [_cgc +1:_dab ]);
};goto _ddfg ;_ddfg :_cgc =0;if _gec ++;_gec ==_fbc {goto _acba ;};_gfb :_cgc =_gec ;switch _dda [_gec ]{case 34:goto _feb ;case 35:goto _dgea ;case 36:goto _dge ;case 37:goto _fgd ;case 44:goto _fca ;case 46:goto _ecae ;case 47:goto _agag ;case 48:goto _edcd ;
case 58:goto _beeb ;case 59:goto _ffa ;case 63:goto _facd ;case 64:goto _bca ;case 65:goto _ddce ;case 69:goto _bbbg ;case 71:goto _gaed ;case 91:goto _afac ;case 92:goto _eacc ;case 95:goto _dbg ;case 100:goto _agag ;case 104:goto _beeb ;case 109:goto _eea ;
case 115:goto _bce ;case 121:goto _bfac ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _agagc ;};goto _ecd ;_feb :_dab =_gec +1;_fbf =20;goto _bcae ;_bcae :if _gec ++;_gec ==_fbc {goto _abfgd ;};_ddbg :if _dda [_gec ]==34{goto _cfbe ;};goto _bbb ;_bbb :if _gec ++;
_gec ==_fbc {goto _ddfa ;};_befe :if _dda [_gec ]==34{goto _cfbe ;};goto _bbb ;_cfbe :_dab =_gec +1;_fbf =21;goto _abd ;_abd :if _gec ++;_gec ==_fbc {goto _fdfg ;};_eff :if _dda [_gec ]==34{goto _bbb ;};goto _gff ;_dgea :_dab =_gec +1;_fbf =3;goto _bfbe ;
_bfbe :if _gec ++;_gec ==_fbc {goto _fggf ;};_gdfa :switch _dda [_gec ]{case 35:goto _fcd ;case 37:goto _fcd ;case 44:goto _affca ;case 47:goto _gbcf ;case 48:goto _fcd ;case 63:goto _fcd ;};goto _ddae ;_fcd :if _gec ++;_gec ==_fbc {goto _bbd ;};_fbd :switch _dda [_gec ]{case 35:goto _fcd ;
case 37:goto _fcd ;case 47:goto _gbcf ;case 48:goto _fcd ;case 63:goto _fcd ;};goto _ecc ;_gbcf :if _gec ++;_gec ==_fbc {goto _bgfe ;};_agea :switch _dda [_gec ]{case 35:goto _efd ;case 37:goto _fcc ;case 48:goto _gcdd ;case 63:goto _efd ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _geb ;
};goto _ecc ;_efd :_dab =_gec +1;goto _afcf ;_afcf :if _gec ++;_gec ==_fbc {goto _dabf ;};_cdg :switch _dda [_gec ]{case 35:goto _efd ;case 37:goto _efd ;case 44:goto _efd ;case 46:goto _efd ;case 48:goto _efd ;case 63:goto _efd ;case 65:goto _ecb ;};goto _dfad ;
_ecb :if _gec ++;_gec ==_fbc {goto _acfa ;};_fbce :switch _dda [_gec ]{case 47:goto _cbe ;case 77:goto _dgb ;};goto _dgd ;_cbe :if _gec ++;_gec ==_fbc {goto _bfea ;};_bfc :if _dda [_gec ]==80{goto _cfd ;};goto _dgd ;_cfd :_dab =_gec +1;goto _dcad ;_dcad :if _gec ++;
_gec ==_fbc {goto _fbeg ;};_aba :if _dda [_gec ]==65{goto _ecb ;};goto _dfad ;_dgb :if _gec ++;_gec ==_fbc {goto _ade ;};_acfg :if _dda [_gec ]==47{goto _gef ;};goto _dgd ;_gef :if _gec ++;_gec ==_fbc {goto _ffcd ;};_efg :if _dda [_gec ]==80{goto _bbec ;
};goto _dgd ;_bbec :if _gec ++;_gec ==_fbc {goto _eaa ;};_gcea :if _dda [_gec ]==77{goto _cfd ;};goto _dgd ;_fcc :if _gec ++;_gec ==_fbc {goto _fbgg ;};_ecdf :switch _dda [_gec ]{case 35:goto _gcef ;case 37:goto _cfbce ;case 63:goto _gcef ;};if 48<=_dda [_gec ]&&_dda [_gec ]<=57{goto _bfgf ;
};goto _ecc ;_gcef :_dab =_gec +1;goto _bee ;_bee :if _gec ++;_gec ==_fbc {goto _gfeb ;};_eaf :switch _dda [_gec ]{case 35:goto _efd ;case 37:goto _gbgf ;case 44:goto _efd ;case 46:goto _efd ;case 48:goto _efd ;case 63:goto _efd ;case 65:goto _ecb ;};goto _dfad ;
_gbgf :if _gec ++;_gec ==_fbc {goto _ebbe ;};_cgf :switch _dda [_gec ]{case 35:goto _eec ;case 44:goto _eec ;case 46:goto _eec ;case 48:goto _eec ;case 63:goto _eec ;};goto _dgd ;_eec :_dab =_gec +1;goto _bcb ;_bcb :if _gec ++;_gec ==_fbc {goto _dgc ;};
_bfec :switch _dda [_gec ]{case 35:goto _eec ;case 44:goto _eec ;case 46:goto _eec ;case 48:goto _eec ;case 63:goto _eec ;case 65:goto _ecb ;};goto _dfad ;_cfbce :if _gec ++;_gec ==_fbc {goto _ddda ;};_gbgg :if _dda [_gec ]==37{goto _cfbce ;};if 48<=_dda [_gec ]&&_dda [_gec ]<=57{goto _bfgf ;
};goto _ecc ;_bfgf :_dab =_gec +1;_fbf =13;goto _dea ;_dea :if _gec ++;_gec ==_fbc {goto _efe ;};_cbd :switch _dda [_gec ]{case 35:goto _efd ;case 37:goto _egd ;case 44:goto _efd ;case 46:goto _efd ;case 48:goto _dbe ;case 63:goto _efd ;case 65:goto _ecb ;
};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _bfgf ;};goto _dfad ;_egd :if _gec ++;_gec ==_fbc {goto _gea ;};_ffdfg :switch _dda [_gec ]{case 35:goto _eec ;case 37:goto _cfbce ;case 44:goto _eec ;case 46:goto _eec ;case 63:goto _eec ;};if 48<=_dda [_gec ]&&_dda [_gec ]<=57{goto _bfgf ;
};goto _dgd ;_dbe :_dab =_gec +1;goto _fffe ;_fffe :if _gec ++;_gec ==_fbc {goto _acag ;};_abfgc :switch _dda [_gec ]{case 35:goto _efd ;case 37:goto _dbe ;case 44:goto _efd ;case 46:goto _efd ;case 48:goto _dbe ;case 63:goto _efd ;case 65:goto _ecb ;};
if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _bfgf ;};goto _dfad ;_gcdd :_dab =_gec +1;goto _ecgb ;_ecgb :if _gec ++;_gec ==_fbc {goto _gbda ;};_eeg :switch _dda [_gec ]{case 35:goto _efd ;case 37:goto _dbe ;case 44:goto _efd ;case 46:goto _efd ;case 48:goto _gcdd ;
case 63:goto _efd ;case 65:goto _ecb ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _geb ;};goto _dfad ;_geb :_dab =_gec +1;goto _fdg ;_fdg :if _gec ++;_gec ==_fbc {goto _egab ;};_deb :switch _dda [_gec ]{case 35:goto _efd ;case 37:goto _bfgf ;case 44:goto _efd ;
case 46:goto _efd ;case 48:goto _gcdd ;case 63:goto _efd ;case 65:goto _ecb ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _geb ;};goto _dfad ;_affca :if _gec ++;_gec ==_fbc {goto _fbdg ;};_fdd :if _dda [_gec ]==35{goto _becd ;};goto _bac ;_fgd :_dab =_gec +1;
_fbf =8;goto _gbac ;_gbac :if _gec ++;_gec ==_fbc {goto _fcac ;};_ggff :switch _dda [_gec ]{case 35:goto _dba ;case 37:goto _ccg ;case 48:goto _fce ;case 63:goto _dba ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _dcb ;};goto _affc ;_dba :if _gec ++;_gec ==_fbc {goto _fccd ;
};_gaec :switch _dda [_gec ]{case 35:goto _dba ;case 47:goto _gbcf ;case 48:goto _dba ;case 63:goto _dba ;};goto _abc ;_ccg :if _gec ++;_gec ==_fbc {goto _cbf ;};_eeca :if _dda [_gec ]==37{goto _ccg ;};if 48<=_dda [_gec ]&&_dda [_gec ]<=57{goto _dcb ;};
goto _ecc ;_dcb :if _gec ++;_gec ==_fbc {goto _gbcd ;};_gbgd :switch _dda [_gec ]{case 37:goto _ccg ;case 47:goto _gbcf ;};if 48<=_dda [_gec ]&&_dda [_gec ]<=57{goto _dcb ;};goto _ecc ;_fce :if _gec ++;_gec ==_fbc {goto _ece ;};_badf :switch _dda [_gec ]{case 35:goto _dba ;
case 37:goto _ccg ;case 47:goto _gbcf ;case 48:goto _fce ;case 63:goto _dba ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _dcb ;};goto _abc ;_agag :_dab =_gec +1;goto _fbbgcg ;_fbbgcg :if _gec ++;_gec ==_fbc {goto _dgg ;};_beb :switch _dda [_gec ]{case 47:goto _agag ;
case 100:goto _agag ;case 109:goto _agag ;case 121:goto _dbf ;};goto _ggf ;_dbf :if _gec ++;_gec ==_fbc {goto _fdgb ;};_ddg :if _dda [_gec ]==121{goto _agag ;};goto _bcg ;_edcd :_dab =_gec +1;_fbf =2;goto _gffa ;_gffa :if _gec ++;_gec ==_fbc {goto _cged ;
};_ceca :switch _dda [_gec ]{case 35:goto _fcd ;case 37:goto _afg ;case 47:goto _gbcf ;case 48:goto _effe ;case 63:goto _fcd ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _feg ;};goto _cgdf ;_afg :if _gec ++;_gec ==_fbc {goto _ecdc ;};_eafe :switch _dda [_gec ]{case 35:goto _fcd ;
case 37:goto _afg ;case 47:goto _gbcf ;case 48:goto _afg ;case 63:goto _fcd ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _dcb ;};goto _aag ;_effe :if _gec ++;_gec ==_fbc {goto _egg ;};_cgfa :switch _dda [_gec ]{case 35:goto _fcd ;case 37:goto _afg ;case 47:goto _gbcf ;
case 48:goto _effe ;case 63:goto _fcd ;};if 49<=_dda [_gec ]&&_dda [_gec ]<=57{goto _feg ;};goto _aag ;_feg :if _gec ++;_gec ==_fbc {goto _egad ;};_cfc :switch _dda [_gec ]{case 37:goto _dcb ;case 47:goto _gbcf ;};if 48<=_dda [_gec ]&&_dda [_gec ]<=57{goto _feg ;
};goto _ecc ;_agagc :_dab =_gec +1;_fbf =20;goto _eeed ;_eeed :if _gec ++;_gec ==_fbc {goto _efgf ;};_add :switch _dda [_gec ]{case 37:goto _dcb ;case 47:goto _gbcf ;};if 48<=_dda [_gec ]&&_dda [_gec ]<=57{goto _feg ;};goto _dede ;_beeb :_dab =_gec +1;
_fbf =15;goto _gfbb ;_gfbb :if _gec ++;_gec ==_fbc {goto _bfdg ;};_aeg :switch _dda [_gec ]{case 58:goto _beeb ;case 65:goto _fad ;case 104:goto _beeb ;case 109:goto _beeb ;case 115:goto _bce ;};goto _bfe ;_fad :if _gec ++;_gec ==_fbc {goto _gee ;};_edec :switch _dda [_gec ]{case 47:goto _fec ;
case 77:goto _abg ;};goto _ecc ;_fec :if _gec ++;_gec ==_fbc {goto _aggf ;};_agfd :if _dda [_gec ]==80{goto _beeb ;};goto _ecc ;_abg :if _gec ++;_gec ==_fbc {goto _egc ;};_bcd :if _dda [_gec ]==47{goto _gad ;};goto _ecc ;_gad :if _gec ++;_gec ==_fbc {goto _caa ;
};_gafd :if _dda [_gec ]==80{goto _fddc ;};goto _ecc ;_fddc :if _gec ++;_gec ==_fbc {goto _gfeg ;};_bfa :if _dda [_gec ]==77{goto _beeb ;};goto _ecc ;_bce :_dab =_gec +1;_fbf =15;goto _bfdd ;_bfdd :if _gec ++;_gec ==_fbc {goto _dac ;};_bedf :switch _dda [_gec ]{case 46:goto _bgff ;
case 58:goto _beeb ;case 65:goto _fad ;case 104:goto _beeb ;case 109:goto _beeb ;case 115:goto _bce ;};goto _bfe ;_bgff :if _gec ++;_gec ==_fbc {goto _ggd ;};_fde :if _dda [_gec ]==48{goto _cff ;};goto _gbaf ;_cff :_dab =_gec +1;_fbf =15;goto _beg ;_beg :if _gec ++;
_gec ==_fbc {goto _dgec ;};_fbdd :switch _dda [_gec ]{case 48:goto _fceb ;case 58:goto _beeb ;case 65:goto _fad ;case 104:goto _beeb ;case 109:goto _beeb ;case 115:goto _bce ;};goto _bfe ;_fceb :_dab =_gec +1;_fbf =15;goto _faf ;_faf :if _gec ++;_gec ==_fbc {goto _afb ;
};_fda :switch _dda [_gec ]{case 48:goto _beeb ;case 58:goto _beeb ;case 65:goto _fad ;case 104:goto _beeb ;case 109:goto _beeb ;case 115:goto _bce ;};goto _bfe ;_facd :_dab =_gec +1;_fbf =5;goto _dfb ;_dfb :if _gec ++;_gec ==_fbc {goto _cbg ;};_aef :switch _dda [_gec ]{case 35:goto _fcd ;
case 37:goto _fcd ;case 47:goto _gbcf ;case 48:goto _fcd ;case 63:goto _fcd ;};goto _fcf ;_ddce :_dab =_gec +1;_fbf =20;goto _gcfa ;_gcfa :if _gec ++;_gec ==_fbc {goto _fbegd ;};_edb :switch _dda [_gec ]{case 47:goto _fec ;case 77:goto _abg ;};goto _dede ;
_bbbg :if _gec ++;_gec ==_fbc {goto _bcee ;};_afge :switch _dda [_gec ]{case 43:goto _fbbgc ;case 45:goto _fbbgc ;};goto _dede ;_gaed :_dab =_gec +1;goto _bba ;_bba :if _gec ++;_gec ==_fbc {goto _fdbc ;};_bcf :if _dda [_gec ]==101{goto _cbdf ;};goto _dede ;
_cbdf :if _gec ++;_gec ==_fbc {goto _acee ;};_eac :if _dda [_gec ]==110{goto _ffe ;};goto _gbce ;_ffe :if _gec ++;_gec ==_fbc {goto _bde ;};_fgg :if _dda [_gec ]==101{goto _baad ;};goto _gbce ;_baad :if _gec ++;_gec ==_fbc {goto _aegd ;};_fece :if _dda [_gec ]==114{goto _fcdc ;
};goto _gbce ;_fcdc :if _gec ++;_gec ==_fbc {goto _acbg ;};_eeb :if _dda [_gec ]==97{goto _adfe ;};goto _gbce ;_adfe :if _gec ++;_gec ==_fbc {goto _gaa ;};_gfga :if _dda [_gec ]==108{goto _fee ;};goto _gbce ;_afac :_dab =_gec +1;_fbf =20;goto _dfae ;_dfae :if _gec ++;
_gec ==_fbc {goto _abb ;};_fga :switch _dda [_gec ]{case 104:goto _acc ;case 109:goto _acc ;case 115:goto _acc ;};goto _ebfc ;_ebfc :if _gec ++;_gec ==_fbc {goto _fcaf ;};_dcag :if _dda [_gec ]==93{goto _dff ;};goto _ebfc ;_dff :_dab =_gec +1;_fbf =18;
goto _cgee ;_fab :_dab =_gec +1;_fbf =16;goto _cgee ;_cgee :if _gec ++;_gec ==_fbc {goto _bedd ;};_aae :if _dda [_gec ]==93{goto _dff ;};goto _ebfc ;_acc :if _gec ++;_gec ==_fbc {goto _cae ;};_edd :if _dda [_gec ]==93{goto _fab ;};goto _ebfc ;_eacc :if _gec ++;
_gec ==_fbc {goto _feef ;};_edag :goto _abe ;_eea :_dab =_gec +1;_fbf =14;goto _fgaa ;_fgaa :if _gec ++;_gec ==_fbc {goto _ddfgf ;};_fedb :switch _dda [_gec ]{case 47:goto _agag ;case 58:goto _beeb ;case 65:goto _fad ;case 100:goto _agag ;case 104:goto _beeb ;
case 109:goto _eea ;case 115:goto _bce ;case 121:goto _dbf ;};goto _ggf ;_bfac :if _gec ++;_gec ==_fbc {goto _ffac ;};_fgc :if _dda [_gec ]==121{goto _agag ;};goto _dede ;_bebb :_acba :_gaff =34;goto _gcda ;_abfgd :_gaff =35;goto _gcda ;_ddfa :_gaff =0;
goto _gcda ;_fdfg :_gaff =36;goto _gcda ;_fggf :_gaff =37;goto _gcda ;_bbd :_gaff =1;goto _gcda ;_bgfe :_gaff =2;goto _gcda ;_dabf :_gaff =38;goto _gcda ;_acfa :_gaff =3;goto _gcda ;_bfea :_gaff =4;goto _gcda ;_fbeg :_gaff =39;goto _gcda ;_ade :_gaff =5;
goto _gcda ;_ffcd :_gaff =6;goto _gcda ;_eaa :_gaff =7;goto _gcda ;_fbgg :_gaff =8;goto _gcda ;_gfeb :_gaff =40;goto _gcda ;_ebbe :_gaff =9;goto _gcda ;_dgc :_gaff =41;goto _gcda ;_ddda :_gaff =10;goto _gcda ;_efe :_gaff =42;goto _gcda ;_gea :_gaff =11;
goto _gcda ;_acag :_gaff =43;goto _gcda ;_gbda :_gaff =44;goto _gcda ;_egab :_gaff =45;goto _gcda ;_fbdg :_gaff =12;goto _gcda ;_fcac :_gaff =46;goto _gcda ;_fccd :_gaff =13;goto _gcda ;_cbf :_gaff =14;goto _gcda ;_gbcd :_gaff =15;goto _gcda ;_ece :_gaff =16;
goto _gcda ;_dgg :_gaff =47;goto _gcda ;_fdgb :_gaff =17;goto _gcda ;_cged :_gaff =48;goto _gcda ;_ecdc :_gaff =18;goto _gcda ;_egg :_gaff =19;goto _gcda ;_egad :_gaff =20;goto _gcda ;_efgf :_gaff =49;goto _gcda ;_bfdg :_gaff =50;goto _gcda ;_gee :_gaff =21;
goto _gcda ;_aggf :_gaff =22;goto _gcda ;_egc :_gaff =23;goto _gcda ;_caa :_gaff =24;goto _gcda ;_gfeg :_gaff =25;goto _gcda ;_dac :_gaff =51;goto _gcda ;_ggd :_gaff =26;goto _gcda ;_dgec :_gaff =52;goto _gcda ;_afb :_gaff =53;goto _gcda ;_cbg :_gaff =54;
goto _gcda ;_fbegd :_gaff =55;goto _gcda ;_bcee :_gaff =56;goto _gcda ;_fdbc :_gaff =57;goto _gcda ;_acee :_gaff =27;goto _gcda ;_bde :_gaff =28;goto _gcda ;_aegd :_gaff =29;goto _gcda ;_acbg :_gaff =30;goto _gcda ;_gaa :_gaff =31;goto _gcda ;_abb :_gaff =58;
goto _gcda ;_fcaf :_gaff =32;goto _gcda ;_bedd :_gaff =59;goto _gcda ;_cae :_gaff =33;goto _gcda ;_feef :_gaff =60;goto _gcda ;_ddfgf :_gaff =61;goto _gcda ;_ffac :_gaff =62;goto _gcda ;_gcda :{};if _gec ==_gge {switch _gaff {case 35:goto _dede ;case 0:goto _ecc ;
case 36:goto _gff ;case 37:goto _ddae ;case 1:goto _ecc ;case 2:goto _ecc ;case 38:goto _dfad ;case 3:goto _dgd ;case 4:goto _dgd ;case 39:goto _dfad ;case 5:goto _dgd ;case 6:goto _dgd ;case 7:goto _dgd ;case 8:goto _ecc ;case 40:goto _dfad ;case 9:goto _dgd ;
case 41:goto _dfad ;case 10:goto _ecc ;case 42:goto _dfad ;case 11:goto _dgd ;case 43:goto _dfad ;case 44:goto _dfad ;case 45:goto _dfad ;case 12:goto _bac ;case 46:goto _affc ;case 13:goto _abc ;case 14:goto _ecc ;case 15:goto _ecc ;case 16:goto _abc ;
case 47:goto _ggf ;case 17:goto _bcg ;case 48:goto _cgdf ;case 18:goto _aag ;case 19:goto _aag ;case 20:goto _ecc ;case 49:goto _dede ;case 50:goto _bfe ;case 21:goto _ecc ;case 22:goto _ecc ;case 23:goto _ecc ;case 24:goto _ecc ;case 25:goto _ecc ;case 51:goto _bfe ;
case 26:goto _gbaf ;case 52:goto _bfe ;case 53:goto _bfe ;case 54:goto _fcf ;case 55:goto _dede ;case 56:goto _dede ;case 57:goto _dede ;case 27:goto _gbce ;case 28:goto _gbce ;case 29:goto _gbce ;case 30:goto _gbce ;case 31:goto _gbce ;case 58:goto _dede ;
case 32:goto _ecc ;case 59:goto _ecc ;case 33:goto _gbce ;case 60:goto _dede ;case 61:goto _ggf ;case 62:goto _dede ;};};};if _cgc > 0{copy (_dda [0:],_dda [_cgc :]);};};_ =_gge ;if _gaff ==_babc {_fd .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");
};};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func Parse (s string )[]Format {_eca :=Lexer {};
_eca .Lex (_g .NewReader (s ));_eca ._gege =append (_eca ._gege ,_eca ._age );return _eca ._gege ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _e .Abs (v )>=_cd ||_e .Abs (v )<=_cda &&v !=0{return _fbbg (v );};_eee :=make ([]byte ,0,15);_eee =_d .AppendFloat (_eee ,v ,'f',-1,64);if len (_eee )> 11{_eae :=_eee [11]-'0';if _eae >=5&&_eae <=9{_eee [10]++;
_eee =_eee [0:11];_eee =_afa (_eee );};_eee =_eee [0:11];}else if len (_eee )==11{if _eee [len (_eee )-1]=='9'{_eee [len (_eee )-1]++;_eee =_afa (_eee );};};_eee =_aga (_eee );return string (_eee );};func (_cfbc *Lexer )nextFmt (){_cfbc ._gege =append (_cfbc ._gege ,_cfbc ._age );
_cfbc ._age =Format {}};const _cd =1e11;const _ebbc int =-1;func (_gb FmtType )String ()string {if _gb >=FmtType (len (_cb )-1){return _c .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_gb );};return _gc [_cb [_gb ]:_cb [_gb +1]];
};const _cda =1e-10;func _bdfb (_ebda _cc .Time )_cc .Time {_ebda =_ebda .UTC ();return _cc .Date (_ebda .Year (),_ebda .Month (),_ebda .Day (),_ebda .Hour (),_ebda .Minute (),_ebda .Second (),_ebda .Nanosecond (),_cc .Local );};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_gbf :=Parse (f );var _gf Format ;if len (_gbf )==1{_gf =_gbf [0];}else if len (_gbf )==4{_gf =_gbf [3];};_af :=false ;for _ ,_eb :=range _gf .Whole {if _eb .Type ==FmtTypeText {_af =true ;};};if !_af {return v ;
};_bbf :=_ff .Buffer {};for _ ,_df :=range _gf .Whole {switch _df .Type {case FmtTypeLiteral :_bbf .WriteByte (_df .Literal );case FmtTypeText :_bbf .WriteString (v );};};return _bbf .String ();};const _db int =34;func _affg (_bef int64 )int64 {if _bef < 0{return -_bef ;
};return _bef ;};func _fg (_eed ,_afc float64 ,_aea Format )[]byte {if len (_aea .Fractional )==0{return nil ;};_bda :=_d .AppendFloat (nil ,_eed ,'f',-1,64);if len (_bda )> 2{_bda =_bda [2:];}else {_bda =nil ;};_dfa :=make ([]byte ,0,len (_bda ));_dfa =append (_dfa ,'.');
_dca :=0;_aca :for _bgg :=0;_bgg < len (_aea .Fractional );_bgg ++{_fa :=_bgg ;_bfd :=_aea .Fractional [_bgg ];switch _bfd .Type {case FmtTypeDigit :if _fa < len (_bda ){_dfa =append (_dfa ,_bda [_fa ]);_dca ++;}else {_dfa =append (_dfa ,'0');};case FmtTypeDigitOpt :if _fa >=0{_dfa =append (_dfa ,_bda [_fa ]);
_dca ++;}else {break _aca ;};case FmtTypeLiteral :_dfa =append (_dfa ,_bfd .Literal );default:_fd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_bfd );
};};return _dfa ;};const _gc ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
func _facg (_cfgg _cc .Time ,_cdd float64 ,_gbg string )[]byte {_bed :=[]byte {};_affa :=0;for _cge :=0;_cge < len (_gbg );_cge ++{var _aed string ;if _gbg [_cge ]==':'{_aed =string (_gbg [_affa :_cge ]);_affa =_cge +1;}else if _cge ==len (_gbg )-1{_aed =string (_gbg [_affa :_cge +1]);
}else {continue ;};switch _aed {case "\u0064":_bed =_cfgg .AppendFormat (_bed ,"\u0032");case "\u0068":_bed =_cfgg .AppendFormat (_bed ,"\u0033");case "\u0068\u0068":_bed =_cfgg .AppendFormat (_bed ,"\u0031\u0035");case "\u006d":_bed =_cfgg .AppendFormat (_bed ,"\u0034");
case "\u006d\u006d":_bed =_cfgg .AppendFormat (_bed ,"\u0030\u0034");case "\u0073":_bed =_cfgg .Round (_cc .Second ).AppendFormat (_bed ,"\u0035");case "\u0073\u002e\u0030":_bed =_cfgg .Round (_cc .Second /10).AppendFormat (_bed ,"\u0035\u002e\u0030");
case "\u0073\u002e\u0030\u0030":_bed =_cfgg .Round (_cc .Second /100).AppendFormat (_bed ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_bed =_cfgg .Round (_cc .Second /1000).AppendFormat (_bed ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_bed =_cfgg .Round (_cc .Second ).AppendFormat (_bed ,"\u0030\u0035");
case "\u0073\u0073\u002e\u0030":_bed =_cfgg .Round (_cc .Second /10).AppendFormat (_bed ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_bed =_cfgg .Round (_cc .Second /100).AppendFormat (_bed ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_bed =_cfgg .Round (_cc .Second /1000).AppendFormat (_bed ,"\u0030\u0035\u002e\u0030\u0030\u0030");
case "\u0041\u004d\u002fP\u004d":_bed =_cfgg .AppendFormat (_bed ,"\u0050\u004d");case "\u005b\u0068\u005d":_bed =_d .AppendInt (_bed ,int64 (_cdd *24),10);case "\u005b\u006d\u005d":_bed =_d .AppendInt (_bed ,int64 (_cdd *24*60),10);case "\u005b\u0073\u005d":_bed =_d .AppendInt (_bed ,int64 (_cdd *24*60*60),10);
case "":default:_fd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_aed );};if _gbg [_cge ]==':'{_bed =append (_bed ,':');};};return _bed ;
};

// AddToken adds a format token to the format.
func (_dc *Format )AddToken (t FmtType ,l []byte ){if _dc ._ag {_dc ._ag =false ;return ;};switch t {case FmtTypeDecimal :_dc ._dg =true ;case FmtTypeUnderscore :_dc ._ag =true ;case FmtTypeText :_dc .Whole =append (_dc .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_dc .Whole =append (_dc .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_dc ._b =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ee :=range l {if _dc .IsExponential {_dc .Exponent =append (_dc .Exponent ,Token {Type :t ,Literal :_ee });
}else if !_dc ._dg {_dc .Whole =append (_dc .Whole ,Token {Type :t ,Literal :_ee });}else {_dc .Fractional =append (_dc .Fractional ,Token {Type :t ,Literal :_ee });};};case FmtTypeDigitOptThousands :_dc ._ec =true ;case FmtTypeFraction :_ce :=_g .Split (string (l ),"\u002f");
if len (_ce )==2{_dc ._ed =true ;_dc ._cg ,_ =_d .ParseInt (_ce [1],10,64);for _ ,_bb :=range _ce [1]{if _bb =='?'||_bb =='0'{_dc ._fb ++;};};};default:_fd .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};const _babc int =-1;const _fbe int =34;const _gcd int =0;type Lexer struct{_age Format ;_gege []Format ;};func _ceb (_gfg int64 ,_bdb Format )[]byte {if !_bdb .IsExponential ||len (_bdb .Exponent )==0{return nil ;};_fdb :=_d .AppendInt (nil ,_affg (_gfg ),10);
_gaf :=make ([]byte ,0,len (_fdb )+2);_gaf =append (_gaf ,'E');if _gfg >=0{_gaf =append (_gaf ,'+');}else {_gaf =append (_gaf ,'-');_gfg *=-1;};_gae :=0;_ead :for _aeac :=len (_bdb .Exponent )-1;_aeac >=0;_aeac --{_ddcb :=len (_fdb )-1-_gae ;_gfa :=_bdb .Exponent [_aeac ];
switch _gfa .Type {case FmtTypeDigit :if _ddcb >=0{_gaf =append (_gaf ,_fdb [_ddcb ]);_gae ++;}else {_gaf =append (_gaf ,'0');};case FmtTypeDigitOpt :if _ddcb >=0{_gaf =append (_gaf ,_fdb [_ddcb ]);_gae ++;}else {for _fdfe :=_aeac ;_fdfe >=0;_fdfe --{_bbc :=_bdb .Exponent [_fdfe ];
if _bbc .Type ==FmtTypeLiteral {_gaf =append (_gaf ,_bbc .Literal );};};break _ead ;};case FmtTypeLiteral :_gaf =append (_gaf ,_gfa .Literal );default:_fd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_gfa );
};};if _gae < len (_fdb ){_gaf =append (_gaf ,_fdb [len (_fdb )-_gae -1:_gae -1]...);};_gba (_gaf [2:]);return _gaf ;};